{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Define design system foundation (colors, typography, spacing)",
        "description": "Build the core design system foundations aligned with hostel branding and accessibility guidelines.",
        "details": "• Technology: Next.js 14+ with React, TypeScript, and Tailwind CSS for color, typography, spacing, and radii.\n• Import or rebuild the official hostel logo and extract a **blue + brownish-yellow** primary palette; define neutral grayscale for backgrounds and borders.\n• Set light **white & blue** interface theme tokens (backgrounds, surfaces, text, borders, focus states) using Tailwind theme tokens and CSS variables.\n• Establish typography scale with high readability (e.g., Inter, Roboto, or system-safe Sans) and map to heading, subheading, body, caption, and button styles.\n• Define 4–8px-based spacing scale (4, 8, 12, 16, 24, 32, 40, 64) and border radius tokens (0, 4, 8) with institutional, non-playful look.\n• Include elevation tokens (shadows) for modals, dropdowns, and sticky elements but keep them subtle to maintain a clean institutional feel.\n• Ensure minimum contrast ratios target WCAG AA (4.5:1 for body text, 3:1 for large text) using axe DevTools, WAVE, or similar accessibility tools.\n• Create design foundations that can be exported or mirrored into React components with Tailwind (name tokens with dev-friendly naming like `color.bg.surface`, `font.size.sm`).",
        "testStrategy": "• Verify all text/background color combinations meet WCAG AA using a contrast checker plugin.\n• Check that all text styles and color styles are reused in sample pages/components (no local ad-hoc styles).\n• Ask dev lead to confirm naming is easily mappable to CSS variables or design tokens.\n• Test on both desktop and mobile pages/components to ensure typography and spacing scales look balanced.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Brand discovery and logo import",
            "description": "Research hostel branding, import or rebuild the official logo, and extract the primary blue + brownish-yellow palette in Figma.",
            "dependencies": [],
            "details": "Use to import logo SVG/PNG; extract primary colors from logo using color picker tools or design specs; create initial color variables under 'brand/primary'; document palette source and rationale in a dedicated component.",
            "status": "done",
            "testStrategy": "Verify logo matches official assets (pixel-perfect comparison); check palette extraction accuracy against logo; ensure colors are stored as global variables for reuse; review with brand stakeholder for approval.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T05:13:16.083Z"
          },
          {
            "id": 2,
            "title": "Color system and tokens with WCAG contrast validation",
            "description": "Define light white & blue interface theme tokens (backgrounds, surfaces, text, borders, focus) and neutral grayscale; validate all combinations meet WCAG AA using plugins.",
            "dependencies": [
              1
            ],
            "details": "Create primitive color variables (e.g., blue/100-900, gray/100-900) and semantic tokens (color/bg/surface, color/text/primary); set focus states with 3:1+ contrast; use axe DevTools, WAVE, or WebAIM contrast checker for checks.",
            "status": "done",
            "testStrategy": "Run contrast checker on all text/background pairs (target 4.5:1 body, 3:1 large); test theme modes (light only); confirm no local colors used in sample pages/components; export tokens to verify JSON structure.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T05:13:16.091Z"
          },
          {
            "id": 3,
            "title": "Typography scale, text styles, and type tokens",
            "description": "Establish typography scale using Inter/Roboto/system sans-serif; create text styles for heading, subheading, body, caption, button with high readability.",
            "dependencies": [
              2
            ],
            "details": "Define font variables (font/family/base, font/size/h1-600px down to caption-12px); map to Tailwind typography utilities; ensure line-height 1.4-1.6x; pair with color tokens for contrast.",
            "status": "done",
            "testStrategy": "Apply styles to sample paragraphs/headings; check readability at small sizes; validate contrast with color tokens; test variable swaps for consistency across pages/components.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T05:13:16.101Z"
          },
          {
            "id": 4,
            "title": "Spacing, radii, elevation, and foundational tokens",
            "description": "Define 4–8px spacing scale (4,8,12,16,24,32,40,64), border radii (0,4,8), and subtle elevation shadows for institutional look using variables.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create number variables for spacing/radius; effect styles for shadows (e.g., elevation/1-3 with low opacity); apply to sample pages/components for modals/dropdowns; keep non-playful, clean aesthetic.",
            "status": "done",
            "testStrategy": "Resize pages/components to confirm spacing consistency via Flexbox/Grid; check shadow subtlety on white/blue backgrounds; validate token reuse in prototypes; measure pixel-perfect alignment.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T05:13:16.108Z"
          },
          {
            "id": 5,
            "title": "Dev-ready token naming, documentation, and sample pages/components",
            "description": "Apply dev-friendly naming (color.bg.surface, font.size.sm); document all tokens and create sample implementation pages/components for React/Next.js export.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use hierarchical naming in variables (primitive/semantic); build documentation page with pages/components showing tokens in context; create exportable sample UI (button, card) using only tokens/styles.",
            "status": "done",
            "testStrategy": "Review naming with dev lead for CSS mapping; check 100% token reuse (no overrides); working application samples for responsiveness; validate export to tokens JSON; stakeholder sign-off on docs.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T05:13:16.116Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 1 into subtasks covering: (1) Brand discovery and logo import; (2) Color system and tokens with WCAG contrast validation; (3) Typography scale, text styles, and type tokens; (4) Spacing, radii, elevation, and other foundational tokens; (5) Dev-ready token naming, documentation, and sample implementation frames. For each subtask, specify deliverables, review criteria, and how to test accessibility and token reuse in Figma.",
        "updatedAt": "2025-12-20T05:42:26.132Z"
      },
      {
        "id": "2",
        "title": "Define reusable base UI components library",
        "description": "Implement atomic and composite UI components (buttons, inputs, tables, badges, modals) as a React component library.",
        "details": "• Technology: React components, props and conditional styles, Flexbox and CSS Grid, variables for states.\n• Create atomic components: buttons (primary, secondary, ghost, destructive), text fields, textareas, dropdowns, date/time pickers, radio/checkbox, toggles, chips, tags.\n• Create data components: tables with sortable headers, pagination, filter chips; cards; lists; tabs; accordions; steppers (for multi-step forms); status badges (Paid, Pending, Failed, Overdue, Approved, Rejected, Under Review, New, Verified, etc.).\n• Include UI patterns: confirmation modals, side panels, toast notifications, banners (e.g., DPDP consent banners), empty states, error states.\n• Add props and conditional styles for sizes (desktop, mobile), states (default, hover, focus, disabled, error, success), and icons where necessary.\n• Implement print-optimized containers (A4 width grids, simplified color, high contrast, printer-friendly) for letters, receipts, undertakings.\n• Use Flexbox/Grid and responsive CSS so components are responsive and easily dropped into React/Next.js layouts.\n• Document usage guidance in a dedicated “Design System → Components” page with naming consistent with common libraries (e.g., MUI, Ant Design) for easier dev mapping.",
        "testStrategy": "• Place each component variant in test pages/components for desktop and mobile to confirm responsiveness and spacing.\n• Validate every form element has clear focus state and error state.\n• Run a consistency check: ensure all screens use only shared React components (Figma’s “Instance” usage, no duplicated code).\n• Print to PDF a sample of print-optimized components to confirm margins and legibility.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define component architecture, naming conventions, and variables strategy",
            "description": "Establish the overall component architecture, naming conventions, and variables strategy for the base UI library in before creating components.",
            "dependencies": [
              2
            ],
            "details": "• Decide on atomic → composite hierarchy (e.g., Atoms/Molecules/Organisms or Base/Patterns) and map all required components into this structure.\n• Define component naming pattern using slashes (e.g., `Form/Input/Text`, `Button/Primary/LG`) and variant properties (e.g., `size=sm|md|lg`, `state=default|hover|focus|disabled|error|success`).\n• Set up variables for semantic color, typography, spacing, radii, and state tokens coming from Task 1, and define how components will consume them (e.g., semantic tokens only, no raw hex).\n• Decide when to use props and conditional styles vs React props (e.g., boolean props for icon on/off, label visibility) to keep the library maintainable.\n• Plan a folder/page structure for the library file (e.g., Foundations, Components/Atoms, Components/Patterns, Test Frames).\nAcceptance criteria:\n• Written one-pager describing architecture, naming, and variable usage, reviewed with implement + dev.\n• All created components follow the agreed naming and variant property schema.\n• No component uses raw colors or typography outside Task 1 styles/variables.\nTest pages/components:\n• Create a dedicated “Architecture & Tokens Sandbox” page with a few sample components wired to variables to validate the strategy before full rollout.",
            "status": "done",
            "testStrategy": "Review a sample of at least 10 components against the written conventions to ensure consistent naming, variant properties, and variable usage.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T05:45:48.255Z"
          },
          {
            "id": 2,
            "title": "Create core form controls with full state coverage",
            "description": "Implement reusable atomic form controls (inputs, textareas, dropdowns, pickers, radio, checkbox, toggles) as React components with all key states and sizes.",
            "dependencies": [
              1
            ],
            "details": "• List all required form controls: text input (single-line), textarea, dropdown/select, date picker, time picker, radio group, checkbox, toggle/switch, search field.\n• For each control, create base component with props and conditional styles for size (sm, md, lg where needed) and state (default, hover, focus, filled, disabled, error, success, read-only).\n• Use Flexbox/Grid and responsive CSS so labels, helper text, and icons adjust to different label lengths and container widths.\n• Connect all colors, typography, spacing, and radii to design system tokens from Task 1.\n• Include optional adornments (leading/trailing icons, clear button) as React props or props and conditional styles.\nAcceptance criteria:\n• Each control exists as a master component with documented variant properties in Figma.\n• All interactive states have distinct visual treatment including clear focus outlines and error messaging placement.\n• Controls resize correctly in horizontal and vertical directions without breaking alignment.\nTest pages/components:\n• Create a \"Form Controls – Desktop\" and \"Form Controls – Mobile\" component placing all props and conditional styles in sample form layouts to test spacing, wrapping, and state transitions visually.",
            "status": "done",
            "testStrategy": "Inspect controls in working application mode to verify focus order and state changes; manually resize parent pages/components to confirm responsiveness of each control.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.258Z"
          },
          {
            "id": 3,
            "title": "Implement buttons, chips, and tags with size and state props and conditional styles",
            "description": "Create button, chip, and tag components with consistent sizes, visual hierarchy, and interactive states, aligned to the design system tokens.",
            "dependencies": [
              1
            ],
            "details": "• Define button types: primary, secondary, ghost, destructive, and any icon-only props and conditional styles.\n• For buttons, create props and conditional styles for size (xs, sm, md, lg if needed) and state (default, hover, focus, active/pressed, disabled, loading) with consistent padding and icon spacing.\n• Implement chips and tags for filters, status, and input chips, with props and conditional styles for selected vs unselected, with/without close icon, and different emphasis levels if required.\n• Ensure text truncation and long labels behave correctly using Flexbox/Grid and min/max width responsive CSS.\n• Map colors and typography strictly to Task 1 tokens, and align naming with common UI libraries (e.g., `Button/Primary`, `Chip/Filter`).\nAcceptance criteria:\n• All button, chip, and tag types exist as components with clearly labeled variant properties.\n• Visual hierarchy between primary, secondary, ghost, and destructive is obvious in test pages/components.\n• Icon placement options (left/right, icon-only) are available without creating redundant components.\nTest pages/components:\n• Create \"Buttons & Chips – States\" pages/components for desktop and mobile with all props and conditional styles placed on both light and error/success backgrounds to verify contrast and legibility.",
            "status": "done",
            "testStrategy": "Use accessibility and contrast-check plugins on button and chip text; run a quick audit to confirm only library instances are used in sample flows.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.265Z"
          },
          {
            "id": 4,
            "title": "Build data display components: tables, lists, cards, badges, steppers, tabs, accordions",
            "description": "Construct composite data display components that are flexible, responsive, and reuse atomic components where possible.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "• Implement table components with header, row, and cell subcomponents, including sortable header icons, pagination controls, and filter chips; ensure row density props and conditional styles (compact, regular).\n• Create card patterns for key use cases (summary cards, list cards) with optional sections (title, meta, status, actions) using React props.\n• Define list patterns (simple lists, media lists) and align spacing with grids.\n• Create steppers for multi-step forms with props and conditional styles for current, completed, upcoming, and error steps (horizontal and vertical where needed).\n• Implement tabs and accordions with clear selected/hover/focus/disabled states and support for long labels.\n• Build status badges (Paid, Pending, Failed, Overdue, Approved, Rejected, Under Review, New, Verified, etc.) as a single base component with props and conditional styles by status and emphasis.\nAcceptance criteria:\n• Each data component is a single source-of-truth component with props and conditional styles/properties for states and densities instead of duplicated pages/components.\n• Tables, tabs, and accordions behave correctly when their width changes and when label text wraps.\n• Status badges are driven by a `status` variant or property and use semantic tokens for color.\nTest pages/components:\n• Assemble \"Data Components – Desktop\" and \"Data Components – Mobile\" pages/components that mimic realistic screens (e.g., table with filters, card grid, stepper in a form) to validate composition and responsiveness.",
            "status": "done",
            "testStrategy": "Resize test pages/components and sample screens to check table column behavior, card wrapping, and badge legibility; confirm all instances link back to the shared components library.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.275Z"
          },
          {
            "id": 5,
            "title": "Create overlays and feedback patterns: modals, side panels, toasts, banners, empty and error states",
            "description": "Implement reusable overlay and feedback components covering confirmations, notifications, and system/empty/error states.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "• Define base modal component with header, body, and footer slots that can host form controls and buttons; include props and conditional styles for confirmation, destructive, and full-screen modes.\n• Create side panel component patterns for contextual details or editing, with responsive widths.\n• Implement toast notifications and inline banners (including DPDP consent banners) with props and conditional styles for types (info, success, warning, error) and optional actions.\n• Create templated empty states and error states using illustration or icon placeholders, title, description, and primary/secondary actions.\n• Ensure focus management considerations are documented (what should receive focus on open/close) for dev handoff.\nAcceptance criteria:\n• At least one reusable base component exists for each overlay/feedback pattern with documented variant properties.\n• Overlays accommodate different content lengths and button configurations without layout breaking.\n• Empty and error states are consistent across modules in typography, iconography, and spacing.\nTest pages/components:\n• Build \"Overlays & Feedback – Desktop\" and \"Overlays & Feedback – Mobile\" pages/components simulating key flows (e.g., destructive confirmation, DPDP consent, form error) to visually validate hierarchy and spacing.",
            "status": "done",
            "testStrategy": "Build and test sample flows triggering modals/toasts/banners to check visual stacking, alignment, and that all overlays reuse the same base components.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.282Z"
          },
          {
            "id": 6,
            "title": "Implement responsive behavior with Flexbox/Grid and responsive CSS for desktop and mobile",
            "description": "Apply Flexbox/Grid, responsive CSS, and layout grids so all components behave predictably across desktop and mobile breakpoints.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "• Define component-level layout rules aligned with Task 24 breakpoints and grids (e.g., desktop 12-col, mobile 4-col).\n• For each component family (forms, buttons, tables, cards, overlays), configure Flexbox/Grid and responsive CSS to handle width changes, content growth, and multi-line text.\n• Create size props and conditional styles (desktop vs mobile where meaningfully different) only when responsive rules are insufficient.\n• Ensure components can be dropped into common container widths without manual overrides.\nAcceptance criteria:\n• All major components support at least two tested sizes (desktop and mobile pages/components) without visual defects.\n• No critical component relies on manual resizing of inner layers; resizing is governed by Flexbox/Grid and responsive CSS.\n• Components align cleanly to layout grids defined in Task 24 when placed in example screens.\nTest pages/components:\n• Create a \"Responsive Stress Test\" page with desktop, tablet, and mobile pages/components, placing key components and aggressively resizing containers to validate wrapping and alignment.",
            "status": "done",
            "testStrategy": "Use Figma’s resize handles and layout grid overlays to confirm consistent behavior; spot-check a subset of application flows using only shared React components to verify real-world responsiveness.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.289Z"
          },
          {
            "id": 7,
            "title": "Document components in a dedicated design system page with dev mapping",
            "description": "Create a “Design System → Components” page documenting usage guidance and mapping to common UI libraries for developer handoff.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "• Set up a structured documentation page (or pages) grouping components into logical sections (Forms, Buttons, Data Display, Overlays, Feedback, Layout/Print).\n• For each component, include a short description, intended usage, do/don’t examples, and notes on accessibility states (focus, error, required fields).\n• Add mapping notes to common UI libraries (e.g., MUI `TextField`, Ant Implement `Table`) using consistent naming to ease implementation.\n• Include notes on expected behavior for edge cases (long text, missing data, loading states) and how props and conditional styles/properties should be used.\n• Document print-optimized containers for A4 letters, receipts, and undertakings, including margins, color reduction, and typography scale.\nAcceptance criteria:\n• All core component families appear on the documentation page with clear labels and usage notes.\n• Each documented component lists at least one analogue in MUI or Ant Implement where applicable.\n• Developers can navigate the page and understand which component to use for a given need without additional explanation.\nTest pages/components:\n• Embed example usage pages/components on the documentation page (e.g., mini screen mockups) demonstrating correct application of each component in context.",
            "status": "done",
            "testStrategy": "Conduct a quick review session with at least one designer and one developer walking through the doc page and verifying they can each identify correct components for 5–7 sample UI requirements.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.296Z"
          },
          {
            "id": 8,
            "title": "Run quality checks for accessibility, instance usage, and library performance",
            "description": "Audit the component library for accessibility coverage, correct instance usage, and performance, and fix identified issues.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "• Use accessibility plugins and manual review to confirm all interactive components have clear focus, hover, active, disabled, and error/success states and adequate contrast.\n• Run an instance usage audit across key product files to ensure screens use shared components, not detached or local copies.\n• Check component descriptions and naming for clarity and completeness, updating where needed.\n• Review library performance: identify overly complex components (deep nesting, many hidden layers) and refactor for efficiency while preserving behavior.\n• Establish a lightweight maintenance checklist and cadence for future audits.\nAcceptance criteria:\n• No critical accessibility gaps remain in core components (focus states and contrast meet agreed standards).\n• All target screens consume published library instances; detached instances are either justified or eliminated.\n• Library performance is acceptable (no major lag when opening, editing, or publishing components).\nTest pages/components:\n• Create a \"QC & Regression\" page with representative flows (forms, tables, overlays) exclusively using shared React components to serve as a baseline for future regression checks.",
            "status": "done",
            "testStrategy": "Perform a final pass using Figma’s library and performance tools plus contrast-check plugins; log and resolve issues in a short checklist before marking Task 2 as complete.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T10:31:39.303Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break Task 2 into subtasks: (1) Component architecture, naming conventions, and variables strategy; (2) Core form controls (inputs, textareas, dropdowns, pickers, radio, checkbox, toggles) with states; (3) Buttons and chips/tags with size and state variants; (4) Data display components (tables, lists, cards, badges, steppers, tabs, accordions); (5) Overlays and feedback (modals, toasts, banners, empty/error states); (6) Responsive behavior and Auto Layout/constraints for desktop vs mobile; (7) Component documentation page with usage guidance and mapping to common UI libraries; (8) Quality checks: instance usage, accessibility states, and performance of the library. For each, define acceptance criteria and test frames.",
        "updatedAt": "2025-12-21T10:31:39.303Z"
      },
      {
        "id": "3",
        "title": "Define role-based navigation structure and information architecture",
        "description": "Implement the global IA and navigation patterns for all roles: Applicant, Resident, Superintendent, Trustee, Accounts, Parent/Guardian.",
        "details": "• Create a sitemap listing all sections per role: Applicant (Application, Status), Resident (Dashboard, Fees, Leave, Room, Documents, Renewal, Exit), Superintendent (Applications, Leaves, Rooms, Communication, Config), Trustees (Applications forwarded, Interviews, Approvals), Accounts (Receivables, Logs, Exports), Parents (Dashboard, Fees view, Leave view).\n• Define navigation patterns: top nav vs side nav, breadcrumbs for deep sections, role-based nav items that only show relevant sections.\n• Map login entry points: Landing → Apply / Check Status / Login; then login-based redirection rules for each role.\n• Use user flow diagrams to show navigation paths between major states and access restrictions.\n• Ensure vertical selection (Boys Hostel / Girls Ashram / Dharamshala) affects content filters and labels across dashboards.\n• Consider scalability for future modules (Biometric, Visitor, Mess) with placeholder nav items baked into IA but visually disabled.\n• Provide a clear guidelines note so devs can implement role-based routing using front-end routing (e.g., React Router / Vue Router) with guard hooks.",
        "testStrategy": "• Review IA with stakeholders to confirm that every requirement from the PRD maps to at least one screen in the sitemap.\n• Conduct quick card-sorting or tree-testing with 2–3 sample users (internally) to validate discoverability of key tasks.\n• Walk through each persona’s lifecycle (applicant to alumni) ensuring no dead ends or navigation loops.\n• Check that vertical selection (Boys/Girls/Dharamshala) is consistently represented in nav labels and context breadcrumbs.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Requirements and content inventory per role based on PRD",
            "description": "Compile detailed requirements and content inventory for each role (Applicant, Resident, Superintendent, Trustee, Accounts, Parent/Guardian) from the PRD, listing all sections and key tasks.",
            "dependencies": [],
            "details": "Review PRD to map every requirement to specific screens/sections per role; create tabular inventory with columns for Role, Section, Key Features, PRD Reference; outputs include inventory spreadsheet or page with role cards detailing content needs.",
            "status": "done",
            "testStrategy": "Cross-check inventory against PRD for 100% coverage; review with PM/stakeholders to confirm no missing requirements or extraneous items.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T14:10:22.334Z"
          },
          {
            "id": 2,
            "title": "Global sitemap and role-based IA including future modules",
            "description": "Implement comprehensive global sitemap and role-specific information architecture, incorporating current sections and placeholders for future modules like Biometric, Visitor, Mess.",
            "dependencies": [
              1
            ],
            "details": "Build hierarchical sitemap in or Miro showing all roles' sections (e.g., Applicant: Application/Status; Resident: Dashboard/Fees/etc.); include visually disabled placeholders for scalability; define shared vs role-specific content; outputs: interactive sitemap diagram and IA documentation.",
            "status": "done",
            "testStrategy": "Validate hierarchy depth ≤3 levels; ensure future modules slotted without disrupting current flows; stakeholder sign-off on completeness.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T14:45:23.664Z"
          },
          {
            "id": 3,
            "title": "Navigation patterns selection and props and conditional styles for roles",
            "description": "Select and define navigation patterns (top nav, side nav, breadcrumbs, role-scoped items) with props and conditional styles for desktop/mobile and deep sections.",
            "dependencies": [
              1,
              2
            ],
            "details": "Evaluate patterns like vertical nav for dashboards, breadcrumbs for sub-sections, progressive disclosure; create examples showing role-based nav (e.g., side nav for Superintendent); document guidelines for top vs side nav usage; outputs: pattern library page and variant mockups.",
            "status": "done",
            "testStrategy": "Build and test 2-3 role navs and test resize responsiveness; confirm patterns align with Material Design/Userpilot best practices for task-oriented nav.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T14:53:59.887Z"
          },
          {
            "id": 4,
            "title": "Role-based routing and login/redirect rules in flow diagrams",
            "description": "Define login entry points, redirection rules post-login, and routing logic for each role, captured in detailed user flow diagrams.",
            "dependencies": [
              2,
              3
            ],
            "details": "Map flows: Landing → Apply/Check Status/Login → Role redirect (e.g., Applicant to Status); include guard hooks for access restrictions; use prototypes for paths; provide dev notes for React/Next.js Router implementation; outputs: flow diagrams and routing spec document.",
            "status": "done",
            "testStrategy": "Walkthrough diagrams for edge cases (wrong role login, role switch); dev review for routing feasibility.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T15:07:39.242Z"
          },
          {
            "id": 5,
            "title": "Vertical context propagation rules across dashboards",
            "description": "Establish rules for how vertical selection (Boys Hostel/Girls Ashram/Dharamshala) filters content, updates labels, and propagates through IA and nav.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Define context persistence (URL params, session state); show in how dashboards filter (e.g., Rooms list by vertical); update nav labels dynamically; outputs: propagation flow diagram, example screens with vertical props and conditional styles, dev guidelines for state management.",
            "status": "done",
            "testStrategy": "Test flows switching verticals mid-session; verify filters apply consistently across role sections.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T15:15:59.516Z"
          },
          {
            "id": 6,
            "title": "Validation activities for IA and navigation design",
            "description": "Conduct stakeholder reviews, internal card sorting/tree tests, and lifecycle walkthroughs to validate the IA and nav structure.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Schedule reviews with stakeholders; run card-sorting/tree-testing with 2-3 internal users per role; walkthrough full lifecycles (applicant→resident); gather feedback and iterate; outputs: validation report with findings, revised artifacts, approval sign-offs.",
            "status": "done",
            "testStrategy": "Measure task success rate >90% in tree tests; confirm stakeholder alignment on all PRD mappings; document changes from feedback.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T15:19:43.034Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break Task 3 into: (1) Requirements and content inventory per role based on PRD; (2) Global sitemap and role-based IA, including future modules; (3) Navigation patterns selection (top/side nav, breadcrumbs, role scoping) and variants; (4) Role-based routing and login/redirect rules, captured in flow diagrams; (5) Vertical (Boys/Girls/Dharamshala) context propagation rules; (6) Validation activities (stakeholder review, internal card sorting/tree tests, lifecycle walkthroughs). For each subtask, define outputs (diagrams, notes, example screens) and review criteria.",
        "updatedAt": "2025-12-21T15:19:43.034Z"
      },
      {
        "id": "4",
        "title": "Implement responsive landing page with vertical selection",
        "description": "Build the completed landing page implement emphasizing hostel overview, facilities, vertical selection, and CTAs.",
        "details": "• Use desktop and mobile pages/components with Flexbox/Grid to ensure responsiveness.\n• Sections: hero with hostel overview and values, discipline and safety highlights, amenities showcase, vertical selection cards (Boys Hostel, Girls Ashram, Dharamshala), visual step-by-step admission process timeline, announcements & notices, footer.\n• Vertical selection cards show short descriptions and lead into Applicant flow or login context; ensure card-style with relevant iconography but minimal visuals.\n• Admission process: implement a horizontal or vertical timeline with labeled steps (Apply → Verification → Interview → Approval → Payment → Room Allocation → Check-in).\n• CTAs: clearly styled buttons for **Apply Now**, **Check Application Status**, **Login**; align button hierarchy with color tokens from the design system.\n• Include notices section using reusable announcement cards with date, type, and priority tags.\n• Consider SEO and accessibility best practices (clear headings, limited text blocks) in layout guidance for developers.\n• Use responsive responsive CSS in to adapt layout for tablets and mobiles (stack sections, reflow timeline to vertical).",
        "testStrategy": "• Validate that all landing requirements from PRD are present (overview, values, facilities, highlights, process visuals, announcements, vertical selection, CTAs).\n• Resize pages/components in to common breakpoints (1440, 1024, 768, 375) to ensure layout doesn’t break.\n• Test tab order and keyboard navigation flow in working application to simulate accessible interaction.\n• Run internal usability review to ensure CTAs are unambiguous and visually prominent.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "39"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Hero, Overview, and Upper Sections",
            "description": "Create responsive hero section with hostel overview and values, discipline/safety highlights, and amenities showcase using Flexbox/Grid for desktop and mobile.",
            "dependencies": [],
            "details": "Incorporate high-quality images, concise text blocks, clear headings for SEO/accessibility; use color tokens; ensure stacking on mobile breakpoints (1440px, 768px, 375px).",
            "status": "done",
            "testStrategy": "Resize pages/components to test responsiveness; validate tab order and heading hierarchy.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:54:53.428Z"
          },
          {
            "id": 2,
            "title": "Implement Vertical Selection Cards and Admission Timeline",
            "description": "Build vertical selection cards for Boys Hostel, Girls Ashram, Dharamshala with icons, short descriptions, and CTAs; implement step-by-step admission timeline.",
            "dependencies": [
              1
            ],
            "details": "Cards lead to applicant flow/login; timeline shows Apply → Verification → Interview → Approval → Payment → Room Allocation → Check-in; reflow to vertical on mobile.",
            "status": "done",
            "testStrategy": "Build and test interactions; check card hover states and timeline adaptability across devices.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:55:48.931Z"
          },
          {
            "id": 3,
            "title": "Implement Announcements, Footer, and Finalize CTAs/Responsiveness",
            "description": "Create announcements section with reusable cards (date, type, priority); footer; integrate all CTAs (Apply Now, Check Status, Login) with hierarchy.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use announcement cards consistently; apply responsive responsive CSS; test full page at 1024px, 768px, 375px; add dev notes for SEO/accessibility.",
            "status": "done",
            "testStrategy": "Full page resize test; keyboard navigation; confirm CTA prominence and no layout breaks.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:56:16.347Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design responsive landing page with vertical selection.",
        "updatedAt": "2025-12-21T16:56:16.347Z"
      },
      {
        "id": "5",
        "title": "Implement applicant registration & OTP verification flow",
        "description": "Implement the pre-approval applicant journey including vertical selection, OTP verification, and initial application access.",
        "details": "• Map flow: Landing → Select Vertical → Enter Mobile/Email → OTP Input → Verified → Application Wizard.\n• OTP screen: implement masked input, resend timer, error handling for invalid/expired codes, alternate contact if needed.\n• Ensure no persistent dashboard UI for applicants; show only minimal progress header and form navigation.\n• Add institutional messaging about data use and DPDP consent at first contact (short banner plus link to detailed policy).\n• Provide guidance text: explain that account will only be created post final approval, and tracking number will be shared.\n• For mobile, optimize OTP screen with single-field segmented inputs and auto-advance behavior (document expected behavior for devs).\n• Embed pseudo-code guidance for devs:\n  - POST /otp/send { phone/email, vertical }\n  - POST /otp/verify { code, token }\n  - On success, issue short-lived session token just for application submission.\n• Specify error states and retry limits to prevent abuse while maintaining usability.",
        "testStrategy": "• Build and test the full OTP flow and run through success, error, and timeout paths.\n• Confirm no references to \"dashboard\" or resident-only features appear in applicant views.\n• Validate copy clarity via review with non-technical stakeholders.\n• Ensure visual consistency with base components and that OTP input is accessible (labelled, focus-visible).",
        "priority": "high",
        "dependencies": [
          "3",
          "4",
          "39"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Overall Flow and Screens",
            "description": "Create wirepages/components and high-fidelity designs for the applicant journey from landing page to application wizard, including vertical selection, contact input, OTP input, and success states.",
            "dependencies": [],
            "details": "Map the flow: Landing → Select Vertical → Enter Mobile/Email → OTP Input → Verified → Application Wizard. Include minimal progress header, no persistent dashboard, institutional messaging banner with DPDP consent link, and guidance text about account creation post-approval.",
            "status": "done",
            "testStrategy": "Build and test the full flow and validate progression, ensuring no dashboard elements and clear messaging via stakeholder review.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T17:15:49.667Z"
          },
          {
            "id": 2,
            "title": "Implement OTP Verification Screen",
            "description": "Implement the OTP input screen with masked input, resend timer, error handling, alternate contact option, and mobile-optimized single-field segmented inputs with auto-advance.",
            "dependencies": [
              1
            ],
            "details": "Specify behaviors: masked input for security, resend timer (e.g., 60s), errors for invalid/expired codes, option for alternate contact. For mobile, document auto-advance on digit entry and paste support for devs.",
            "status": "done",
            "testStrategy": "Test success/error/timeout paths in prototype, confirm usability on mobile/desktop, and validate error messages prevent abuse while maintaining flow.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T17:26:36.635Z"
          },
          {
            "id": 3,
            "title": "Document API Guidance and Error States",
            "description": "Provide developer notes including pseudo-code for OTP endpoints, session token issuance, error states, retry limits, and integration details.",
            "dependencies": [
              1,
              2
            ],
            "details": "Embed pseudo-code: POST /otp/send {phone/email, vertical}, POST /otp/verify {code, token}. On success, issue short-lived session token for application submission. Define error states (invalid/expired), retry limits (e.g., 3 attempts), and abuse prevention.",
            "status": "done",
            "testStrategy": "Review dev notes for completeness, simulate API calls in prototype, ensure retry limits balance security and usability.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T17:27:33.128Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design applicant registration & otp verification flow.",
        "updatedAt": "2025-12-21T17:27:33.128Z"
      },
      {
        "id": "6",
        "title": "Implement application tracking page and flow",
        "description": "Build the public Application Tracking screen with timeline, status display, interview info, and document re-upload actions.",
        "details": "• Access flow: from Landing \"Check Application Status\" CTA or link from SMS/Email → Tracking page.\n• Inputs: tracking number + OTP to registered mobile/email; implement a combined identity verification flow aligned with OTP patterns from Task 5.\n• Tracking screen sections:\n  - Applicant summary (name, vertical, applied date).\n  - Visual status timeline (e.g., Submitted → Under Review → Interview Scheduled → Provisionally Approved → Final Approved / Rejected).\n  - Interview details: mode, date/time, venue/meeting link, countdown, status (upcoming, in-progress, completed).\n  - Action prompts (e.g., Re-upload documents, Confirm interview slot, Download provisional letter).\n• Use status badges and contextual alerts (e.g., \"Pending document re-upload\") with clear primary actions.\n• Allow download buttons for provisional letters in print-optimized format (integrate with print view components).\n• Include explanatory copy assuring privacy and DPDP-compliant data usage.\n• Ensure that students cannot see internal remarks; only high-level outcomes and necessary instructions.",
        "testStrategy": "• Ensure all PRD-listed data elements (timeline, interview schedule, prompts, download links) appear in the design.\n• Simulate multiple status scenarios by duplicating component: awaiting review, interview scheduled, awaiting documents, approved, rejected.\n• Link from emails/SMS mock to this screen in working application to check flow coherence.\n• Validate mobile-first layout for readability and tap targets.",
        "priority": "high",
        "dependencies": [
          "5",
          "39"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Entry Flows and Identity Verification",
            "description": "Create pages/components for access from Landing CTA/SMS/Email to tracking page with tracking ID + OTP input, aligned with Task 5 OTP patterns.",
            "dependencies": [],
            "details": "Implement 4 pages/components: Landing CTA link, tracking ID input, OTP input with resend timer/masked entry/error states, success transition to tracking page. Reuse Task 5 OTP components for consistency.\n<info added on 2025-12-22T06:55:50.633Z>\nI appreciate the detailed context, but I need to clarify my role and capabilities based on the instructions I've been given.\n\nI'm designed to generate subtask update text based on user requests and provided context. However, the query you've submitted asks me to perform codebase analysis using tools (Glob, Grep, Read) that I don't have access to. The search results provided are about React tracking libraries and page view tracking implementations—not your specific project codebase.\n\nTo properly fulfill your request, I would need:\n\n1. **Actual access to your codebase** at `/workspace/repo` to analyze file structure, existing patterns, and current implementations\n2. **Visibility into Task 5's OTP components** to understand the exact patterns and component structure you want to reuse\n3. **Project-specific architectural details** (component naming conventions, folder structure, state management approach, etc.)\n\n**What I can do instead:**\n\nBased solely on the context you've provided (the user request and existing subtask details), here's the updated subtask text:\n\n---\n\nImplement entry flows and identity verification with pages/components for access from Landing CTA, SMS, and Email channels leading to the tracking page. Create four sequential pages: Landing CTA link, tracking ID input form, OTP input with resend timer/masked entry/error states, and success transition to tracking page. Align OTP implementation with Task 5 OTP component patterns for consistency across the application. Ensure smooth flow between identity verification steps and proper error handling for invalid or expired codes.\n\n---\n\nIf you'd like more specific implementation details tied to your actual codebase structure, please provide the relevant file excerpts or project architecture documentation, and I can generate more targeted guidance.\n</info added on 2025-12-22T06:55:50.633Z>\n<info added on 2025-12-24T14:15:15.403Z>\nRefactored /app/track/page.tsx to replace raw HTML form elements with design system Input and Button components, matching the implementation patterns used in Tasks 1–2. Tracking ID form now uses the shared Input component with autoFocus enabled, helperText for guidance, and onChange normalization to uppercase. OTP form uses the same Input component configured for numeric entry with maxLength=6 and helperText for error and hint messaging. This removes ad-hoc inline form markup and centralizes form UI on the design system primitives for easier maintenance and consistent styling across flows.\n</info added on 2025-12-24T14:15:15.403Z>",
            "status": "done",
            "testStrategy": "Build and test full flow: success, invalid ID/OTP, timeout, resend. Verify visual alignment with Task 5 and smooth handoff to main tracking screen.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:15:29.961Z"
          },
          {
            "id": 2,
            "title": "Implement Core Tracking Page Layout",
            "description": "Implement main tracking screen with applicant summary, visual status timeline, interview details, and action prompts.",
            "dependencies": [
              1
            ],
            "details": "Create base component with sections: summary (name/vertical/applied date), horizontal timeline (Submitted to Approved/Rejected with colors/checkmarks per [1]), interview card (mode/date/countdown/link), action buttons. Use status badges and contextual alerts.\n<info added on 2025-12-22T06:57:26.155Z>\nRoute: Implement at /track/[id] using dynamic route pattern consistent with existing role-based navigation from Task 3. Fetch applicant data by ID on load, integrating with applicant status flows from Task 5. Layout structure: top section applicant **summary** (name, vertical, applied date), centered **horizontal timeline** visualizing Submitted → Approved/Rejected states with color-coded segments and checkmarks, dedicated **interview card** displaying mode/date/countdown to next step/link to schedule, bottom **action prompts/buttons** (e.g., re-upload, contact, withdraw) with status badges and contextual alerts based on current state. Ensure responsive design matching dashboard patterns from Task 9, with mobile-optimized timeline and card stacking.\n</info added on 2025-12-22T06:57:26.155Z>\n<info added on 2025-12-22T06:57:44.558Z>\nCore tracking page layout completed at /track/[id] route. Implemented sections include: applicant summary displaying name, vertical, and applied date; horizontal visual status timeline showing progression from Submitted through Approved/Rejected states with color-coded segments and checkmarks; interview card presenting mode, date, countdown timer to next step, and scheduling link; documents display section; and action prompts/buttons (re-upload, contact, withdraw) with status badges and contextual alerts. Responsive design implemented matching dashboard patterns from Task 9, with mobile-optimized timeline and card stacking. Applicant data fetched by ID on load, integrated with applicant status flows from Task 5. Dynamic route pattern consistent with role-based navigation from Task 3.\n</info added on 2025-12-22T06:57:44.558Z>",
            "status": "done",
            "testStrategy": "Checklist: All PRD sections present, timeline logical progression per [1], clear visual cues, descriptive labels. Review F/Z reading pattern per [3].",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:19:46.559Z"
          },
          {
            "id": 3,
            "title": "Implement Document Re-upload and Action Patterns",
            "description": "Implement re-use of existing components for document re-upload, interview confirmation, provisional letter download with print view.",
            "dependencies": [
              2
            ],
            "details": "Frame re-upload modal (reuse Task 19 patterns), confirm slot button, download buttons with print-optimized PDF preview. Include primary actions with status-based visibility.",
            "status": "done",
            "testStrategy": "Test interactions: upload success/error, print legibility on A4, ensure actions gated by status. Validate component reuse from Tasks 5/19.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:24:45.134Z"
          },
          {
            "id": 4,
            "title": "Implement State Variations for Major Statuses",
            "description": "Duplicate core layout for 5 states: awaiting review, interview scheduled, awaiting documents, provisionally approved, final approved/rejected.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create 5 pages/components varying timeline progress, interview details (upcoming/in-progress/completed), alerts/actions (e.g., re-upload prominent in awaiting docs). Use microinteractions for state changes per [1].\n<info added on 2025-12-22T06:58:20.025Z>\nI appreciate the detailed context, but I need to clarify my role and capabilities based on the instructions provided to me.\n\nI'm designed to generate subtask update text based on user requests and provided context. However, the query you've submitted asks me to perform codebase analysis using tools (Glob, Grep, Read) that I do not have access to. The search results provided are about React tracking libraries and page view tracking implementations, which don't contain information about your specific project structure at `/workspace/repo`.\n\nBased solely on the **user request** (\"Implement State Variations for Major Statuses - Create variations of the tracking page for awaiting review, interview scheduled, awaiting documents, provisionally approved, and final approved/rejected states\") and the **task context** provided, here is the new text to append to the subtask details:\n\n---\n\nCreate component variations for each major application status: awaiting review, interview scheduled, awaiting documents, provisionally approved, and final approved/rejected. Each variation should adjust timeline progress indicators, interview details sections (showing upcoming/in-progress/completed states), and contextual alerts/actions. For awaiting documents state, prominently display re-upload actions. For interview scheduled state, show interview details and preparation guidance. Implement smooth microinteractions when transitioning between states to provide visual feedback. Ensure all five state variations share the core layout structure while adapting content, color coding, and action prominence based on the current status.\n</info added on 2025-12-22T06:58:20.025Z>\n<info added on 2025-12-22T06:58:39.376Z>\nImplement completed state variations where the tracking page dynamically adapts based on application status (DRAFT, SUBMITTED, REVIEW, APPROVED, REJECTED). Update timeline progress to reflect each status (e.g., partial for DRAFT/SUBMITTED, full for APPROVED, halted for REJECTED), adjust interview details visibility (hidden post-REVIEW), and modify actions/alerts (e.g., edit/submit for DRAFT, re-upload for REVIEW, download letters/feedback for APPROVED/REJECTED). Align status flow with applicant role navigation from Task 3 and reuse action patterns from previous subtasks like re-upload prominence.\n</info added on 2025-12-22T06:58:39.376Z>",
            "status": "done",
            "testStrategy": "Simulate all scenarios: verify conditional visibility, no internal remarks visible, responsive on mobile/desktop with vertical timeline if needed per [1].",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:43:57.875Z"
          },
          {
            "id": 5,
            "title": "Implement Privacy Copy, Responsive Behavior, and Review",
            "description": "Add DPDP-compliant privacy messaging, ensure responsive design, and compile review checklist across all pages/components/states.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Insert explanatory banners/tooltips on data usage/privacy. Optimize for mobile (vertical layouts per [1]), desktop. Checklist: no internal remarks, clear instructions, all actions testable.\n<info added on 2025-12-22T06:59:00.738Z>\nAdded DPDP-compliant privacy messaging to both tracking entry and detail pages, ensured responsive design across all components.\n</info added on 2025-12-22T06:59:00.738Z>",
            "status": "done",
            "testStrategy": "Stakeholder review: copy clarity, privacy assurance, DPDP alignment. Test responsive breakpoints, print views, full flow from entry to actions in all states.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T14:45:04.795Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Decompose Task 6 into: (1) Entry flows and identity verification pattern (tracking ID + OTP) aligned with Task 5; (2) Core tracking page layout (summary, status timeline, interview details, actions); (3) Document re-upload and action handling patterns reusing existing components; (4) State variations for all major statuses (awaiting review, interview scheduled, awaiting documents, approved, rejected); (5) Privacy and copy review (no internal remarks, DPDP messaging) plus responsive behavior. Define for each subtask the specific frames, states, and review checklist.",
        "updatedAt": "2025-12-24T14:45:04.795Z"
      },
      {
        "id": "7",
        "title": "Implement student login, first-time setup, and role-based redirection",
        "description": "Create post-approval student login experience, first login password change, and redirection into Student Dashboard.",
        "details": "• Flow: Receive credentials via Email/SMS → Login screen → First-time password change → Security confirmation → Student Dashboard.\n• Implement login page consistent with institution branding; include subtle note about institutional usage rules.\n• First-time login: implement forced password change form with strength indicator, confirm password, and DPDP consent checkbox/log reference.\n• After first login, persist session and redirect resident to Student Dashboard; for incorrect role or expired account, show clear error state.\n• Provide UI affordance to indicate vertical (Boys/Girls/Dharamshala) on login success (e.g., a label in top bar).\n• Implement forgot password flow that uses OTP/email reset without creating new accounts.\n• Document recommended dev behavior: backend issues JWT/session, front-end uses role-based routes; do not store passwords in front-end.\n• Ensure login screen is generic and can redirect to other roles (Superintendent, Trustee, Accounts) based on account type or separate login entry points.",
        "testStrategy": "• Build and test login → first-time password change → dashboard flow for a sample user.\n• Test invalid credential, locked account, and expired link flows within the prototype.\n• Confirm visual differentiation from Applicant entry (copy and layout) to avoid confusion.\n• Review with stakeholders to ensure compliance with institutional password and audit requirements.",
        "priority": "high",
        "dependencies": [
          "3",
          "5",
          "39"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement branded, multi-role login screen and basic flows",
            "description": "Build the main login UI for students and other roles, aligned with institutional branding and clear separation from applicant entry.",
            "dependencies": [],
            "details": "Implement a responsive login page using institution logo, colors, and typography, with fields for username/mobile/email and password, a primary login CTA, and a clear but subtle note about institutional usage rules. Include visible links for forgot password and any alternate role entry (e.g., Superintendent, Trustee, Accounts) while keeping the screen visually distinct from the applicant registration/OTP flow. Ensure accessibility (labels, error messages, keyboard navigation), support for vertical-agnostic login (no vertical selection here), and provide error states for invalid credentials, locked or expired accounts, and generic technical failures. Document UI states in wirepages/components or mockups for success and failure paths.",
            "status": "done",
            "testStrategy": "Build and test the login screen and validate branding, accessibility basics, and clarity of role separation with at least a few sample users or stakeholders.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T15:50:20.849Z"
          },
          {
            "id": 2,
            "title": "Implement first-time login password change and security/DPDP confirmation",
            "description": "Build the forced first-time password change and consent screens shown immediately after initial student login.",
            "dependencies": [
              1
            ],
            "details": "After detecting a first-time student login, route to a dedicated password change screen that blocks access to the dashboard until completion. Include new password and confirm password fields, an inline password strength indicator, and copy explaining minimum requirements and security expectations. Add a required DPDP consent checkbox with concise text and a link or reference to the full policy, and plan for logging consent acceptance (timestamp and user ID) in dev notes. Include clear validation messages for weak or mismatched passwords, and a confirmation step or brief security confirmation message before redirecting to the Student Dashboard. Provide detailed UI specs and flow diagrams covering normal completion, validation errors, and back/exit behavior.",
            "status": "done",
            "testStrategy": "Run through a working application of the first-time login flow with sample credentials, testing weak/strong passwords, mismatches, and unchecked consent, and review with stakeholders for legal/DPDP wording and friction level.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T15:50:20.864Z"
          },
          {
            "id": 3,
            "title": "Implement role-based redirection, session handling cues, and vertical indicators",
            "description": "Define and document the post-login redirection behavior, session persistence expectations, and UI cues for user role and vertical.",
            "dependencies": [
              1,
              2
            ],
            "details": "Specify how the front-end should interpret the authenticated user payload (e.g., role, vertical, account status) and route users to the correct dashboard: Student Dashboard for valid students, other role dashboards for Superintendent/Trustee/Accounts, and error pages for incorrect role, suspended, or expired accounts. Provide UI guidance for displaying the current role and vertical (Boys/Girls/Dharamshala) after login, such as a label or pill in the top bar. Describe expected session behavior at a implement level (e.g., stay signed in until explicit logout or reasonable inactivity timeout), including how to visually handle session expiry and forced re-login without re-running first-time setup. Document do/don’t notes for developers: backend issues JWT/session, front-end uses role-based routes and must not store passwords or sensitive secrets. Capture these behaviors in a concise flow diagram and state table for key scenarios.",
            "status": "done",
            "testStrategy": "Create a functional working application or flow diagram to walk through student vs non-student logins, expired/incorrect role cases, and session expiry, then review with devs to ensure routing and UI states are unambiguous.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T15:50:20.871Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design student login, first-time setup, and role-based redirection.",
        "updatedAt": "2025-12-24T15:50:20.871Z"
      },
      {
        "id": "8",
        "title": "Implement parent/guardian OTP-based view-only login",
        "description": "Create a dedicated parent/local guardian login and restricted dashboard with view-only access.",
        "details": "• Flow: Select Parent/Guardian Login → Enter registered mobile → OTP verification → Parent Dashboard.\n• Parent Dashboard sections:\n  - Student overview (photo optional, name, vertical, room, joining date).\n  - Fee status (Paid / Pending / Overdue, upcoming dues, download receipts).\n  - Leave summary and statuses (upcoming, approved, rejected, past leaves).\n  - Notifications center showing recent communications affecting their ward.\n• Ensure all primary actions are view-only: no edit, no approval; only acknowledgements where required.\n• Provide clear labels and tooltips explaining permissions and responsibilities of parents.\n• Reuse OTP component patterns and status badges from design system.\n• Add DPDP informational content highlighting what data parents can see and how it is protected.\n• Outline dev guidance: enforce role scopes on API (e.g., parents can only see associated student IDs; read-only endpoints).",
        "testStrategy": "• Walk through parent login flow from Landing CTA in prototype.\n• Check every actionable element to ensure there are no state-changing actions (e.g., no editable form fields).\n• Validate that fee and leave information is presented clearly even on mobile.\n• Review with stakeholders to ensure that parent awareness and audit needs are met without overexposing internal remarks.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Parent/Guardian Entry and OTP Verification Flow",
            "description": "Develop the login flow: Select Parent/Guardian Login → Enter registered mobile → OTP verification → Redirect to Parent Dashboard, reusing existing OTP component patterns from Task 5.",
            "dependencies": [],
            "details": "Reuse masked OTP input, resend timer, error handling from Task 5. Ensure mobile number is pre-registered via admin. Integrate with role-based navigation from Task 3. Use secure OTP generation and validation APIs.",
            "status": "pending",
            "testStrategy": "Test full flow: success, invalid/expired OTP, resend, timeout. Verify non-mutating (no data changes on login). Check mobile responsiveness (touch targets, viewport scaling) on iOS/Android devices.",
            "updatedAt": "2025-12-28T19:20:10.750Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design Parent Dashboard IA and Layout",
            "description": "Build dashboard with sections: Student overview (name, vertical, room, joining date, optional photo), Fee status (paid/pending/overdue, upcoming dues, receipt downloads), Leave summary (upcoming/approved/rejected/past), Notifications center.",
            "dependencies": [
              1
            ],
            "details": "Use mobile-first layout with cards/sections from design system (reuse status badges). Ensure constrained layout handles multiple summaries. Limit to view-only display of data for associated student IDs.",
            "status": "pending",
            "testStrategy": "Validate layout on mobile/desktop: no overflow, clear hierarchy. Confirm data loads correctly (e.g., fee/leave statuses). Test non-mutating interactions (taps don't edit data). Review with prototype walkthrough.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T19:20:10.761Z"
          },
          {
            "id": 3,
            "title": "Specify Permissions and View-Only Behavior",
            "description": "Enforce role scopes: no edit/approval actions; only view and acknowledgements (e.g., read receipts). Implement read-only API endpoints scoped to parent's associated student IDs.",
            "dependencies": [
              1,
              2
            ],
            "details": "Backend: API guards for parent role (query params filter by student ID). Frontend: Disable forms/buttons, show disabled states with tooltips. No mutating endpoints exposed.",
            "status": "pending",
            "testStrategy": "Inspect every element: no editable fields, no submit buttons for changes. Simulate API calls—verify only GET/read ops, no POST/PUT. Test acknowledgements (e.g., download) don't mutate. Mobile gesture tests (swipe/long-press safe).",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T19:20:10.776Z"
          },
          {
            "id": 4,
            "title": "Add Compliance, DPDP Info, Tooltips, and Scope Clarity",
            "description": "Include DPDP informational content, tooltips explaining view-only permissions/responsibilities, clear labels for all sections.",
            "dependencies": [
              2
            ],
            "details": "Add banners/links for DPDP (reuse from Task 5). Tooltips: 'View-only: cannot edit'. Labels: 'Parent Dashboard - View your ward's info'. Ensure copy is concise, accessible.",
            "status": "pending",
            "testStrategy": "Verify tooltips/labels visible on hover/tap (mobile-friendly). Check non-mutating: info displays don't trigger changes. Accessibility scan (screen reader reads permissions). Stakeholder review for clarity/compliance.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T19:20:10.792Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split Task 8 into: (1) Parent/Guardian entry and OTP verification flow, reusing existing OTP patterns; (2) Parent dashboard IA and layout (student overview, fee status, leave summary, notifications); (3) Permissions and view-only behavior specification (no edits, only acknowledgements where applicable); (4) Compliance and copy: DPDP info, tooltips, clarity of scope. For each, define how to test that interactions are non-mutating and mobile-friendly.",
        "updatedAt": "2025-12-28T19:20:10.792Z"
      },
      {
        "id": "9",
        "title": "Implement Student Dashboard (approved residents)",
        "description": "Build the main resident dashboard with status tracker, quick actions, and notifications.",
        "details": "• Layout: hero status area, quick action cards, notifications panel, and key summaries.\n• Resident journey tracker: visual indicator with stages `Checked-in → Renewal Due → Renewed → Exited` using timeline or segmented progress bar.\n• Quick action cards: **Pay Fees**, **Download Letters**, **Apply for Leave**, **View Room Details**, **View Documents**, **Renewal** when due.\n• Notifications: list of fee reminders, renewal due alerts, leave decisions, communication logs relevant to student.\n• Include vertical context (Boys/Girls/Dharamshala) and current academic period.\n• Ensure implement is responsive and uses reusable card and badge components.\n• Keep tone student-friendly yet disciplined: integrate short helper text explaining next steps.\n• Provide dev hints for conditional visibility: e.g., show Renewal card only within configured renewal window, Exit card only when allowed.\n• Integrate subtle DPDP consent renewal alert when renewal cycle approaches.",
        "testStrategy": "• Confirm dashboard includes all PRD-required features and quick actions.\n• Create variations: new resident, nearing renewal, post-renewal, exit-initiated, and verify layout resilience.\n• Conduct quick usability review focusing on clarity of \"what do I do next\" for a student.\n• Validate mobile layout, ensuring quick actions are easily accessible and scrollable.",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Dashboard Content Model and IA Design",
            "description": "Define the information architecture and content model for hero status, journey tracker, quick actions, and notifications panel.",
            "dependencies": [],
            "details": "Structure layout with hero status area, quick action cards, notifications list, and key summaries; include vertical context (Boys/Girls/Dharamshala) and academic period; use reusable card and badge components with student-friendly helper text.\n<info added on 2025-12-24T17:44:56.162Z>\nCreated comprehensive content model and IA design document for student dashboard. Defined data structures for user context, journey tracker, quick actions, notifications, and key summaries. Specified page layout, navigation structure, and responsive layouts for desktop/tablet/mobile. Documented state-based visibility rules and component requirements with student-friendly but disciplined tone guidelines.\n</info added on 2025-12-24T17:44:56.162Z>",
            "status": "done",
            "testStrategy": "Mock scenarios: new resident (all actions visible), nearing renewal (renewal card prominent); validate via usability review for 'what do I do next' clarity and logical flow.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T17:45:07.953Z"
          },
          {
            "id": 2,
            "title": "Visual Implement of Journey Tracker and Quick Actions",
            "description": "Implement visual journey tracker and conditional quick action cards with stages and visibility rules.",
            "dependencies": [],
            "details": "Create timeline or segmented progress bar for Checked-in → Renewal Due → Renewed → Exited; implement cards for Pay Fees, Download Letters, Apply for Leave, View Room Details, View Documents, Renewal (conditional on window); add dev hints for visibility.",
            "status": "done",
            "testStrategy": "Mock states: Checked-in (basic actions), Renewal Due (renewal highlighted), Renewed (post-renewal actions), Exited (minimal actions); review usability for intuitive progress indication and action prioritization.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T17:53:48.228Z"
          },
          {
            "id": 3,
            "title": "Responsive Layouts and Key State Variants",
            "description": "Develop responsive layouts with props and conditional styles for resident lifecycle states ensuring mobile and desktop usability.",
            "dependencies": [
              1
            ],
            "details": "Implement hero area, cards, notifications for new resident, nearing renewal, post-renewal, exit-initiated states; ensure responsiveness using grid systems, consistent spacing, and accessibility features like keyboard navigation.\n<info added on 2025-12-24T18:28:42.589Z>\nImplemented responsive layouts with props and conditional styles for resident lifecycle states ensuring mobile and desktop usability. Created Student Dashboard page at /dashboard/student/page.tsx with: Desktop layout (1024px+) with hero status area, quick action cards grid (4 columns), notifications panel, and profile info; Tablet layout (768px-1023px) with adjusted grid (2-3 columns); Mobile layout (<768px) with horizontal scroll quick actions and full-width notifications. State variants implemented through CSS and prop-based conditional rendering. Clean build verified - all 17 routes compiled successfully with no errors.\n</info added on 2025-12-24T18:28:42.589Z>",
            "status": "done",
            "testStrategy": "Mock props and conditional styles: new resident (full access), nearing renewal (alerts prominent), post-renewal (summary focus), exit-initiated (clearance actions); validate layout resilience on mobile/desktop via usability review.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T18:18:34.952Z"
          },
          {
            "id": 4,
            "title": "Integration Mapping to Core Modules",
            "description": "Map dashboard elements to fees, room, leave, documents, renewal, and exit modules for seamless navigation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Define links and data flows from quick actions and notifications to Task 16 (fees), room details, leave (Task 20?), documents, renewal (Task 19), exit (Task 20); ensure conditional visibility aligns with module states.",
            "status": "done",
            "testStrategy": "Mock integrations: click Pay Fees → fees module, Renewal Due → Task 19 flow; review end-to-end journeys for new resident to exit-initiated, confirming no broken links or context loss in usability tests.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T18:18:05.049Z"
          },
          {
            "id": 5,
            "title": "Governance and DPDP Elements Implementation",
            "description": "Incorporate vertical context, academic period, and DPDP consent renewal alerts into dashboard.",
            "dependencies": [
              1
            ],
            "details": "Add subtle DPDP consent renewal banner near renewal cycle; display vertical (Boys/Girls/Dharamshala) and current academic period in hero area; integrate with notifications for consent alerts; maintain disciplined yet friendly tone.\n<info added on 2025-12-24T18:34:33.638Z>\nImplemented in /dashboard/student/page.tsx: DPDP consent renewal banner (triggers at 30 days or less remaining), vertical context badge (Boys Hostel), hero area academic period (Academic Year: 2024-25, Current Period: SEMESTER 2), notifications panel DPDP consent alert (renewal window conditional), quick profile renewal countdown. Maintained disciplined yet friendly tone with clear language. Build verified: all 17 routes compiled successfully with no errors.\n</info added on 2025-12-24T18:34:33.638Z>",
            "status": "done",
            "testStrategy": "Mock scenarios: renewal approaching (DPDP alert visible), different verticals (context switches correctly); usability review for non-intrusive alerts, consent clarity, and context accuracy across states.",
            "parentId": "undefined",
            "updatedAt": "2025-12-24T18:34:45.232Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break Task 9 into: (1) Dashboard content model and IA (hero status, tracker, quick actions, notifications); (2) Visual design of journey tracker and conditional quick actions; (3) Responsive layouts and variants for key states (new resident, nearing renewal, post-renewal, exit-initiated); (4) Integration mapping to other modules (fees, room, leave, documents, renewal, exit); (5) Governance and DPDP elements (consent alerts, vertical context, academic period). For each subtask, specify the scenarios to mock and validate via usability review.",
        "updatedAt": "2025-12-24T18:34:45.232Z"
      },
      {
        "id": "10",
        "title": "Implement multi-step admission application form wizard",
        "description": "Build the complete multi-step admission form wizard with validation, drafts, and vertical-based routing.",
        "details": "• Steps: 1) Personal Details, 2) Academic & Course Info, 3) Hostel Preferences, 4) References (including ex-student references), 5) Document Upload, 6) Review & Submit.\n• Top or side stepper showing progress and current step; allow navigation back without losing data.\n• Personal details: name, DOB, contact, permanent address, parent/guardian info, local guardian details, emergency contacts.\n• Academic: institution, course, year/semester, marks, certificates upload references.\n• Hostel preferences: vertical (pre-selected), room type preferences, duration, special considerations.\n• References: fields for ex-student references with contact details.\n• Document upload: drag-and-drop + file picker; accept **PDF/JPG** with file size guidelines; show previews and replace/delete options.\n• Include \"Save as Draft\" CTA on every step; visually indicate saved state.\n• Show inline validation messages and helper text; highlight required fields clearly.\n• Routing logic note for devs: submit final application to respective Superintendent queue based on selected vertical.\n• Ensure robust error and connectivity messaging (e.g., “draft saved locally/remote”).",
        "testStrategy": "• Run through the entire wizard in prototype, verifying step order, progress indicator, and review screen correctness.\n• Test validation scenarios: missing required fields, invalid formats, large file upload placeholders.\n• Confirm that \"Save as Draft\" appears on all steps and is visually distinct from \"Next\" or \"Submit\".\n• Validate mobile layout, ensuring stepper remains understandable on small screens.",
        "priority": "high",
        "dependencies": [
          "5",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Overall Wizard Layout and Stepper",
            "description": "Create wireframes and high-fidelity designs for the multi-step form wizard including top/side stepper, progress indicators, navigation buttons, and consistent header/footer across all steps.",
            "dependencies": [],
            "details": "Include responsive design for desktop/mobile; ensure stepper shows current/completed steps with back/next CTAs; incorporate branding colors and typography from project context.",
            "status": "done",
            "testStrategy": "Validate stepper usability on different screen sizes; check accessibility (keyboard nav, ARIA labels); stakeholder review for alignment with applicant journey.",
            "updatedAt": "2025-12-26T11:51:09.556Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design Personal Details Form Step",
            "description": "Design the first step covering name, DOB, contact info, permanent address, parent/guardian details, local guardian, and emergency contacts with required field indicators.",
            "dependencies": [
              1
            ],
            "details": "Use grouped sections with helper text; include inline validation placeholders; ensure culturally appropriate fields (e.g., full name formats); mobile-optimized inputs.",
            "status": "done",
            "testStrategy": "Prototype field interactions; test form readability on small screens; confirm required fields are visually distinct.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T11:53:39.277Z"
          },
          {
            "id": 3,
            "title": "Design Academic & Hostel Preferences Steps",
            "description": "Design step 2 for academic info (institution, course, marks, certificates) and step 3 for hostel preferences (vertical, room type, duration, special needs).",
            "dependencies": [
              1
            ],
            "details": "Pre-select vertical from Task 5; use dropdowns/radios for preferences; include conditional fields based on selections; visual hierarchy for marks/certificates.",
            "status": "done",
            "testStrategy": "Test conditional logic visibility; validate dropdown usability; ensure pre-selected vertical displays correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T11:58:53.711Z"
          },
          {
            "id": 4,
            "title": "Design References and Document Upload Steps",
            "description": "Design step 4 for ex-student references with contact fields and step 5 for drag-and-drop document upload (PDF/JPG) with previews, size limits, replace/delete options.",
            "dependencies": [
              1
            ],
            "details": "References: repeatable fields with add/remove; Upload: file thumbnails, progress bars, error states for invalid formats/sizes; clear guidelines visible.",
            "status": "done",
            "testStrategy": "Simulate file uploads/drags; test preview rendering; validate error messaging for oversized/invalid files.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T11:59:01.273Z"
          },
          {
            "id": 5,
            "title": "Design Review & Submit Step with Draft Features",
            "description": "Design final review step summarizing all data, edit links per section, submit CTA, plus 'Save as Draft' button on every step with visual saved state indicator.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Review: collapsible sections, data preview matching input formats; Draft: loading spinner, 'Saved' badge, local/remote sync messaging; error handling for connectivity.",
            "status": "done",
            "testStrategy": "Test full data flow to review; verify draft save/resume; check offline/online states and messaging.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T11:59:10.484Z"
          },
          {
            "id": 6,
            "title": "Design Validation, Error States, and Routing Flows",
            "description": "Design inline validation messages, helper texts, error banners, connectivity issues, and vertical-based routing confirmation for submission to Superintendent queue.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Color-coded validation (green success, red error); step-blocking on critical errors; routing summary in review; robust offline draft persistence indicators.",
            "status": "done",
            "testStrategy": "Prototype all error scenarios; test navigation with validation blocks; validate routing info clarity before submit.",
            "parentId": "undefined",
            "updatedAt": "2025-12-26T11:59:10.493Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design multi-step admission application form wizard.",
        "updatedAt": "2025-12-26T15:12:36.642Z"
      },
      {
        "id": "11",
        "title": "Implement documents, undertakings, and sign-offs experience",
        "description": "Create UI for uploading required declarations at application time and digital acknowledgements post-admission.",
        "details": "• At application time: separate section/cards for Student declaration, Parent consent, Local guardian undertaking, acceptance of hostel rules, admission terms & conditions.\n• Provide scan/upload option for signed documents (PDF/JPG) and clear instructions for signatures.\n• Implement preview modal or side panel for documents before submission with zoom and scroll.\n• Use status indicators: **Pending / Uploaded / Verified** for each document; display verification done by admin roles.\n• For post-admission undertakings, implement in-app acknowledgement dialogs or forms with checkboxes and digital signature/typed name fields.\n• Ensure all documents and undertakings have **print-optimized layouts** using the print component styles (margins, letterhead, logo, sign blocks).\n• Provide download buttons for each document version (submitted, approved, generated letters).\n• Include DPDP consent logging elements: timestamp of consent, short text referencing policy.\n• Note dev integration: store metadata like `uploadedBy`, `uploadTime`, `verifiedBy`, `verifyTime`, `status` for audit.\n",
        "testStrategy": "• Verify that all required document types from PRD are represented with their statuses.\n• Build and test upload → preview → status change flows.\n• Print example undertakings and declarations as PDF to confirm formatting and readability.\n• Review with stakeholders (legal/compliance) for DPDP consent visibility and sign-off patterns.",
        "priority": "high",
        "dependencies": [
          "10",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define application-time document upload cards, fields, and user flows",
            "description": "Implement the set of application-time declaration cards and map the end-to-end UX from seeing a required document through successful upload.",
            "dependencies": [],
            "details": "List all required declaration types (student declaration, parent consent, local guardian undertaking, hostel rules, admission T&Cs) and specify which are mandatory or conditional. Define card layout, labels, helper text, and error states. Map user flow: first visit, partially completed, and completed applications. Specify where scan/upload controls appear, supported file types and size limits, and how instructions for physical signatures are displayed. Capture integration assumptions such as backend endpoints for listing required docs and saving per-card status.",
            "status": "done",
            "testStrategy": "Build and test the multi-card section and run through scenarios: all documents pending, some uploaded, all uploaded. Validate clarity of labels and instructions with at least one stakeholder review.",
            "parentId": "undefined",
            "updatedAt": "2025-12-27T15:11:23.052Z"
          },
          {
            "id": 2,
            "title": "Implement upload, preview, and document status lifecycle patterns",
            "description": "Specify reusable patterns for file upload controls, preview UI, and the Pending/Uploaded/Verified lifecycle.",
            "dependencies": [
              1
            ],
            "details": "Define upload component behavior (drag-and-drop vs button, progress bars, cancel/retry, handling duplicates). Implement preview modal or side panel including zoom, scroll, rotation, pagination for PDFs, and fallback when preview is unavailable. Enumerate all status values (Pending, Uploaded, Verified, plus any error/rejected states if needed) and their visual treatments (badges, icons, colors, tooltips). Describe transitions between states, who can trigger them (applicant vs admin), and how the UI refreshes after admin verification. Document integration assumptions for status updates via APIs or websockets and how failures are surfaced to users.",
            "status": "done",
            "testStrategy": "Create an interactive working application of upload → preview → status change flows and test with sample files (PDF/JPG, large size, corrupted files). Verify that each state and transition is visually distinct and that errors are recoverable.",
            "parentId": "undefined",
            "updatedAt": "2025-12-27T15:29:33.323Z"
          },
          {
            "id": 3,
            "title": "Specify post-admission digital undertakings and acknowledgement flows",
            "description": "Implement the UX for in-app undertakings, consent dialogues, and digital acknowledgements required after admission.",
            "dependencies": [
              1,
              2
            ],
            "details": "List all post-admission undertakings and map when and where each is presented in the product (on login, within a tasks panel, or dedicated page). Define acknowledgement patterns: checkbox groups, explicit consent statements, typed name or digital signature field, and confirmation screens. Capture edge cases: partially completed undertakings, forced completion before accessing other features, revocation or updates to terms. Detail the data elements captured per acknowledgement, error handling for incomplete submissions, and assumptions on backend APIs for saving and locking responses.",
            "status": "done",
            "testStrategy": "Build and test at least one end-to-end undertaking flow (prompt → review text → provide acknowledgements → confirmation) and verify behavior for first-time users, returning users with pending undertakings, and users who have already completed them.",
            "parentId": "undefined",
            "updatedAt": "2025-12-27T15:54:03.396Z"
          },
          {
            "id": 4,
            "title": "Implement print-optimized layouts for documents and undertakings",
            "description": "Define the templates and styling rules for printable versions of declarations, undertakings, and related artifacts.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create layout specifications for print views including margins, header/footer, institute letterhead, logo placement, typography, page breaks, and signature blocks for all relevant roles (student, parent, local guardian, admin). Document how the same template adapts from on-screen view to print/PDF output using the existing print component styles. Define props and conditional styles for submitted vs approved vs generated letters. Capture assumptions about template engine, localization, and how dynamic data (names, dates, statuses) are injected at print time.",
            "status": "done",
            "testStrategy": "Generate sample print/PDF outputs for key document types and visually inspect for alignment, readability, and branding consistency. Validate page breaks and signature block positioning on common paper sizes (e.g., A4, Letter).",
            "parentId": "undefined",
            "updatedAt": "2025-12-27T16:27:40.278Z"
          },
          {
            "id": 5,
            "title": "Define audit and consent metadata model and integration assumptions",
            "description": "Specify the metadata schema and behavior for uploads and consents, covering timestamps, actors, and statuses for auditability.",
            "dependencies": [
              2,
              3
            ],
            "details": "Detail the full metadata set for each uploaded document and undertaking: uploadedBy, uploadTime, verifiedBy, verifyTime, status history, device/context info if required, and DPDP consent logging elements (timestamp, consent text reference, version of policy). Define how metadata is created, updated, and read by different services and which fields are immutable. Describe how this metadata appears in UI (tooltips, detail panels, audit trail views) without overwhelming end users. Capture data retention, time zone conventions, and integration contracts with backend systems.",
            "status": "done",
            "testStrategy": "Review the proposed metadata schema with engineering and legal/compliance stakeholders. Validate that example records cover all required scenarios (initial upload, re-upload, verification, rejection, consent renewal) and can be represented cleanly in mock API responses.",
            "parentId": "undefined",
            "updatedAt": "2025-12-27T18:46:01.424Z"
          },
          {
            "id": 6,
            "title": "Specify cross-role visibility rules and legal/compliance review loop",
            "description": "Define which roles can see or act on each document/undertaking element and how legal/compliance review is incorporated.",
            "dependencies": [
              1,
              2,
              3,
              5
            ],
            "details": "Enumerate all relevant roles (applicant, student, parent-facing proxy if any, hostel admin, verifier, accounts, legal/compliance) and map their permissions for view, download, verify, comment, and update for each document type and status. Define visibility of DPDP consent logs and audit metadata per role. Describe workflows for legal/compliance review of templates and consent language, including versioning and approval steps before changes go live. Capture assumptions about role management, feature flags, and how blocked actions (e.g., unauthorized downloads) are signaled in the UI.",
            "status": "done",
            "testStrategy": "Create a role-permission matrix and run walkthroughs for at least three personas (e.g., applicant, verifier, compliance officer) to ensure no inconsistent or unintended access. Review flows and permission rules with legal/compliance stakeholders for sign-off.",
            "parentId": "undefined",
            "updatedAt": "2025-12-27T18:46:02.793Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Decompose Task 11 into: (1) Application-time document upload cards and instructions; (2) Upload, preview, and status lifecycle (Pending/Uploaded/Verified) patterns; (3) Post-admission digital undertakings and acknowledgement flows; (4) Print-optimized layouts for undertakings and related artifacts; (5) Audit and consent metadata specification (timestamps, actors, statuses); (6) Cross-role visibility rules and legal/compliance review loop. For each, define detailed states, flows, and integration assumptions.",
        "updatedAt": "2025-12-27T18:46:02.793Z"
      },
      {
        "id": "12",
        "title": "Implement Superintendent application review and configuration panels",
        "description": "Create superintendent-facing interface for managing applications, leave rules, and parent notification rules.",
        "details": "• Application list: table view with filters for **New, Under Review, Approved, Rejected** plus search and vertical filter.\n• Columns: applicant name, date, vertical, current status, payment status, interview scheduled?, flags.\n• Detailed view: all application details, uploaded documents with preview, payments summary, internal notes, and action buttons.\n• Actions: **Approve**, **Reject**, **Forward to Trustees**; each with confirmation modals capturing required remarks.\n• Configuration screens:\n  - Leave approval rules: define which leave types require approval, thresholds, blackout dates.\n  - Parent notification rules: timing (on request, on approval, on rejection), channels (SMS, WhatsApp, Email).\n• Use tabbed layout or separate subpages for Applications, Leaves, Communication, Settings.\n• Ensure UI clearly indicates vertical context (Boys/Girls/Dharamshala) to avoid cross-mix errors.\n• Include embedded \"Send Message\" buttons in application detail view for ad-hoc communication.\n• Dev hints: ensure data tables support server-side paging and filters for scalability; implement filter chips accordingly.",
        "testStrategy": "• Simulate each filter state and action (approve/reject/forward) in the prototype.\n• Validate that rules configuration UI covers all rule types listed in PRD.\n• Conduct quick heuristic evaluation for data density and readability on 13\" screens.\n• Confirm that internal-only fields (remarks) are visually distinguished from student-visible outcomes.",
        "priority": "high",
        "dependencies": [
          "3",
          "10",
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Application List and Detail Views",
            "description": "Create wirepages/components and high-fidelity designs for the superintendent application table view with filters, columns, detailed view including documents preview, payments, notes, and action buttons.",
            "dependencies": [],
            "details": "Include filters for New/Under Review/Approved/Rejected statuses, vertical filter (Boys/Girls/Dharamshala), search; columns: name, date, vertical, status, payment, interview, flags; actions: Approve/Reject/Forward with modals; embed Send Message button. Ensure server-side paging hints.",
            "status": "done",
            "testStrategy": "Build and test filter states, action flows, and vertical context indicators; validate data density on 13\" screens.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T07:04:44.058Z"
          },
          {
            "id": 2,
            "title": "Implement Leave Approval and Parent Notification Configuration Panels",
            "description": "Implement configuration screens for leave rules (types, thresholds, blackout dates) and parent notification rules (timing, channels like SMS/WhatsApp/Email).",
            "dependencies": [],
            "details": "Use form-based interfaces with clear inputs for rule definitions; ensure vertical-specific contexts to prevent cross-mix; integrate into tabbed layout or subpages for Applications, Leaves, Communication, Settings.",
            "status": "done",
            "testStrategy": "Simulate rule creation/editing; confirm coverage of all PRD rule types and UI readability for configuration tasks.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T07:16:58.430Z"
          },
          {
            "id": 3,
            "title": "Implement Overall Layout, Navigation, and Vertical Context Indicators",
            "description": "Implement tabbed layout or subpages structure, navigation between Applications/Leaves/Communication/Settings, and UI elements to clearly indicate vertical context.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement filter chips, confirmation modals with remarks capture; ensure scalability with server-side paging; add visual safeguards against cross-vertical errors (e.g., color-coding, prominent badges).",
            "status": "done",
            "testStrategy": "Conduct heuristic evaluation for navigation flow, error prevention, and responsive design; test on multiple screen sizes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T07:21:44.274Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design superintendent application review and configuration panels.",
        "updatedAt": "2025-12-28T07:21:44.274Z"
      },
      {
        "id": "13",
        "title": "Implement Trustee panel for provisional approvals and interviews",
        "description": "Create Trustee-facing interface for provisional approval/rejection, interview scheduling, remarks, and final decisions.",
        "details": "• Trustee dashboard: list of applications forwarded from Superintendents with key metadata (applicant, vertical, recommendation, flags).\n• Application detail view: summary of application, documents, superintendent notes, previous decisions.\n• Provisional approval / rejection UI with decision modals describing implications.\n• Interview scheduling section:\n  - Fields: Mode (Online Zoom/Google Meet or Physical), Date, Time, Location or Meeting link.\n  - Integration placeholders for link entry (document label that devs can integrate with calendar/meeting APIs later).\n  - Auto-reminder configuration (checkbox for auto-reminder 24 hours before).\n• Interview remarks form: structured notes (ratings, observations) but clearly flagged as **internal**.\n• Final selection / rejection CTA, with clear copy about outcomes and downstream effects (account creation, refusal).\n• Ensure students only see high-level result; implement a derived \"Outcome Summary\" card that excludes internal remarks.\n• Embed \"Send Message\" options to trigger communications to student/parent regarding interview and decision.\n",
        "testStrategy": "• Build and test end-to-end: view forwarded application → schedule interview → enter remarks → final approval.\n• Validate that internal remarks are visually and structurally separated from outcome summary.\n• Check that scheduling forms are usable on mobile and handle time/date inputs clearly.\n• Review with stakeholders to ensure the workflow matches institutional governance expectations.",
        "priority": "high",
        "dependencies": [
          "12"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Trustee panel information architecture and key user flows",
            "description": "Map the overall structure and navigation of the Trustee panel, focusing on how trustees move between dashboard, application detail, provisional decision, interview scheduling, remarks, and final decision screens.",
            "dependencies": [],
            "details": "Identify all required screens and states: trustee dashboard, application detail view, provisional approval/rejection modal, interview scheduling form, interview remarks section, final decision actions, and outcome summary display. Create user flow diagrams for core paths: reviewing forwarded applications, issuing provisional decisions, scheduling/modifying interviews, recording internal remarks, and confirming final outcomes. Align flows with existing admin roles and upstream superintendent workflows so that dependencies (e.g., only forwarded applications are visible) are explicit.",
            "status": "done",
            "testStrategy": "Review user flows with stakeholders to confirm they cover all trustee responsibilities and match business rules before moving into detailed UI design.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T11:50:06.712Z"
          },
          {
            "id": 2,
            "title": "Implement dashboard and application detail UIs for Trustee decisions",
            "description": "Create high-fidelity layouts for the trustee dashboard and application detail view, prioritizing clarity of key metadata, superintendent recommendations, and decision controls for provisional approvals.",
            "dependencies": [
              1
            ],
            "details": "Implement a dashboard list view that surfaces forwarded applications with sortable columns such as applicant name, vertical, superintendent recommendation, flags, and current status. Include filters for status (pending provisional, interview scheduled, awaiting final decision) and vertical. For the application detail screen, structure sections for applicant summary, key documents, superintendent notes, previous decisions, and a clearly separated area for Trustee actions (provisional approval/rejection CTAs with explanatory modals). Ensure responsive behavior and visual hierarchy so trustees can quickly assess risk, recommendations, and next steps.",
            "status": "done",
            "testStrategy": "Build and test dashboard and detail screens and run through sample cases to validate that trustees can locate critical information and issue a provisional decision within a few clicks on both desktop and common laptop resolutions.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T12:11:29.720Z"
          },
          {
            "id": 3,
            "title": "Implement interview scheduling, internal remarks, and outcome summary components",
            "description": "Create detailed UI components for interview scheduling, internal-only interview remarks, final selection/rejection CTAs, outcome summary card, and integrated messaging triggers to students/parents.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement the interview scheduling form with fields for mode (online/physical), date, time, location or meeting link, auto-reminder checkbox, and visible placeholders where developers will later hook calendar/meeting integrations. Create an internal remarks section with ratings and observation fields, visually tagged as internal-only and separated from any student-visible content. Define final decision CTAs with clear copy on implications (account creation, refusal) and implement a derived Outcome Summary card that excludes internal notes while summarizing result and next steps. Embed Send Message entry points for notifying students/parents about interview details and final decisions, following patterns from the notifications/communications system.",
            "status": "done",
            "testStrategy": "Walk through an end-to-end working application from provisional approval to interview scheduling, remarks entry, and final decision, confirming that internal remarks never appear on student-facing views and that scheduling and messaging elements are clear and mobile-friendly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T13:29:08.389Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design trustee panel for provisional approvals and interviews.",
        "updatedAt": "2025-12-28T13:29:08.389Z"
      },
      {
        "id": "14",
        "title": "Implement embedded communication patterns (WhatsApp, SMS, Email)",
        "description": "Create contextual communication UI elements embedded in key workflows with templates and schedule options.",
        "details": "• Identify touchpoints: interview scheduling, selection/rejection, fee reminders, leave approval/rejection, renewal, exit notifications.\n• At each touchpoint, implement a **Send Message** button opening a side panel or modal with:\n  - Channel toggles (WhatsApp, SMS, Email).\n  - Template dropdowns with editable message body.\n  - Recipient list (student, parent, local guardian, superintendent copy).\n• Include schedule options for some flows (e.g., auto-reminders 24 hours pre-interview, fee reminder cadence T-15, T-7, T-3, due date).\n• Show preview of final message including dynamic placeholders ({{name}}, {{date}}, {{amount}}) and highlight to devs that these will be auto-populated.\n• Provide implement for an escalation feature: when fees overdue, UI shows \"Escalate\" with auto-selection of parents + superintendent consolidated report.\n• Ensure all communication triggers are logged via a consistent pattern: show a small \"Log will be stored\" info line.\n• Note to devs: actual sending will use APIs (e.g., Twilio, WhatsApp Business API, transactional email), but implement must be service-agnostic.\n",
        "testStrategy": "• Walk through at least three embedding scenarios (interview, fee reminder, leave decision) in the prototype.\n• Validate that communication UI never hides critical context (e.g., referencing wrong student) by including summary in the panel.\n• Check that templates are editable but have safe defaults.\n• Confirm presence of schedule and escalation UI per PRD requirements.",
        "priority": "high",
        "dependencies": [
          "12",
          "13"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify and Map Communication Touchpoints",
            "description": "Analyze and document all specified touchpoints for embedding communication UI, including interview scheduling, selection/rejection, fee reminders, leave approval/rejection, renewal, and exit notifications.",
            "dependencies": [],
            "details": "Create a visual map or flowchart showing where the 'Send Message' button integrates into each workflow. Prioritize touchpoints based on frequency and urgency (e.g., fee reminders first). Include context summary requirements to avoid wrong recipient errors.",
            "status": "done",
            "testStrategy": "Review map with stakeholders to confirm all PRD touchpoints covered and no critical workflows missed.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T18:46:26.330Z"
          },
          {
            "id": 2,
            "title": "Implement Core Send Message Panel Components",
            "description": "Implement the side panel or modal triggered by 'Send Message' button, featuring channel toggles (WhatsApp, SMS, Email), template dropdowns with editable body, recipient lists, and message preview with dynamic placeholders.",
            "dependencies": [
              1
            ],
            "details": "Specify UI elements: toggles with icons, searchable dropdowns for templates, checkboxes for recipients (student, parent, guardian, superintendent CC), rich text editor for body, and live preview pane showing {{name}}, {{date}}, {{amount}} populated examples. Ensure service-agnostic with dev notes on APIs.",
            "status": "in-progress",
            "testStrategy": "Build and test panel in Figma; test edit/preview flow, placeholder rendering, and responsive modal behavior on desktop/mobile.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T18:53:48.297Z"
          },
          {
            "id": 3,
            "title": "Implement Scheduling, Escalation, and Logging Features",
            "description": "Incorporate schedule options for reminders, escalation UI for overdue fees, and consistent logging indicators across all communication patterns.",
            "dependencies": [
              1,
              2
            ],
            "details": "For scheduling: date/time picker with presets (e.g., T-24h interview, fee cadence T-15/7/3/due). Escalation: prominent 'Escalate' button auto-selecting parents + superintendent with consolidated report template. Add 'Log will be stored' info tooltip everywhere. Ensure non-blocking of parent context.",
            "status": "in-progress",
            "testStrategy": "Build and test 3 scenarios (interview reminder, fee escalation, leave rejection); validate scheduling presets, escalation auto-select, and logging visibility without UX friction.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T20:30:19.271Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design embedded communication patterns (whatsapp, sms, email).",
        "updatedAt": "2025-12-28T20:30:19.271Z"
      },
      {
        "id": "15",
        "title": "Implement fee payment and student-side payment experience",
        "description": "Create student-facing payment UI including fee breakup, payment methods, statuses, and receipts.",
        "details": "• Student payments page: show fee breakup components: processing fee, hostel fees, security deposit, key deposit.\n• Clearly label amounts due, paid, outstanding, and due dates; use status badges (**Paid, Pending, Failed, Overdue**).\n• Payment methods section: UI for UPI and QR Code flows with placeholders for integration; show payment instructions and security notes.\n• Use primary CTA **Pay Now** which opens payment details modal/page with method selection.\n• Upon successful payment, show confirmation screen with receipt download button (print-optimized receipt layout) and summary.\n• Implement failure and pending screens with retry and contact support options.\n• Provide receipt template incorporating logo, payment breakdown, transaction ID, date/time, payer details.\n• Pseudo-code guidance for integration:\n  - Front-end posts to `/payments/create` and receives payment link/QR.\n  - Poll `/payments/status` until success/failure and then update UI state.\n• Ensure DPDP and financial privacy disclaimers are visible where relevant.",
        "testStrategy": "• Build and test payment flows: normal success, failure, and timeout.\n• Validate clarity of fee breakup and ensure no overlapping labels or ambiguous totals.\n• Print sample receipts from the print view implement to check margins and information density.\n• Conduct internal UX review focused on preventing payment confusion and double payments.",
        "priority": "high",
        "dependencies": [
          "2",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement student payments overview page with fee breakup and statuses",
            "description": "Build the main student payments page showing clear fee breakup, totals, and payment status indicators.",
            "dependencies": [],
            "details": "Implement layout that lists all fee components (processing fee, hostel fees, security deposit, key deposit) with per-line amounts and a clear total. Include labels for amounts due, paid, and outstanding, with due dates displayed prominently near the summary. Add visually distinct status badges for Paid, Pending, Failed, and Overdue, ensuring they are readable and accessible. Reserve space for DPDP and financial privacy disclaimers near the summary or footer without distracting from the primary actions.",
            "status": "done",
            "testStrategy": "Review with stakeholders using sample fee scenarios (all paid, partially paid, overdue) to confirm clarity of amounts and labels; run UX checks for readability and accessibility of status badges on mobile and desktop.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T14:16:54.861Z"
          },
          {
            "id": 2,
            "title": "Implement payment initiation and method selection flow (Pay Now, UPI, QR)",
            "description": "Build the interaction and UI for starting a payment, choosing methods, and guiding users through UPI/QR flows with integration placeholders.",
            "dependencies": [
              1
            ],
            "details": "Implement a primary Pay Now CTA on the payments overview page that opens a focused modal or dedicated page. In this flow, present available methods (e.g., UPI, QR Code) with clear icons, brief descriptions, and security notes. Include fields or placeholders that will be populated by backend responses from /payments/create (e.g., payment link, QR image). Provide stepwise instructions for UPI and QR use, plus a visible processing state while payments are in progress. Ensure there is a consistent area in the UI to surface polling-based status updates from /payments/status.",
            "status": "done",
            "testStrategy": "Build and test the Pay Now flow with mock data for UPI and QR and run through success, in-progress, and cancellation scenarios; validate that users always know which step they are on and what to do next, and that the implement can accommodate asynchronous status updates.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T14:20:19.289Z"
          },
          {
            "id": 3,
            "title": "Implement payment result states and receipt experience (success, failure, pending)",
            "description": "Define UI for post-payment outcomes including confirmations, errors, pending states, and a reusable receipt template for students.",
            "dependencies": [
              2
            ],
            "details": "Create distinct screens or states for successful, failed, and pending payments, each with appropriate messaging, visual cues, and next steps. For success, implement a confirmation screen summarizing amount, method, and key details, with a prominent button to download or print a receipt using a print-optimized layout. The receipt template should support logo, fee breakdown, transaction ID, date/time, payer details, and status. For failures and pending states, provide clear explanations, retry options where appropriate, and a contact support path. Ensure DPDP and financial privacy disclaimers are visible where personal and transaction details are shown.",
            "status": "done",
            "testStrategy": "Test flows using mocked payment status responses (success, failure, timeout/pending) to ensure correct screen is shown and actions behave as expected; print sample receipts to verify legibility, information completeness, and brand alignment across common paper sizes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T14:26:46.280Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design fee payment and student-side payment experience.",
        "updatedAt": "2025-12-28T14:26:46.280Z"
      },
      {
        "id": "16",
        "title": "Implement Accounts / Accounting Team dashboards",
        "description": "Create accounting-facing views for receivables, logs, receipts generation, and export-ready layouts for Tally integration.",
        "details": "• Accounts dashboard: KPIs for total receivables, collected, overdue, upcoming due this month; filter by vertical and period.\n• Receivables list: table with student, amount, due date, status, contact summary.\n• Payment logs: chronological record of transactions with filters (status, method, date range) and quick export actions.\n• Receipt management: ability to generate and view receipts under multiple heads; implement for searching by student, receipt number.\n• Export-ready layout for Tally: a simplified, columnar view with only necessary accounting fields; explicit note to devs about CSV/XLS export.\n• Show audit filters: by hostel vertical, by fee component, by user role initiating adjustments.\n• Incorporate communication log links for invoices and reminders.\n• Ensure the dense data interface remains readable with alternating row backgrounds and frozen headers on long tables.",
        "testStrategy": "• Validate that all PRD-required elements (receivables dashboard, receipt generation, logs, exports) are present.\n• Simulate export by framing an example Tally-ready table and running it through a print/PDF check.\n• Review ease of scanning large tables on 1080p and 1366x768 resolutions.\n• Get feedback from finance stakeholders (if available) on terminology and grouping.",
        "priority": "high",
        "dependencies": [
          "15",
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Accounts Dashboard with KPIs and Filters",
            "description": "Build the main overview dashboard displaying key performance indicators for receivables, collections, overdue amounts, and upcoming dues, with filters for vertical and period selection.",
            "dependencies": [],
            "details": "Include cards for total receivables, collected, overdue, upcoming due this month; add dropdown filters for vertical (hostel) and date period; ensure responsive layout with alternating row backgrounds if tables are used.",
            "status": "pending",
            "testStrategy": "Validate KPI calculations with sample data; test filter functionality across different verticals and periods; check readability on 1080p and 1366x768 resolutions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Receivables List, Payment Logs, and Receipt Management",
            "description": "Implement detailed list views for receivables with student details, chronological payment logs with filters and exports, and receipt generation/search interface.",
            "dependencies": [
              1
            ],
            "details": "Receivables table: student, amount, due date, status, contact summary; Payment logs: filters by status/method/date, quick export; Receipts: generate/view by student/receipt number under multiple heads, include communication log links.",
            "status": "pending",
            "testStrategy": "Build and test table scrolling with frozen headers; simulate export actions; test search functionality for receipts; ensure dense data readability with alternating backgrounds.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Tally Export Layout and Audit Filters",
            "description": "Create simplified export-ready columnar view for Tally integration with necessary accounting fields, plus audit filters by hostel vertical, fee component, and user role.",
            "dependencies": [
              1,
              2
            ],
            "details": "Export layout: CSV/XLS with explicit dev notes on fields; add audit filters throughout views; incorporate notes for devs on export implementation and table optimizations like frozen headers.",
            "status": "pending",
            "testStrategy": "Simulate Tally export with example data via print/PDF; verify all PRD elements present; test audit filters across scenarios; review on multiple resolutions for scanability.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design accounts / accounting team dashboards."
      },
      {
        "id": "17",
        "title": "Implement room allocation and check-in interfaces",
        "description": "Create admin and student views for room allocation, occupancy matrix, and check-in confirmation.",
        "details": "• Admin room matrix: grid view by floor/wing with rooms as cards or cells, showing capacity, occupied count, and gender/vertical labels.\n• Filters: by vertical (Boys/Girls/Dharamshala), occupancy status (empty, partial, full), room type.\n• Room detail side panel: list of current occupants, capacity, allocation/change actions, history of allocations.\n• Allocation flow: select student(s) → choose room → confirm allocation with confirmation modal and optional notes.\n• Student view: simple room details page with room number, sharing details (roommates names, beds), joining date, and house rules.\n• Check-in confirmation: implement a one-time confirmation step where student acknowledges room condition/inventory and hostel rules.\n• Use status badges to represent occupancy (Available, Partially Occupied, Full, Blocked).\n• Provide guidance for dev data model: rooms table, occupancy records, and link to student profile.\n",
        "testStrategy": "• Build and test allocation of a new student to a room, including change-room action.\n• Validate that matrix remains usable with several dozen rooms; test horizontal/vertical scrolling behaviors.\n• Confirm that student-facing views show only their room, not others’ sensitive details.\n• Print sample room list for offline use to test legibility.",
        "priority": "medium",
        "dependencies": [
          "3",
          "9",
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Admin Room Allocation Matrix and Filters",
            "description": "Build the grid view for rooms organized by floor/wing, including cards or cells displaying capacity, occupied count, gender/vertical labels, and status badges (Available, Partially Occupied, Full, Blocked). Implement filters for vertical, occupancy status, and room type.",
            "dependencies": [],
            "details": "Use responsive grid layout with hover effects for room cards; integrate side panel for room details on selection; ensure scalability for dozens of rooms with scrolling; provide dev guidance on rooms table and occupancy records linking to student profiles.",
            "status": "done",
            "testStrategy": "Build and test matrix filtering and sorting; validate usability with 50+ rooms; test status badge accuracy against mock data.",
            "parentId": "undefined",
            "updatedAt": "2025-12-29T09:32:04.801Z"
          },
          {
            "id": 2,
            "title": "Implement Room Detail Panel and Allocation Flow",
            "description": "Develop the side panel showing current occupants list, capacity, allocation/change actions, and allocation history. Implement the allocation workflow: select student(s), choose room, confirm via modal with optional notes.",
            "dependencies": [
              1
            ],
            "details": "Include occupant profiles with names and beds; add buttons for allocate/change room; modal should summarize selection, show conflicts, and log notes; link to student profiles for quick selection.",
            "status": "done",
            "testStrategy": "Build and test full allocation flow including multi-student selection and confirmation; test edge cases like over-capacity or blocked rooms.",
            "parentId": "undefined",
            "updatedAt": "2025-12-29T09:32:04.809Z"
          },
          {
            "id": 3,
            "title": "Implement Student Room View and Check-in Confirmation",
            "description": "Create student-facing room details page with room number, roommates' names, beds, joining date, and house rules. Implement one-time check-in confirmation screen for acknowledging room condition, inventory, and hostel rules.",
            "dependencies": [
              1
            ],
            "details": "Keep student view minimal and non-sensitive; use checklists or signatures for check-in; include printable confirmation; ensure integration with occupancy records update post-check-in.",
            "status": "done",
            "testStrategy": "Build and test student view and check-in flow; validate privacy (no other rooms visible); test confirmation modal on mobile and desktop.",
            "parentId": "undefined",
            "updatedAt": "2025-12-29T09:32:04.817Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design room allocation and check-in interfaces.",
        "updatedAt": "2025-12-29T09:32:04.817Z"
      },
      {
        "id": "18",
        "title": "Implement leave management module (student, superintendent, parent views)",
        "description": "Create strict-governance leave request and approval interfaces for all roles.",
        "details": "• Student leave UI: option cards for Short leave, Night-out, Multi-day leave; each opens a tailored form with dates, reason, destination, contact.\n• Show rules and policies prominently (e.g., minimum notice period, curfew).\n• Leave history list with statuses and remarks.\n• Superintendent leave dashboard: table of pending and past leaves with filters by type, status, date, and student.\n• Approve/Reject actions with required remarks, plus an embedded Send Message panel to inform students/parents.\n• Admin-configurable rules (from Task 12) surface as read-only summary on approval screen.\n• Parent view: read-only list of leaves for their ward, with status, dates, and notifications; optional confirmation that they were notified.\n• Clearly mark all dates and times; use calendar and time pickers from the design system.\n• Ensure audit log references (who approved, when) are visible to authorized staff.\n",
        "testStrategy": "• Build and test student: create request → view pending → see approved/rejected state.\n• Build and test superintendent: review → apply decision → trigger notification.\n• Check that parent screens show only their ward’s leaves and no actions.\n• Validate strictness of flows (no self-approval, no editing after approval) through stakeholder review in prototype.",
        "priority": "high",
        "dependencies": [
          "12",
          "14",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement student-facing leave request and history interfaces",
            "description": "Create detailed UI/UX for the student leave experience, including request creation for all leave types, rule visibility, and history views.",
            "dependencies": [],
            "details": "Implement the student dashboard section for leave management with option cards for Short leave, Night-out, and Multi-day leave, each opening a tailored form capturing dates/times, reason, destination, and contact details. Ensure rules and policies (notice periods, curfew, limits) are prominently surfaced contextually near form actions. Define empty, loading, and error states for leave creation. Implement a leave history list with clear status badges, remarks, and sorting/filtering by type and date. Integrate calendar and time picker components from the existing design system and ensure mobile responsiveness.",
            "status": "pending",
            "testStrategy": "Build and test a full student flow: create each leave type, review validation and rule messaging, then verify visibility and clarity of history entries and statuses.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement superintendent leave review, decision, and audit views",
            "description": "Define the superintendent-facing dashboard, review flows, decision actions, and audit visibility for leave governance.",
            "dependencies": [
              1
            ],
            "details": "Create a superintendent dashboard with tables for pending and past leaves, including filters by leave type, status, date range, and student. Implement the leave detail/review screen with prominent display of request data, admin-configurable rules summary (read-only), and past decisions. Specify Approve/Reject flows with mandatory remarks, confirmation patterns, and clear state changes. Integrate an embedded Send Message panel to contact students and/or parents directly from the decision screen. Include visible audit log references (who approved/rejected, when, and key actions) for authorized staff, ensuring the layout supports strict-governance and non-editability after final decisions.",
            "status": "pending",
            "testStrategy": "Run through sample scenarios: filter and open a pending leave, approve with remarks and message, reject with remarks, and verify that audit entries are updated and immutable in UI while list and detail views stay consistent.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement parent-facing leave overview and notification confirmation views",
            "description": "Create read-only parent views for tracking their ward’s leaves and confirming notifications without granting approval powers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement a parent leave overview screen showing a list of their ward’s leave requests only, with clear display of dates, times, type, status, and superintendent remarks. Ensure no action controls for creating, editing, or approving leave are present. Add patterns for notification indicators (e.g., tags or icons) and an optional lightweight confirmation UI for parents to acknowledge they have been notified, without affecting the approval state. Align visual language with broader notification/alert patterns from the project while maintaining strict access boundaries between parent and student data.",
            "status": "pending",
            "testStrategy": "Build and test a parent session: view multiple leave records for a single ward, verify absence of action controls, test the notification acknowledgment interaction, and confirm that data matches the student and superintendent views for the same leave records.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design leave management module (student, superintendent, parent views)."
      },
      {
        "id": "19",
        "title": "Implement 6-month renewal module",
        "description": "Create renewal journey screens for reminders, document re-uploads, fee top-up, consent renewal, and simplified approvals.",
        "details": "• Student renewal entry: card on dashboard and dedicated page when renewal window is open; show remaining days and benefits of timely renewal.\n• Renewal steps: 1) Review personal/academic info, 2) Re-upload updated certificates/marksheets, 3) Fee top-up, 4) Renewal consent, 5) Submit.\n• Integrate payment UI for top-up (reuse patterns from Task 15).\n• Include DPDP consent renewal prompt with explicit text and checkboxes.\n• Show renewal status tracker (Not started → In Progress → Under Review → Approved → Rejected).\n• Superintendent/Trustee renewal list: simplified view vs original admission with quick decisions.\n• Notifications: implement subtle banners/alerts for upcoming renewal (e.g., at 30/15/7 days) in dashboards.\n• Ensure that after successful renewal, status on Student Dashboard updates to \"Renewed\" with new end date.\n",
        "testStrategy": "• Build and test full student renewal process including payment and consent steps.\n• Validate that required re-upload of documents is clearly indicated and cannot be bypassed.\n• Test scenarios: early renewal, last-minute renewal, missed deadline.\n• Confirm that renewal approval screens for admins are simpler yet aligned with governance needs.",
        "priority": "high",
        "dependencies": [
          "9",
          "11",
          "15",
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement renewal entry points and notification surfaces across dashboards",
            "description": "Define where and how students discover the 6‑month renewal journey, and how time-based reminders appear in student and admin dashboards.",
            "dependencies": [
              19,
              9,
              12
            ],
            "details": "Map all UI entry points: dashboard renewal card, dedicated renewal page, and deep links from notifications. Specify pages/components for: (a) default dashboard with no active window, (b) dashboard when renewal window is open with remaining days and benefit messaging, (c) banners/alerts for upcoming renewal at 30/15/7 days, and (d) post-renewal dashboard showing updated status and new end date. Enumerate states such as eligible, not-yet-open, open, closed, and renewed. Document dependencies on notification/communications module and existing dashboard layouts from earlier tasks so layout and tone stay consistent.",
            "status": "pending",
            "testStrategy": "Validate that a student can always find a clear entry to renewal during the open window and that notifications appear in the right time windows without overlapping or cluttering other dashboard components.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement student renewal wizard steps and UI, including document re-upload",
            "description": "Build the multi-step student renewal flow with clear progression, data review, and required document re-uploads.",
            "dependencies": [
              1,
              11,
              19
            ],
            "details": "Define pages/components for each wizard step: (1) review personal and academic information, (2) mandatory and optional document re-upload screen for updated certificates/marksheets, (3) confirmation review step before payment and consent, and (4) final summary. For each step, list states: pristine, validation errors, saving, and success. Integrate document handling patterns from Task 11 for upload, preview, and status chips. Define navigation behaviors (next/back, autosave, resume later) and guardrails preventing skipping required uploads. Document dependencies on core profile data modules and document-management components so information is read-only where needed and edits are constrained.",
            "status": "pending",
            "testStrategy": "Run through end-to-end wizard prototypes verifying that each step validates correctly, documents can be re-uploaded and previewed, and that users cannot submit renewal without completing required sections.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate payment top-up UI using Task 15 patterns within renewal flow",
            "description": "Embed fee top-up and payment confirmation within the renewal wizard using existing payment implement patterns.",
            "dependencies": [
              2,
              15,
              16,
              19
            ],
            "details": "Specify pages/components for the payment step: fee breakdown, selectable payment methods, charges summary, and confirmation screen. Reuse layouts, components, and error states defined in Task 15 for payment initiation, progress, success, and failure. Capture states for: pending calculation, payment in progress, success, failure with retry, and partial payment (if supported). Define how payment outcomes affect the wizard state (lock next steps until success, or allow exit-and-resume). Document integrations and data surfaces needed for Accounts dashboards from Task 16, including how receipts and logs will appear post-payment.",
            "status": "pending",
            "testStrategy": "Simulate payments with mock states (success, failure, timeout) ensuring UI feedback is clear, amounts match upstream fee rules, and payment records surface correctly for Accounts views.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement consent renewal UX including DPDP-compliant text and controls",
            "description": "Build the dedicated consent renewal experience with explicit DPDP wording and clear user choices.",
            "dependencies": [
              2,
              5,
              11,
              19
            ],
            "details": "Define pages/components for the consent step: initial consent screen with DPDP summary text, detailed policy access, and checkboxes for specific consents; error states where consent is not given or incomplete; and confirmation of recorded consents. Ensure copy and patterns align with earlier DPDP treatments from Tasks 5 and 11. Specify how the consent step links to the overall wizard (block submission until required consents are checked, show tooltips or inline help). Capture states for first-time consent vs renewal of previously given consent and show historical consent reference where needed.",
            "status": "pending",
            "testStrategy": "Review consent copy with compliance stakeholders, test flows where users partially consent or refuse, and verify that renewal cannot be completed without mandatory DPDP consents while optional consents behave as configured.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Define renewal status tracking UI and student-facing lifecycle states",
            "description": "Implement how students see and understand the status of their renewal across its lifecycle.",
            "dependencies": [
              1,
              2,
              3,
              4,
              19
            ],
            "details": "Specify pages/components for the renewal tracker component: inline widget on dashboard, full-width tracker on the renewal page, and compact status chip versions. Enumerate and visually differentiate states: Not started, In Progress, Under Review, Approved, Rejected, and any payment-pending or docs-pending intermediates. Define transitions triggered by student actions (submit, edit) and admin decisions. Ensure that after approval, the student dashboard clearly shows status as Renewed with the new end date. Document dependencies on backend status codes and existing status-badge components to keep naming and color semantics consistent.",
            "status": "pending",
            "testStrategy": "Walk through sample timelines from creation to approval/rejection confirming the UI always shows the correct current state, prevents contradictory statuses, and updates immediately following simulated backend changes.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement admin renewal review and decision flows (Superintendent/Trustee)",
            "description": "Create simplified admin views for reviewing and deciding on renewals compared to full admission workflows.",
            "dependencies": [
              2,
              3,
              5,
              11,
              19
            ],
            "details": "Define pages/components for Superintendent/Trustee renewal lists: list view with filters, compact cards, and key columns (student, due date, status, flags). Implement a simplified detail/review screen highlighting only renewal-relevant data: updated documents, fee payment confirmation, consent status, and prior year data snapshot. Specify decision actions (quick approve, reject with reasons, send back for correction) and corresponding confirmation or error states. Compare and document differences from full admission review screens so the UX is lighter but still auditable. Capture dependencies on roles/permissions, document verification flows from Task 11, and accounting data from Tasks 15 and 16 for fee verification.",
            "status": "pending",
            "testStrategy": "Test sample admin journeys where multiple renewals are processed in bulk and individually, confirming that decisions correctly update student-facing status trackers and that minimal but sufficient information is available for safe decisions.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Map edge-case renewal flows (early, last-minute, missed) and messaging",
            "description": "Implement UI states and messages for atypical renewal timings including early, last-minute, and missed renewals.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              19
            ],
            "details": "Enumerate edge-case scenarios: early renewals before standard window, renewals submitted in the final days or hours, and renewals attempted after the window closes. For each, define pages/components and banner states on dashboards and in the wizard: eligibility warnings, urgency prompts, and post-deadline information (e.g., escalation path or appeal process if any). Specify behavior for partially completed renewals when the window closes, including what students see and what admins can do. Align all messaging tone with program policy and ensure no conflicting calls to action appear across surfaces. Document dependencies on scheduling/notification logic and policy rules from product and legal teams.",
            "status": "pending",
            "testStrategy": "Run scenario-based tests walking through each edge case using dated test data, verifying correct access rules, messaging, and handoffs between student and admin views, including how missed renewals are communicated and recorded.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Split Task 19 into: (1) Renewal entry points and notification surfaces across dashboards; (2) Student renewal wizard steps and UI, including document re-upload; (3) Payment top-up integration using Task 15 patterns; (4) Consent renewal UX and DPDP text; (5) Renewal status tracking for students; (6) Admin (Superintendent/Trustee) renewal review and decisions (simplified vs full admission); (7) Edge-case flows (early, last-minute, and missed renewals) and associated messaging. For each subtask, define required frames, states, and dependencies on other modules."
      },
      {
        "id": "20",
        "title": "Implement exit and alumni module",
        "description": "Create UI for exit requests, clearance checklist, exit approval, exit certificate, and migration to alumni state.",
        "details": "• Student: Exit request form detailing desired exit date, reason, and forwarding address; show conditions and implications (fees, deposits).\n• Clearance checklist: items like room inventory check, key return, ID card return, accounts clearance; show statuses (Pending/Completed) for each.\n• Superintendent/Accounts: clearance dashboard summarizing pending tasks per exiting student and actions to mark them completed.\n• Exit approval screen: once all checklist items are cleared, allow final approval with remarks.\n• Exit certificate: implement print-ready certificate including name, vertical, stay period, conduct (if applicable), and signatures.\n• Alumni migration: on approval, update student status to Alumni; implement a simple alumni profile view with contact and history summary.\n• Add links to communication history and financial settlement in admin views.\n",
        "testStrategy": "• Prototype: student raises exit request → admin completes checklist → approves → student downloads certificate.\n• Print exit certificate mock to verify legibility and brand alignment.\n• Confirm no editing of exit records after final approval to preserve audit trail (at least in UI behavior).\n• Review with stakeholders for completeness of checklist items and certificate content.",
        "priority": "medium",
        "dependencies": [
          "17",
          "16",
          "11",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement student exit request flow and implication messaging",
            "description": "Implement the end-to-end student exit request experience, including form fields, guidance copy, and clear explanation of conditions, fees, deposits, and irreversible consequences.",
            "dependencies": [],
            "details": "Map the student journey from discovering the exit option on their dashboard through filling the request form (desired exit date, reason, forwarding address, preferred contact) and submitting it. Include inline help and a dedicated info section summarizing implications: possible forfeiture or adjustment of deposits, fee proration rules, loss of hostel access, and timeline expectations. Clearly differentiate editable vs non-editable fields after submission, and support a limited pre-approval edit/cancel window with explicit warnings before lock-in. Surface a visible status badge for the current exit state (Draft, Submitted, Under Clearance, Approved, Rejected/Withdrawn) and log all key actions (created, edited, canceled, submitted) with timestamp and actor in an audit trail panel that is read-only for admins and view-only for the student. Ensure irreversible transitions (e.g., from Submitted to Under Clearance) require confirmation dialogs that mention their audit-logged nature and that future changes must go through admin roles.",
            "status": "pending",
            "testStrategy": "Build and test the full student flow: create draft → edit → submit → attempt edit after lock → cancel within allowed window. Verify audit log entries are created for each action and remain visible even after state changes, and that irreversible transitions cannot be bypassed via alternative navigation paths.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement clearance checklist UI and cross-role status tracking",
            "description": "Create a structured, role-aware clearance checklist interface showing item-level statuses, ownership, and history for each exiting student.",
            "dependencies": [
              1
            ],
            "details": "Define the canonical checklist items (room inventory, key return, ID card return, accounts clearance, library dues, any custom items) as rows in a unified checklist view attached to the exit request. For each item, show owner role, current status (Pending, In Progress, Completed, Waived), last updated timestamp, and optional remarks. Allow role-based interaction: students see read-only statuses and any student-facing instructions; admins and specific departments can update only their owned items. Capture every change as an immutable audit entry (previous status, new status, remarks, actor, timestamp) and expose this via an expandable history per item. Visually signal when all mandatory items are completed and which items are blocking final approval. Implement safeguards for irreversible status changes (e.g., Completed → revert) by either disallowing reversal in the primary UI or gating it behind an elevated override pattern with justification and separate audit tagging.",
            "status": "pending",
            "testStrategy": "Test with sample roles (student, superintendent, accounts) updating multiple checklist items and confirm visibility rules, status accuracy, and that all changes appear in per-item history. Attempt invalid operations (student editing statuses, cross-role edits) and verify they are blocked. Validate that once an item is marked Completed, UI reversal flows either do not exist or clearly request justification and log enhanced audit data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement superintendent and accounts clearance dashboards and workflows",
            "description": "Create admin-facing dashboards that summarize pending exit-related tasks, support efficient processing, and expose audit-safe task handling patterns.",
            "dependencies": [
              2
            ],
            "details": "Implement separate but consistent dashboards for superintendent and accounts roles, listing exiting students with key attributes (name, room, vertical, requested exit date, overall clearance progress, aging). Provide filters (by hostel, date range, progress state) and sort options (oldest requests first, high-risk cases). Include quick actions to open a student’s clearance detail view and mark owned checklist items as completed, with mandatory remarks where appropriate. Integrate compact views of communication history and financial settlement links so admins can reference context without leaving the workflow. All dashboard actions that change state must route through the same underlying checklist update patterns, ensuring comprehensive audit logging. Irreversible operations (e.g., mass-complete multiple items, closing an old request) should require confirmation, display impact (number of students/items affected), and be highlighted in audit logs as bulk operations for later review.",
            "status": "pending",
            "testStrategy": "Simulate typical admin workflows: triage by filters, open a case, update multiple checklist items, and close a batch of older cases. Verify that dashboard counts match individual student views, that every state-changing action generates a traceable log entry, and that bulk actions correctly log affected records. Run through least-privilege tests ensuring each role only sees and acts on its permitted scope.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement exit approval screen and audit-safe finalization patterns",
            "description": "Define the final approval interface and associated patterns to ensure safe, irreversible transition from active resident to exited status with strong audit guarantees.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create an approval screen that summarizes student details, requested exit parameters, full checklist with statuses, financial settlement summary, and any unresolved warnings. Disable the final approval action until all mandatory checklist items and financial requirements are satisfied or explicitly waived with justification. On approval, trigger a clearly marked irreversible transition that locks editing of the exit record and checklist while still allowing read-only viewing by authorized roles. Require explicit confirmation (modal) that outlines consequences: student will no longer be treated as active resident, certain features will be disabled, and data becomes part of permanent records. Capture structured approval metadata (approver role, name, timestamp, remarks, device/IP if available) and present it as the final entry in the audit log. Provide a narrowly scoped post-approval override pattern (e.g., admin-of-admins) for exceptional reversals that is visually distinct, requires detailed justification, and creates a prominent audit entry referencing the original approval.",
            "status": "pending",
            "testStrategy": "Walk through approval scenarios: fully compliant case, case with missing checklist item, and case requiring a waiver. Confirm that finalization cannot proceed with unresolved blockers and that once approved, all editing controls disappear while data remains viewable. Execute an exceptional reversal using the override role and check that both the approval and reversal are clearly recorded and chronologically ordered in the audit log.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement exit certificate template and download/print flow",
            "description": "Create a print-ready, branded exit certificate layout and the associated UI for generation, viewing, downloading, and printing with proper version control.",
            "dependencies": [
              4
            ],
            "details": "Define a certificate template with institution branding, student identity details, vertical, stay period, conduct statement (if applicable), approval date, and authorized signatures/ seals. Ensure layout is optimized for A4 printing with safe margins and high-contrast typography. In the UI, make certificate generation available only after final approval, with a one-click action that generates a versioned PDF snapshot of the exit record at that time. Prevent editing of certificate content by rendering from immutable data captured at approval; if post-approval corrections are necessary, require a controlled re-issue flow that stores both the old and new versions with reasons. Provide clear controls for viewing online, downloading, and printing, and include a small footer with version number or hash and generation timestamp to support audit verification. Log every certificate generation and download event with actor, timestamp, and version, accessible to admins in an audit panel.",
            "status": "pending",
            "testStrategy": "Print sample certificates (including re-issued ones) to verify layout consistency, legibility, and presence of all required fields. Test generation immediately after approval and after a later correction to confirm that versioning works and historical certificates remain accessible. Track multiple downloads by different roles and ensure each event is logged and retrievable in audit views.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement alumni state transition and minimal alumni profile views with history links",
            "description": "Define the migration from resident to alumni status and implement concise alumni profile views with access to key historical records and clear treatment of irreversible state.",
            "dependencies": [
              4,
              5
            ],
            "details": "Specify that upon final exit approval, the system transitions the student to an Alumni status and removes them from active resident lists while retaining a linked alumni record. Implement a minimal alumni profile page showing core identity details, contact information, stay history summary, exit certificate access, and links to communication history and financial settlement records. Make the alumni status visually distinct from active residents across the system (badges, filters) and ensure alumni records are read-only except for allowed fields like updated contact info, which should be logged when changed. Treat the resident→alumni transition as fundamentally irreversible in standard workflows; any return to resident-like status must follow a separate re-admission process rather than toggling flags. Reflect the transition in an audit trail entry capturing who triggered it (usually automated from approval), when, and from which prior status. Provide filter and search options for admins to locate alumni, and ensure that alumni data is covered by data retention and governance rules surfaced in implement notes.",
            "status": "pending",
            "testStrategy": "Simulate an end-to-end journey from active resident to alumni, verifying that the user disappears from active views and appears in alumni lists with the correct status and profile. Test updates to allowed alumni fields and confirm they generate audit entries. Attempt to revert alumni back to active using normal admin roles and confirm that it is blocked, forcing use of the defined re-admission path if needed, and verify that alumni history links (communications, financials, certificate) open read-only records.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Break Task 20 into: (1) Student exit request flow and explanatory messaging about implications; (2) Clearance checklist UI and status tracking across roles; (3) Superintendent/Accounts clearance dashboards and workflows; (4) Exit approval and audit-safe finalization patterns; (5) Exit certificate print-ready template and download flow; (6) Alumni state and minimal alumni profile views, including links to history. For each, outline how to handle irreversible states and audit requirements in the design."
      },
      {
        "id": "21",
        "title": "Implement audit, logs, and compliance screens",
        "description": "Create comprehensive audit interfaces for communication logs, approvals, consent tracking, and DPDP compliance elements.",
        "details": "• Communication logs: table listing WhatsApp/SMS/Email communications with columns for date/time, sender role, recipient(s), channel, status (sent, failed), and context (fee, interview, leave).\n• Approval history: show records per application/leave/payment/renewal with authority, decision, date/time, and remarks.\n• Consent & undertaking logs: dedicated view listing each consent type (hostel rules, DPDP, parent consent, etc.) with timestamps and method (digital/physical upload).\n• DPDP compliance UI elements:\n  - Persistent but unobtrusive banners/links to data policy.\n  - Data retention information page.\n  - Consent renewal prompts surfaced in renewal module and first logins.\n• Filtering options by date range, vertical, role, channel, and entity type.\n• Emphasize read-only nature of logs; no destructive edits through UI.\n• Provide dev notes: logs tables expected to be large; suggest server-side pagination and export options in guidelines.\n",
        "testStrategy": "• Cross-check log screen requirements with all modules that generate audit entries.\n• Build and test drill-down from specific student/application to a filtered audit view.\n• Validate that DPDP banners and consent info are accessible from login screens and account settings.\n• Run UX review to ensure logs remain usable even with many filters and high data density.",
        "priority": "high",
        "dependencies": [
          "14",
          "12",
          "13",
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Communication and Approval Logs Tables",
            "description": "Create table-based interfaces for communication logs (WhatsApp/SMS/Email with columns: date/time, sender role, recipient(s), channel, status, context) and approval history (per application/leave/payment/renewal with authority, decision, date/time, remarks).",
            "dependencies": [],
            "details": "Include server-side pagination for large datasets, read-only emphasis via visual cues (no edit buttons), filtering by date range, vertical, role, channel, entity type. Add export options (CSV/PDF) with dev notes on implementation.",
            "status": "pending",
            "testStrategy": "Build and test tables with sample data; test filters, pagination, export on desktop/mobile; validate read-only behavior prevents accidental edits.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Consent and Undertaking Logs View",
            "description": "Build dedicated read-only view listing consent types (hostel rules, DPDP, parent consent, etc.) with timestamps, method (digital/physical upload), and filtering options.",
            "dependencies": [
              1
            ],
            "details": "Use card or table layout for consents per entity; integrate filters matching other logs; highlight timestamps and methods prominently; ensure linkage to related entities like students/applications.",
            "status": "pending",
            "testStrategy": "Test drill-down from student profiles to filtered consents; verify completeness across modules (e.g., registration, renewal); UX review for scannability.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement DPDP Compliance UI Elements and Integration",
            "description": "Implement persistent banners/links to data policy, data retention info page, consent renewal prompts in renewal module/first logins, with read-only audit access.",
            "dependencies": [
              1,
              2
            ],
            "details": "Make banners unobtrusive (footer or subtle top bar); implement info page with clear sections on retention policies; prompts as modals/checkboxes with explicit text; integrate into Tasks 5,19 navigation.",
            "status": "pending",
            "testStrategy": "Validate accessibility from login/settings/renewal; cross-check with PRD for DPDP elements; simulate consent renewal flow; stakeholder review for compliance visibility.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design audit, logs, and compliance screens."
      },
      {
        "id": "22",
        "title": "Implement future-proofing placeholders for biometric, visitor, and mess management",
        "description": "Create visual placeholders for future modules without functional logic but aligned with IA and branding.",
        "details": "• Add navigation items or dashboard cards labeled **Biometric Attendance**, **Visitor Management**, **Mess Management** in relevant admin and student views, styled as \"Coming Soon\".\n• Implement simple placeholder screens with iconography and short description of planned functions, ensuring they do not confuse users into expecting current functionality.\n• Use consistent pattern (e.g., greyed-out cards, lock icons) and tooltips to indicate non-availability.\n• Clearly indicate in style guide how devs should treat these placeholders (hidden behind feature flags or static informational pages).\n• Ensure placeholders do not interfere with primary workflows or clutter navigation excessively.\n",
        "testStrategy": "• Verify placeholders appear where requested in PRD but do not provide active actions.\n• Test on mobile that \"Coming Soon\" messaging is legible and not mistaken for an error.\n• Review IA to ensure future modules are logically grouped.\n• Obtain stakeholder sign-off that placeholders don’t create false expectations.",
        "priority": "low",
        "dependencies": [
          "3",
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define IA placement and interaction rules for future module placeholders",
            "description": "Analyze existing information architecture to decide where Biometric Attendance, Visitor Management, and Mess Management should appear in admin and student views and specify how they should be accessed as non-functional entries.",
            "dependencies": [],
            "details": "Review current navigation, dashboards, and role-based views to identify logical positions for the three future modules without disrupting core workflows. Specify whether each will appear as a nav item, dashboard card, or both for each role. Document click behavior (e.g., opens static info screen only, no CTAs), and define rules for when they are visible or hidden (e.g., feature flags, environment settings). Capture these decisions in the IA/route map so devs can wire routes and flags consistently later.",
            "status": "pending",
            "testStrategy": "Cross-check final IA map against PRD to ensure all three modules are represented in the right sections and that no flows require active functionality from these entries.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement consistent UI pattern and copy for ‘Coming Soon’ placeholders",
            "description": "Build the visual and content system for placeholder cards and screens for the three modules, ensuring clarity that features are not yet available and alignment with brand guidelines.",
            "dependencies": [
              1
            ],
            "details": "Implement card states (e.g., greyed-out, low emphasis, lock or clock icon) for Biometric Attendance, Visitor Management, and Mess Management with a unified style. Create corresponding placeholder screens with iconography, short description of intended capabilities, and explicit ‘Coming Soon / Not yet available’ messaging. Define tooltip and helper text patterns that clarify non-availability and avoid any impression that an error occurred. Ensure typography, spacing, colors, and icons follow the existing design system and accessibility rules. Provide React components or similar reusable assets for placeholders.",
            "status": "pending",
            "testStrategy": "Run quick usability checks or stakeholder reviews on mockups to confirm users interpret these elements as future features, not broken links or active modules, and verify visual consistency with the existing design system.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Document implementation guidelines and responsive CSS in the style guide",
            "description": "Extend the design/style guide with explicit guidance on how developers should implement and manage the future-proofing placeholders for the three modules.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add a dedicated section to the style guide that documents when and where to use placeholder cards and screens, including examples for Biometric Attendance, Visitor Management, and Mess Management. Specify technical treatment expectations: use of feature flags vs. static pages, routing behavior, analytics tracking (if any), and rules for hiding/removing placeholders in certain deployments. Clarify non-interference requirements (no blocking primary tasks, minimal nav clutter) and do/don’t examples. Include redlines and component specs so devs can implement without additional clarification.",
            "status": "pending",
            "testStrategy": "Review the updated style guide with implement and engineering leads to ensure the instructions are unambiguous, feasible for implementation, and cover all three modules and environments (web/mobile).",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design future-proofing placeholders for biometric, visitor, and mess management."
      },
      {
        "id": "23",
        "title": "Implement accessibility, help, and error handling patterns",
        "description": "Create consistent UX for tooltips, inline help, progress indicators, confirmation modals, and error states aligned with WCAG.",
        "details": "• Define standard patterns for:\n  - Tooltips (icon, hover/focus behavior).\n  - Inline help text below form fields.\n  - Visual progress indicators (steppers, loaders, skeletons) for long operations.\n  - Confirmation modals for irreversible actions (reject, final approval, exit, delete documents).\n  - Error banners and inline field errors.\n• Ensure color use and focus states meet WCAG 2.1 AA; include keyboard navigation guidance in implement notes.\n• Add a compact help center pattern: small \"?\" icon linking to contextual help or FAQ per page.\n• Document guidelines for error messaging tone: formal, clear, non-technical.\n• Provide pseudo-code for devs on focus management:\n  - Move focus to error summary on form submission failure.\n  - Return focus to triggering element on modal close.\n• Include patterns for empty states that instruct users how to proceed.\n",
        "testStrategy": "• Apply these patterns on at least 3 key flows (application wizard, payment, leave) in the prototype.\n• Use accessibility plugins/checklists in to review text size, color contrast, and focus cues.\n• Conduct keyboard-only walkthrough in working application (Tab/Enter/Esc) to simulate behavior.\n• Review error copy with stakeholders for tone and clarity.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define accessible UI patterns for help, progress, errors, and empty states",
            "description": "Create detailed, WCAG-aligned implement specs for tooltips, inline help, progress indicators, confirmation modals, error banners/inline errors, and empty states.",
            "dependencies": [],
            "details": "Document component-level patterns covering: tooltip trigger icon and label, hover/focus behavior, dismissal, and ARIA usage; inline help placement, wording, and interaction; visual progress indicators including steppers, loaders, and skeletons with text alternatives; confirmation modal structure for irreversible actions with clear primary/secondary actions and warnings; error banners and inline field errors with clear copy, iconography, and associations to fields; empty states that explain next steps and link to primary actions. Ensure consistency with existing design system tokens and component library.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Specify accessibility, color, focus, and keyboard interaction guidelines",
            "description": "Define cross-component accessibility rules for color contrast, focus states, keyboard navigation, and context-sensitive help patterns.",
            "dependencies": [
              1
            ],
            "details": "Write WCAG 2.1 AA–aligned guidelines for minimum contrast ratios, focus ring styles, and state changes for all relevant components. Define keyboard behavior for tooltips, progress steppers, modals (open/close, trap focus, escape handling), banners, and inline errors. Include rules for logical tab order and visible focus. Implement and document the compact help center pattern using a small \"?\" icon that is reachable by keyboard, has accessible name/tooltip, and links to contextual help or FAQ per page.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Document error messaging tone and focus management pseudo-code for developers",
            "description": "Produce implementation-oriented guidance for error messaging style and focus handling across forms and modals.",
            "dependencies": [
              1,
              2
            ],
            "details": "Write tone guidelines for error, warning, and help messages (formal, clear, non-technical, action-oriented), including examples for banners, inline errors, and confirmation modals. Provide pseudo-code and interaction notes for focus management, covering: moving focus to an error summary region on form submission failure; setting focus on first errored field when appropriate; trapping and restoring focus for modals; returning focus to the triggering element on modal close. Align documentation with existing coding standards so devs can integrate patterns consistently.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design accessibility, help, and error handling patterns."
      },
      {
        "id": "24",
        "title": "Define responsive layout grids and breakpoints for all screen types",
        "description": "Standardize grid systems and breakpoints for desktop, tablet, and mobile layouts to ensure consistency.",
        "details": "• Define breakpoint strategy (e.g., Desktop ≥ 1200px, Tablet 768–1199px, Mobile ≤ 767px) and document it in the design system.\n• For each breakpoint, set column grids (e.g., 12-col for desktop, 8 for tablet, 4 for mobile) with defined gutters and margins.\n• Apply grids consistently to key screen templates: dashboards, tables, forms, modals, print views.\n• Use layout grids and responsive CSS to make components responsive; test resizing behavior.\n• Provide implementation notes for devs mapping grids to CSS componentworks (e.g., CSS Grid/Flexbox, or libraries like MUI/Bootstrap if used).\n• Document maximum content width for readability (e.g., ~1200px) and behavior on very wide monitors.\n",
        "testStrategy": "• Check that all major pages/components use the defined grids and no ad-hoc grids exist.\n• Manually resize multiple screens to test responsive behavior and component wrapping.\n• Review on simulated devices (preview) to confirm consistent spacing.\n• Get dev feedback on feasibility of mapping grids to CSS layout utilities.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and document responsive breakpoint strategy in design system",
            "description": "Establish the canonical breakpoint ranges for mobile, tablet, and desktop (and any extra-large or orientation-specific states) and document them clearly in the design system.",
            "dependencies": [
              1,
              2,
              24
            ],
            "details": "• Analyze current and target devices to finalize breakpoint ranges (e.g., mobile ≤767px, tablet 768–1199px, desktop ≥1200px, plus any XL/landscape props and conditional styles if needed).\n• Decide naming convention for breakpoints (e.g., xs/sm/md/lg/xl or mobile/tablet/desktop).\n• Create a dedicated section in the design system file and implement docs describing each breakpoint, its pixel range, intended usage, and example layouts.\n• Add example pages/components per breakpoint (blank shells) labeled with viewport size and responsive CSS for later reuse.\n• Ensure breakpoint definitions align with or can be mapped to front-end tokens or CSS media query variables used by engineering.",
            "status": "pending",
            "testStrategy": "• Review breakpoint list with implement and dev leads to confirm feasibility and alignment with front-end media queries.\n• Check that the design system documentation includes explicit ranges, names, and example pages/components for each breakpoint.\n• Validate no conflicting or duplicate breakpoint definitions exist in previous files or specs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define grid systems (columns, gutters, margins) and map to spacing/typography tokens per breakpoint",
            "description": "Specify the column grids, gutters, and margins for each breakpoint and connect them to existing spacing and typography tokens in the design system.",
            "dependencies": [
              1,
              24
            ],
            "details": "• For each breakpoint, define grid specs: number of columns (e.g., 12 for desktop, 8 for tablet, 4 for mobile), gutter width, and outer margins.\n• Map grid spacing (gutters/margins) to existing spacing tokens from Task 1 (e.g., 16/24/32px) and ensure typographic line lengths support readability (e.g., max content width ~1200px).\n• Create layout grid styles per breakpoint and save them as reusable named styles (e.g., Grid/Desktop/12col).\n• Document how typography scales across breakpoints (e.g., heading size adjustments, line-height, and content width recommendations).\n• Include visual examples: one or two simple content layouts per breakpoint that demonstrate proper column usage and spacing alignment to tokens.",
            "status": "pending",
            "testStrategy": "• Apply each grid style to sample pages/components at each breakpoint and verify columns, gutters, and margins match the documented values.\n• Check that spacing units visible in redlines align with design tokens (no ad-hoc values).\n• Confirm max content width and line length meet readability goals when previewed at common device sizes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Apply grids and responsive CSS to key templates in with example pages/components",
            "description": "Use the defined grids to build key screen templates (dashboards, tables, forms, modals, print views) and set up layout responsive CSS and resizing behavior for each breakpoint.",
            "dependencies": [
              1,
              2,
              24
            ],
            "details": "• Create base template pages/components for each key screen type (dashboards, data tables, forms, modals, print views) at mobile, tablet, and desktop breakpoints.\n• Apply the appropriate layout grid style to each component and ensure components snap to columns and respect gutters/margins.\n• Configure responsive CSS and Flexbox/Grid so core components (nav, sidebars, content area, modals) resize and reflow correctly on component width changes.\n• Include at least one annotated example component per template/breakpoint combination showing column spans, content width, and stacking rules.\n• Define simple rules for component behavior across breakpoints (e.g., sidebar collapses, table columns stack or scroll, form fields move from multi-column to single-column).",
            "status": "pending",
            "testStrategy": "• Manually resize each template component in and verify that components remain aligned to the grid and behave according to defined rules.\n• Check that all key templates use only the standardized grid styles (no local grid overrides).\n• Review example pages/components with at least one other designer to confirm clarity and consistency of grid usage.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Align with developers on grid implementation and validate via responsive tests",
            "description": "Document how grids map to CSS Grid/Flexbox or chosen UI libraries, and run joint validation using resizing tests and device previews.",
            "dependencies": [
              1,
              2,
              3,
              24
            ],
            "details": "• Document mapping from each breakpoint and grid spec to front-end implementation (e.g., CSS Grid template columns, Flexbox wrappers, or MUI/Bootstrap grid props).\n• Provide example code snippets or pseudo-code for common layouts (dashboard with sidebar, form page, data table) reflecting the agreed column counts and breakpoints.\n• Walk through the grid and breakpoint documentation with dev leads to confirm naming, token mapping, and feasibility within the existing tech stack.\n• Run responsive checks on interactive prototypes or staged builds, comparing behavior to example pages/components for each breakpoint.\n• Capture any deviations or responsive CSS from engineering and update implement guidelines and example pages/components accordingly.",
            "status": "pending",
            "testStrategy": "• Cross-check breakpoints and column counts in CSS or UI library configuration against the design system specs.\n• Test real or working application pages in browser dev tools across a range of viewport widths to ensure layouts switch at the correct breakpoints and match examples.\n• Collect developer feedback on implementation clarity and adjust documentation until no ambiguities remain.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Split Task 24 into: (1) Breakpoint strategy definition and documentation; (2) Grid systems (columns, gutters, margins) per breakpoint and mapping to typography/spacing tokens; (3) Application of grids to key templates (dashboards, forms, tables, modals, print views) and Figma constraints setup; (4) Developer alignment: notes on mapping Figma grids to CSS Grid/Flexbox or chosen UI libraries, plus validation via resizing tests. For each, define explicit guidelines and example frames."
      },
      {
        "id": "25",
        "title": "Create functional end-to-end working application for primary user journeys",
        "description": "Link key screens in into an interactive working application covering major flows for each role.",
        "details": "• Journeys to include:\n  - Applicant: Landing → OTP → Application Wizard → Tracking.\n  - Student: Login → Dashboard → Pay Fees → Apply for Leave → Check Room → Renewal → Exit.\n  - Superintendent: Login → Application Review → Approve/Forward → Leave Approval → Config.\n  - Trustee: Review forwarded app → Schedule Interview → Final Decision.\n  - Accounts: View receivables → Export.\n  - Parent: OTP Login → View fees and leaves.\n• Use working application connections with smooth transitions where suitable for smooth transitions.\n• Add hotspot hints and annotations on a separate overlay component or page for stakeholders to understand flows.\n• Ensure props and conditional styles and component states (hover, focused, error) are demonstrated where relevant.\n• Configure starting points for each persona for easy testing in user sessions.\n",
        "testStrategy": "• Walk through all defined journeys end-to-end and fix any dead links or wrong transitions.\n• Share working application with 2–3 stakeholders per role and gather feedback on navigation and flow.\n• Verify that transitions work on desktop and mobile previews.\n• Ensure performance of working application is acceptable (no excessive nesting causing lag).",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "20",
          "21",
          "22",
          "23",
          "24"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define working application architecture, flows, and entry points per persona",
            "description": "Map all personas to their full journey, group relevant pages/components, and configure flow starting points for each role.",
            "dependencies": [],
            "details": "Create a working application architecture map listing Applicant, Student, Superintendent, Trustee, Accounts, and Parent flows and their exact component sequences. Group pages/components into labeled sections per persona, define which screen is the starting component for each journey, and set named flows (e.g., “Applicant – Application Wizard,” “Student – Renewal & Exit”). Note cross-journey links (e.g., from Landing to Parent OTP, Student Login, Applicant start). Specify where device type and viewport settings differ between desktop and mobile. Document which pages/components will be reused across flows and where role-based props and conditional styles of a screen are needed.",
            "status": "pending",
            "testStrategy": "In Figma, use the Flow list to verify each persona has a distinct named starting point and that pressing Present from each flow starts on the intended component without showing other journeys by default.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Wire applicant journey interactions and component states",
            "description": "Implement working application connections for the Applicant flow: Landing → OTP → Application Wizard → Tracking, including stateful component props and conditional styles.",
            "dependencies": [
              1
            ],
            "details": "On the Applicant journey pages/components, connect primary CTAs and form actions from Landing to OTP entry, OTP verification success, and error/retry states, then into the multi-step Application Wizard and final Tracking view. Use Framer Motion or CSS transitions between steps where UI elements persist (e.g., header, progress, form container) to show smooth transitions. Demonstrate interactive component props and conditional styles for buttons (default, hover, disabled, loading), text fields (empty, focused, filled, error), steppers/progress indicators (step changes), and status badges on the Tracking screen. Ensure back, cancel, and resume actions navigate correctly without dead ends and that failure paths (invalid OTP, required-field errors) are represented with at least one dedicated component each.",
            "status": "pending",
            "testStrategy": "Run the Applicant flow in development server, clicking through both success and error paths. Confirm: all CTAs navigate to the correct next step, Framer Motion or CSS transitions is applied where elements persist, and each important component shows at least one interactive or variant-driven state (focus, error, hover, disabled).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wire student journey interactions and renewal/exit states",
            "description": "Implement working application interactions for the Student flow: Login → Dashboard → Pay Fees → Apply for Leave → Check Room → Renewal → Exit, demonstrating residency states.",
            "dependencies": [
              1
            ],
            "details": "Link Student Login to Dashboard using appropriate success and error states. From the Dashboard, wire quick actions to Pay Fees (including at least one payment-in-progress and success/failure variant), Apply for Leave (integrated with Task 18 leave forms and statuses), View Room Details, Renewal, and Exit flows. Use Framer Motion or CSS transitions or instant transitions where appropriate to illustrate changes in resident status (Checked-in, Renewal Due, Renewed, Exit-initiated, Exited) via the tracker and badges. Demonstrate component props and conditional styles such as tab switches, accordions, table row hover/selection (for histories), and notification states (unread vs read). Ensure that renewal completion returns to an updated Dashboard state, and exit completion reflects restricted or read-only access where applicable.",
            "status": "pending",
            "testStrategy": "Simulate a full Student session in the prototype: login, pay a fee, submit a leave request, inspect room details, complete a renewal, and initiate/complete exit. Verify that status indicators and dashboards update to the correct state screens and that there are no broken links or loops that trap the user.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Wire superintendent, trustee, accounts, and parent role flows with key tasks and states",
            "description": "Create role-specific working application wiring for superintendent, trustee, accounts, and parent journeys with their primary tasks and UI states.",
            "dependencies": [
              1
            ],
            "details": "For Superintendent, wire Login to Application Review lists, then to detail views enabling Approve/Forward paths, Leave Approval, and Config screens, showing table interactions (filters, sort hover, row selection) and action button states (default, hover, disabled). For Trustee, connect entry from a forwarded application list to application detail, Schedule Interview, and Final Decision pages/components, including at least one confirmation modal. For Accounts, wire navigation to receivables views (tables with pagination/filter props and conditional styles) and Export actions with a feedback state (e.g., export-in-progress, success). For Parent, implement OTP Login (aligned with Task 8) through to a read-only Dashboard showing fee status, leave summary, and notifications, explicitly demonstrating disabled or hidden edit actions and view-only interactions like tabs or filters. Reuse interactive components and props and conditional styles wherever possible to maintain consistency across admin and parent flows.",
            "status": "pending",
            "testStrategy": "Present each role’s flow independently and walk through its primary tasks: superintendent reviewing and approving/forwarding an application and a leave request, trustee scheduling an interview and recording a decision, accounts exporting receivables, and parent logging in via OTP and reviewing fees and leaves. Confirm that all critical buttons and navigation elements respond with a state change or screen transition, and that parent views do not expose any state-changing controls.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimize working application performance, overlays, and end-to-end validation",
            "description": "Add annotation overlays and hotspot hints, tune working application settings for performance, and run a comprehensive validation to remove dead ends or incorrect transitions.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create dedicated annotation/legend pages/components or overlay components describing each persona’s flow, key assumptions, and any non-obvious interactions, then hook them up via info icons or a separate ‘Guided Tour’ flow. Add hotspot hints on complex screens to indicate functional areas where discoverability is a concern. Review and simplify transitions or Framer Motion or CSS transitions usage where performance may lag, and adjust device settings or remove unnecessary media to keep interactions smooth. Conduct a systematic link audit across all flows, checking that back, close, and alternative paths always return to a valid component and that all modal overlays have both entry and exit interactions. Ensure every major component type (buttons, fields, tables, tabs, steppers, badges) is demonstrated with at least one interactive or variant-driven state somewhere in the working application for stakeholder review.",
            "status": "pending",
            "testStrategy": "Use Figma’s working application development server to run scripted end-to-end scenarios for each persona, deliberately testing edge paths (cancel, back, error, and overlay close actions) while monitoring for jank or long load times. Fix any dead links or misrouted transitions identified, then share the working application with a small stakeholder set per role and collect feedback specifically on clarity of flows, discoverability of hotspots, and performance, iterating until no critical navigation or state-visibility issues remain.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Decompose Task 25 into: (1) Prototype architecture and entry points definition per persona; (2) Wiring and interactions for applicant-related flows (Landing → OTP → Application → Tracking); (3) Wiring and interactions for student flows (Login → Dashboard → Fees → Leave → Room → Renewal → Exit); (4) Wiring for admin/parent/accounts roles with key tasks; (5) Prototype performance, annotation overlays, and validation pass to fix dead ends or incorrect transitions. For each, define how states and component variants will be demonstrated."
      },
      {
        "id": "26",
        "title": "Prepare developer handoff specifications and annotations",
        "description": "Document component specs, behaviors, and integration notes for developers consuming the designs.",
        "details": "• For each core component and template screen, add measurement specs (spacing, typography, colors) using Inspect-friendly naming.\n• Document interaction behaviors (hover, focus, active, disabled, loading) and transitions directly on component examples.\n• Add pseudo-code snippets and API shape hints where relevant (e.g., status enums, routing logic, OTP flows), while keeping stack-agnostic but React/Next.js-friendly.\n• Define accessibility requirements and keyboard behavior per component.\n• Group these notes in a dedicated \"Dev Specs\" page with links to relevant designs.\n• Encourage use of Figma’s Dev Mode for direct asset export of icons and images; mark exportable elements.\n• Include guidance on mapping roles and permissions into the front-end (e.g., route guards, conditional rendering).\n",
        "testStrategy": "• Review Dev Mode to ensure all key components expose understandable names and tokens.\n• Conduct a handoff session mock where a dev navigates the file and confirms clarity.\n• Validate that all complex flows (multi-step forms, payments, approvals) have at least one annotated reference screen.\n• Update specs iteratively based on developer feedback.",
        "priority": "high",
        "dependencies": [
          "2",
          "23",
          "24"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Component-level specs using Dev Mode",
            "description": "Add measurement specs for tokens, spacing, typography, colors for core components and screens using Inspect-friendly naming and Dev Mode conventions.",
            "dependencies": [],
            "details": "Apply consistent naming conventions (e.g., spacing-sm-8px, color-primary-#hex); mark exportable assets; ensure all states (default, hover, etc.) have specs visible in Dev Mode.",
            "status": "pending",
            "testStrategy": "Review Dev Mode inspect panel for all core components to confirm specs are accurate and accessible.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Screen and flow-level interaction specs",
            "description": "Document behaviors, edge cases, routing, and role-based logic for template screens and flows like login, renewal, exit.",
            "dependencies": [
              1
            ],
            "details": "Annotate interactions (hover, focus, transitions) on examples; cover edge cases (invalid creds, expired links) and role logic (route guards, conditional rendering).",
            "status": "pending",
            "testStrategy": "Build and test key flows in and simulate dev navigation to verify interaction clarity.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Accessibility and keyboard requirements",
            "description": "Define a11y requirements and keyboard behaviors for each component and flow, including ARIA labels and navigation order.",
            "dependencies": [
              1
            ],
            "details": "Specify labels, contrast ratios, focus order; call out non-standard heading hierarchies; align with WCAG for forms, modals in tasks like documents and renewal.",
            "status": "pending",
            "testStrategy": "Use working application with keyboard navigation and screen reader simulation to validate.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "API shapes and pseudo-code for critical flows",
            "description": "Provide stack-agnostic pseudo-code and API hints for OTP, payments, approvals, status enums in flows like login, renewal.",
            "dependencies": [
              2
            ],
            "details": "Include snippets for status handling (pending/verified), routing logic; format as code blocks on relevant screens, React/Next.js-friendly but neutral.",
            "status": "pending",
            "testStrategy": "Share snippets with sample dev for feedback on clarity and implementability.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Organize dedicated Dev Specs section",
            "description": "Create a Dev Specs page grouping all notes with navigation links to designs, components, and flows.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use clear headings, thumbnails, single source of truth; link to components/screens; encourage Dev Mode for exports; consistent naming across file.",
            "status": "pending",
            "testStrategy": "Mock handoff navigation: ensure devs can find specs without guidance.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Conduct handoff validation and iterations",
            "description": "Run validation sessions with devs, gather feedback, and iterate on specs based on input.",
            "dependencies": [
              5
            ],
            "details": "Schedule mock handoff sessions; track feedback on clarity, completeness; update file with changes, notify via Dev Mode status.",
            "status": "pending",
            "testStrategy": "Post-session survey: confirm 90% spec clarity; re-test complex flows like payments post-iteration.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Split Task 26 into: (1) Component-level specs (tokens, measurements, states) using Figma Dev Mode conventions; (2) Screen- and flow-level interaction specs (behaviors, edge cases, routing and role logic); (3) Accessibility and keyboard interaction requirements per component/flow; (4) API shape and pseudo-code hints for critical flows (OTP, payments, approvals) while staying stack-agnostic; (5) Organization of a dedicated \"Dev Specs\" section with navigation guidance; (6) Handoff validation sessions and iteration based on dev feedback. For each, define concrete documentation artifacts needed."
      },
      {
        "id": "27",
        "title": "Set up library organization and versioning strategy",
        "description": "Organize files into libraries and define a versioning workflow for sustainable collaboration.",
        "details": "• Structure: one main Design System library file, and separate product files for Public (Landing/Applicant), Student, Admin (Superintendent/Trustee/Accounts), Parents/Alumni.\n• Enable npm package publishing or shared components for components and styles; define naming conventions and categories.\n• Establish a versioning practice: tag major milestones (v1.0 Admission MVP, v1.1 Renewal & Exit, etc.) with file versions.\n• Set up branching or duplicate files for experimentation without disturbing the main library.\n• Document contribution guidelines for designers (how to add components, update tokens, deprecate components).\n• Provide notes for devs on how to subscribe to libraries and track breaking changes.\n",
        "testStrategy": "• Verify that all screens use shared React components rather than local components where intended.\n• Test npm package publishing or shared components and consumption in a sandbox team project.\n• Review naming consistency and searchability of components.\n• Ensure at least one previous version is easily restorable from history.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement file and library structure with clear naming conventions",
            "description": "Define the concrete project, file, page, and component naming structure for the main Design System library and the product-specific files (Public, Student, Admin, Parents/Alumni).",
            "dependencies": [],
            "details": "Create or reorganize projects to separate the core Design System from product work files. Within the Design System project, create a primary \"Design System – Foundations & Components\" file that will act as the main library, plus distinct product files for Public (Landing/Applicant), Student, Admin (Superintendent/Trustee/Accounts), and Parents/Alumni. Inside the library file, create pages for Foundations, Components, Patterns, and Documentation. Define and document a component and style naming convention (e.g., `Button / Primary / Filled`, `Form / Input / Text`, `Color / Background / Surface`) and map where system-level components live vs. where product-specific props and conditional styles live. Add a short in-file documentation component describing when to create or keep components in the system library vs. in product files, with examples for each role/vertical.",
            "status": "pending",
            "testStrategy": "Open each project and verify that the Design System and all product files follow the agreed structure and naming patterns. Confirm that new components can be located predictably via the Assets panel search using the defined naming scheme.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure npm package publishing or shared components, categorization of components/styles, and access permissions",
            "description": "Set up npm package publishing or shared components for the Design System file, categorize components and styles, and ensure correct team/project permissions and library enablement settings.",
            "dependencies": [
              1
            ],
            "details": "In the Design System file, convert key UI elements into main components and define Color, Text, and Effect Styles for tokens, ensuring they are on clearly labeled pages (e.g., Foundations, Components). Open the Team Library or Libraries panel and publish the Design System file as a shared library, confirming that all required components and styles are included while excluding work-in-progress or nested helper elements not meant for consumption. Organize components into logical groups using pages, pages/components, and slash-based naming for categories (e.g., `Navigation / Tabs`, `Feedback / Toast`). For each product team/project, enable the Design System library and, if needed, set up additional smaller product libraries. Review and adjust file and project permissions so only designated maintainers can publish library updates, while all designers can consume the library.",
            "status": "pending",
            "testStrategy": "From a separate sandbox file with only view access to the library, verify that components and styles appear under the expected categories and groups in the Assets and Styles panels. Confirm that non-maintainers cannot publish changes but can consume updates. Publish a small test change and ensure it appears as an update notification in consumer files.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define and implement versioning and branching workflow",
            "description": "Create a practical versioning and experimentation process using file versions, naming conventions, and branching or duplicates for safe iteration.",
            "dependencies": [
              1,
              2
            ],
            "details": "Decide on a version naming convention for milestones (e.g., `v1.0 Admission MVP`, `v1.1 Renewal & Exit`) and document when to create a named version (e.g., after a release, after major component changes). In the Design System file, create at least one example named version to validate the workflow. Define how designers should use branching (if available) or duplicate files/pages for experiments: specify which file is the \"main\" library, who can create branches, how to label them (e.g., `branch/button-states-refactor`), and the process for merging or discarding. Document rollback expectations, including how to restore a previous version or revert published library changes. Capture this as a short \"Versioning & Branching\" section in the system documentation component or a dedicated documentation file linked from the library.",
            "status": "pending",
            "testStrategy": "Create a test branch or duplicate file, make visible changes to a few components, then merge or replace them into the main library and publish. Verify that consumer files receive update prompts and that you can revert to a previous named version if needed. Check that the named versions history clearly reflects the milestone tags.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Document designer contribution, change management, and deprecation guidelines",
            "description": "Create written guidelines and lightweight workflows for how designers add or modify components, update tokens, and deprecate or replace existing components in the library.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Within the Design System file (or a dedicated \"Design System – Docs\" file), create a Documentation page or component titled \"Designer Contribution Guidelines.\" Specify step-by-step instructions for proposing new components (e.g., work in a dedicated playground page or branch, follow naming and property conventions, request review), updating foundations/tokens (color, type, spacing), and extending props and conditional styles. Define what constitutes a breaking change and outline the required review process for such changes (e.g., implement review, dev sign-off). Establish a deprecation model, including how to tag deprecated components (e.g., prepend `Deprecated /` in the name, add a red badge in the component thumbnail, update description with replacement information), how long deprecated components remain before removal, and how to communicate replacements to designers. Include visual examples and checklists directly in the documentation component.",
            "status": "pending",
            "testStrategy": "Ask another designer to follow the written process to add a small new component and deprecate an old variant in a sandbox branch. Observe whether they can do so without verbal clarification. Verify that deprecated components are clearly identifiable in the Assets panel and have guidance pointing to replacements.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create developer consumption and update-tracking guidelines for libraries",
            "description": "Provide clear instructions and norms for developers on how to subscribe to libraries, interpret components/tokens, and safely track and adopt library updates without introducing breaking changes.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create a \"For Developers\" documentation component or page in the Design System or a separate handoff/documentation file. Describe how devs should enable the Design System library in or their inspection tool, where to find canonical components and styles, and how tokens map to implementation (e.g., token naming vs. CSS variables or design tokens in code). Outline the process for monitoring changes: how and when maintainers will announce new versions or breaking changes (e.g., release notes component, Slack/Notion link), how to use Figma’s library update dialog to inspect diffs before accepting, and what to do if an update breaks a layout. Include examples of a typical \"release notes\" entry summarizing changed components, deprecated items, and recommended adoption steps. Ensure this documentation is shared with dev leads and linked from any engineering documentation hubs.",
            "status": "pending",
            "testStrategy": "Share the developer guidelines with at least one dev and ask them to enable the library in a fresh file, inspect a component, and walk through accepting a test library update. Confirm they can map a component’s styles/tokens to implementation names and explain how they would detect and respond to a breaking change announcement.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Decompose Task 27 into: (1) File and library structure design (system vs product files) and naming conventions; (2) Library publishing setup, component/style categorization, and permissions; (3) Versioning and branching strategy (milestone tags, experimentation approach); (4) Contribution guidelines for designers and process for deprecations/changes; (5) Developer consumption guidelines, including how to track updates and avoid breaking changes. For each, define the concrete Figma operations and documentation to create."
      },
      {
        "id": "28",
        "title": "Implement notifications and in-app alerts system",
        "description": "Create consistent UI for in-app notifications, banners, and reminder alerts across modules.",
        "details": "• Notification center: bell icon with dropdown showing latest notifications (fees, renewal, leaves, interviews), with type icons and timestamps.\n• In-page banners for critical alerts (e.g., overdue fees, renewal due, interview today) using color-coded statuses.\n• Badge counts on main nav items (e.g., new applications, pending approvals).\n• Notification detail page listing full history with filters by type and date.\n• Use consistent language and tone across all alerts.\n• Provide dev notes on polling or push patterns conceptually (while leaving implementation details to tech stack), and on marking notifications as read.\n• Ensure notifications are accessible (screen-reader announcements guidance in notes, non-color-only distinctions).\n",
        "testStrategy": "• Verify all modules that need reminders/alerts have corresponding notification patterns.\n• Build and test reading and clearing notifications in student and admin views.\n• Check responsive behavior of the notification dropdown and banners.\n• Review with stakeholders that reminder timing (fee, renewal, interview) is communicated clearly.",
        "priority": "medium",
        "dependencies": [
          "9",
          "14",
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define notification types, hierarchy, and UX patterns",
            "description": "Identify all notification and alert types across modules (fees, renewals, leaves, interviews, approvals, etc.) and define a clear hierarchy (e.g., passive info, warning, critical) with corresponding UX patterns (center dropdown item, in-page banner, badge, modal if needed).",
            "dependencies": [],
            "details": "Map events from related modules (accounts, renewal, exit, registration) to specific notification types and priorities. Define which events surface in the bell dropdown, which require in-page banners, and which only use badges. Specify behavior rules: ordering, grouping, when to auto-expire, when to require explicit dismissal, and how read/unread states work across views. Document triggers conceptually without going into stack-specific implementation.",
            "status": "pending",
            "testStrategy": "Review a matrix of event types versus notification channels (center, banner, badge, email/SMS if applicable) with stakeholders and validate that each use case is covered without over-notifying users.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement UI for notification center, banners, badges, and detail history",
            "description": "Create detailed UI layouts and interaction specs for the bell icon dropdown, in-page banners, nav badge counts, and the full notification history page with filters and empty/error states.",
            "dependencies": [
              1
            ],
            "details": "Implement the notification center dropdown: bell icon states, unread indicator, max visible items, scroll behavior, hover/focus states, timestamps, type icons, and inline actions (e.g., mark as read). Define visual and interaction patterns for in-page banners, including placement rules, color/status mapping, icons, copy length, and dismissal. Specify badge styles and placement on main navigation items. Implement the notification history page with sorting, type/date filters, pagination, bulk actions, and mobile-responsive behavior. Provide UI specs, components, and props and conditional styles in the design system file.",
            "status": "pending",
            "testStrategy": "Build and test interactions for the dropdown, banners, and history page; run through common scenarios (many unread items, no notifications, mixed types) and validate responsiveness and usability with quick stakeholder or hallway tests.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define content guidelines, accessibility, and developer notes for notifications",
            "description": "Create guidelines for notification copy, tone, accessibility requirements, and conceptual dev notes on delivery (polling/push) and read-state handling.",
            "dependencies": [
              1,
              2
            ],
            "details": "Write copy patterns and templates for common notification types (fees, renewals, leaves, interviews) to ensure consistent tone, brevity, and clarity. Define rules for titles, body text, CTAs, and timestamps. Add accessibility guidance: ARIA roles, screen reader announcement behavior, focus management, keyboard navigation, and non-color visual distinctions for status. Provide conceptual notes for engineers on polling vs. push patterns, deduplication, throttling, and how notifications transition between unseen/unread/read across devices and sessions, without prescribing specific tech-stack implementations.",
            "status": "pending",
            "testStrategy": "Review guidelines with design, content, and engineering leads to ensure feasibility; perform spot-checks on sample screens for adherence to tone, accessibility checks (using screen reader and keyboard navigation), and consistency of read/unread behavior across mocked flows.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design notifications and in-app alerts system."
      },
      {
        "id": "29",
        "title": "Implement print-optimized templates for forms, letters, undertakings, and receipts",
        "description": "Create dedicated A4-friendly designs for all printable artifacts required for audit and physical submission.",
        "details": "• Templates to include:\n  - Application summary form.\n  - Provisional and final admission letters.\n  - Undertakings and consent forms (student, parent, local guardian).\n  - Fee receipts.\n  - Exit certificates.\n• Use A4-sized pages/components with defined margins (~20–25mm), mono/duo-color scheme to reduce ink usage, and legible fonts at print sizes.\n• Include institutional header (logo, name, address), reference numbers, dates, and signature blocks.\n• Keep layouts simple and use table structures for data where appropriate.\n• Add small footers with DPDP/data usage disclaimers where relevant.\n• Ensure the content aligns with on-screen information to avoid discrepancies.\n• Provide guidance in notes on mapping these templates to PDF generation in the application layer.\n",
        "testStrategy": "• Export each template as PDF and print on test printer or viewer to check readability and alignment.\n• Cross-check data fields vs respective on-screen counterparts.\n• Review with administrative staff/stakeholders for acceptance and compliance.\n• Iterate to fix any clipping or layout issues observed on physical prints.",
        "priority": "high",
        "dependencies": [
          "11",
          "15",
          "20",
          "21"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement A4 Layout Framework and Common Elements",
            "description": "Establish standardized A4 page setup with margins (20-25mm), mono/duo-color scheme, legible fonts, institutional header (logo, name, address), footers with DPDP disclaimers, and signature blocks for all templates.",
            "dependencies": [],
            "details": "Use 210x297mm A4 dimensions at 300 DPI; apply table structures for data alignment; ensure print optimization with CMYK, simple grids (e.g., 8pt), and hierarchy (headlines 18-24pt, body 9-12pt); test for ink efficiency.",
            "status": "pending",
            "testStrategy": "Export to PDF, print test for margins/alignment/readability; verify color usage and font legibility at print size.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Templates for Forms and Letters",
            "description": "Implement print-optimized templates for application summary form, provisional/final admission letters, undertakings/consent forms (student, parent, local guardian), incorporating reference numbers, dates, and data mapping.",
            "dependencies": [
              1
            ],
            "details": "Structure forms with tables for fields matching on-screen data; letters with formal layout, placeholders for dynamic content; keep simple, aligned with institutional branding and audit requirements.",
            "status": "pending",
            "testStrategy": "Cross-check fields against application screens; PDF export/print review for discrepancies; stakeholder feedback on content alignment.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Receipts, Exit Certificates, and Integration Notes",
            "description": "Develop fee receipts and exit certificates templates; provide developer guidance on PDF generation mapping from application layer.",
            "dependencies": [
              1
            ],
            "details": "Receipts with tabular fee breakdown, receipt numbers; certificates with formal borders/signatures; include notes on variable data insertion, PDF export standards (PDF/X), and avoiding print issues like clipping.",
            "status": "pending",
            "testStrategy": "Print prototypes on A4; validate data population simulation; admin staff review for compliance and usability in physical submission.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on design print-optimized templates for forms, letters, undertakings, and receipts."
      },
      {
        "id": "30",
        "title": "Conduct usability review and iterate on critical flows",
        "description": "Run internal usability checks on critical flows and refine designs based on findings.",
        "details": "• Focus flows: admission application, login and dashboard, payment, leave request, renewal, exit.\n• Prepare small test scenarios and tasks for representative users or internal testers.\n• Use prototype, observe navigation paths, error recovery behavior, and comprehension of labels.\n• Collect prioritized list of issues (e.g., confusing labels, hidden CTAs, dense tables) and update designs accordingly.\n• Pay special attention to multi-role clarity (ensuring users always know which role and vertical context they are in).\n• Document key changes and rationale in a short changelog within the project.\n",
        "testStrategy": "• Conduct at least one review session per main persona and capture feedback.\n• Re-test updated designs to confirm issues are resolved.\n• Validate that no critical path (apply, pay, renew, exit) has usability blockers.\n• Have stakeholders sign off on revised prototypes as v1.0 release-ready.",
        "priority": "medium",
        "dependencies": [
          "25"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Prepare Usability Test Plan and Scenarios",
            "description": "Develop detailed test scenarios, tasks, and scripts for the specified critical flows using prototype, focusing on navigation, error recovery, labels, and multi-role clarity.",
            "dependencies": [],
            "details": "Define in-scope flows (admission application, login/dashboard, payment, leave request, renewal, exit); create 3-5 tasks per flow with realistic scenarios; pilot test scripts internally; document goals, success metrics, and personas per NN/g and Nielsen methods.",
            "status": "pending",
            "testStrategy": "Review plan with team for completeness; simulate one full session to validate task clarity and timing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Conduct Internal Usability Testing Sessions",
            "description": "Run moderated usability tests with internal testers or representative users on prototype, observing key behaviors and collecting feedback on critical flows.",
            "dependencies": [
              1
            ],
            "details": "Schedule 4-6 sessions covering all flows; use think-aloud protocol; record navigation paths, error recovery, label comprehension, and role/vertical context awareness; note issues like confusing labels, hidden CTAs, dense tables.",
            "status": "pending",
            "testStrategy": "Capture video recordings; debrief after each session; ensure at least one test per main persona and flow.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Analyze Findings, Iterate Designs, and Document",
            "description": "Prioritize issues from test data, update designs, re-test fixes, and create changelog with rationale.",
            "dependencies": [
              2
            ],
            "details": "Theme and prioritize issues by severity/frequency (e.g., critical paths first); refine designs for multi-role clarity; validate no blockers in apply/pay/renew/exit; add changelog component in with before/after and rationale.",
            "status": "pending",
            "testStrategy": "Re-test updated flows with 2-3 quick sessions; get stakeholder sign-off on v1.0 readiness.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on conduct usability review and iterate on critical flows."
      },
      {
        "id": "31",
        "title": "Implement Supabase Auth & Role-Based Session Management in NestJS",
        "description": "Replace all mock OTP, student, and parent authentication with Supabase Auth using JWT, roles, and secure session handling integrated into the NestJS backend.",
        "details": "Tech & setup:\n- Use NestJS v11+ with TypeScript 5+, Node 20 LTS.\n- Use official supabase-js v2 (@supabase/supabase-js) as the primary client in the backend.\n- Store Supabase project URL, anon/service keys, JWT secret, and Twilio/MSG91 credentials in environment variables, injected via NestJS ConfigModule.\n- Use NestJS modules: @nestjs/jwt for custom JWT where required, @nestjs/throttler for rate limiting, @nestjs/passport + passport-jwt for guard integration.\n\nSupabase Auth configuration:\n- Configure Supabase Auth for phone OTP and email/password in the Supabase dashboard.\n- Enable phone auth; configure external SMS provider (Twilio/MSG91) via Edge Functions or Supabase hooks.\n- Define JWT custom claims for role and vertical using Supabase Auth hooks or by writing to the auth.users / public.users mapping and using a JWT enrichment function.\n\nNestJS Auth module design:\n- Create AuthModule with:\n  - AuthController for /api/auth/* endpoints.\n  - AuthService wrapping supabase-js auth methods.\n  - JwtStrategy & JwtAuthGuard reading Supabase-issued JWTs from Authorization: Bearer header.\n  - ThrottlerGuard for OTP endpoints.\n\nEndpoints (core pseudocode):\n- POST /api/auth/otp/send\n  - Validate phone format.\n  - Apply rate limit (max 3 per 5 minutes per phone+IP) using Throttler and custom in-memory/Redis key.\n  - Call supabase.auth.signInWithOtp({ phone }) with appropriate options.\n  - Log event to audit_logs via a service.\n\n- POST /api/auth/otp/verify\n  - Receive phone + OTP.\n  - Call supabase.auth.verifyOtp({ phone, token: otp, type: 'sms' }).\n  - On success, map user to public.users row; ensure role and vertical set.\n  - Return access_token and refresh_token from Supabase; set secure, HTTP-only cookies if using cookie-based auth.\n\n- POST /api/auth/login\n  - For student password login: supabase.auth.signInWithPassword({ email/phone, password }).\n  - On first login, if password not set (metadata.first_login === true), return flag to frontend for password creation.\n\n- POST /api/auth/refresh\n  - Use refresh_token from cookie/body: supabase.auth.refreshSession({ refresh_token }).\n  - Return new access_token/refresh_token.\n\n- POST /api/auth/logout\n  - Invalidate refresh token in client (delete cookie); optionally call supabase.auth.signOut().\n\nStudent & parent flows:\n- Students: maintain mapping between auth.users.id and public.users.id (student role); enforce role: STUDENT and vertical claims in JWT by reading public.users and embedding via a JWT hook function.\n- Parents: phone-based OTP login; store linked student_user_ids in users.metadata or a separate parent_child_links table; ensure JWT contains role: PARENT and parent metadata for lookup.\n\nSecurity enhancements:\n- Device fingerprinting: accept device_id and user-agent from client; store in a device_sessions table keyed by user_id; mark suspicious if new device or geo-IP; add additional verification path.\n- IP allowlisting for admin roles: maintain allowed_ips table; in a global guard, if role in (TRUSTEE, ACCOUNTS) and request.ip not in allowed_ips, deny.\n- MFA for Trustee/Accounts: integrate TOTP (e.g., speakeasy) or SMS-based second factor; store MFA secret in encrypted form; add /api/auth/mfa/verify before issuing full-privilege JWT.\n\nAudit logging:\n- On each auth-related action (OTP send/verify, login, refresh, logout, MFA, failed attempts), insert audit_logs row with entity_type='AUTH', action, actor_id if known, ip and user_agent.\n\nSample guard pseudocode:\n```ts\n@Injectable()\nexport class SupabaseJwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(ctx: ExecutionContext) {\n    const req = ctx.switchToHttp().getRequest();\n    const token = extractBearerToken(req.headers.authorization);\n    // Verify with NestJS JWT using Supabase JWT secret\n    const payload = this.jwtService.verify(token);\n    req.user = payload; // { sub, role, vertical, phone, ... }\n    return true;\n  }\n}\n```\n",
        "testStrategy": "- Unit-test AuthService methods with mocked supabase-js client for:\n  - OTP send / verify, login, refresh, logout success and failure paths.\n- Integration tests using Supertest against NestJS:\n  - OTP send respects rate limiting (4th request within 5 min receives 429).\n  - OTP verify issues JWT with correct role and vertical claims for students and parents.\n  - Student login, first-time password setup, and password reset flows.\n  - Parent login with multiple children correctly populates accessible students.\n- Security tests:\n  - Attempt login for Trustee/Accounts from disallowed IP, expect 403.\n  - Simulate suspicious device fingerprint and verify additional checks.\n  - Verify MFA is required and enforced for privileged roles.\n- Session tests:\n  - Token refresh before and after expiry; ensure expired tokens rejected.\n  - Cross-device login behavior: ability to revoke sessions if required.\n- Verify audit_logs entries created for each auth event and contain correct metadata.",
        "priority": "high",
        "dependencies": [
          "30"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "32",
        "title": "Integrate Supabase Storage for Document Management & Migration Support",
        "description": "Use Supabase Storage buckets with signed URLs and NestJS APIs to handle document uploads, access control, previews, and migration tooling.",
        "details": "Tech & setup:\n- Use supabase-js v2 storage client from backend with service role key for server-side operations.\n- Configure four buckets: applications-documents, student-documents, undertakings, system-generated (in Supabase dashboard or via SQL). Enable RLS or use storage policies in line with auth JWT claims.\n\nNestJS Storage module:\n- Create DocumentsModule with DocumentsController and DocumentsService.\n- Endpoints:\n  - POST /api/documents/upload\n  - GET /api/documents/:id/url\n  - PATCH /api/documents/:id/verify\n  - GET /api/documents\n\nUpload flow pseudocode:\n```ts\n@Post('upload')\n@UseInterceptors(FileInterceptor('file'))\nasync uploadDoc(@UploadedFile() file, @Body() dto: UploadDto, @Req() req) {\n  // Validate file type, size\n  this.validationService.validateFile(file, ['pdf','jpg','jpeg','png'], 10 * 1024 * 1024);\n  // Optional virus scan: send buffer to ClamAV over TCP or to a scanning API\n  await this.virusScanService.scan(file.buffer);\n\n  const bucket = this.getBucketForCategory(dto.category);\n  const storagePath = `${dto.studentUserId}/${dto.applicationId ?? 'general'}/${Date.now()}_${file.originalname}`;\n\n  const { data, error } = await this.supabase.storage\n    .from(bucket)\n    .upload(storagePath, file.buffer, { contentType: file.mimetype, upsert: false });\n\n  if (error) throw new InternalServerErrorException(error.message);\n\n  await this.prismaOrKnex('documents').insert({\n    application_id: dto.applicationId,\n    student_user_id: dto.studentUserId,\n    document_type: dto.documentType,\n    storage_url: data.path,\n    status: 'UPLOADED',\n    uploaded_by: req.user.sub,\n    metadata: { bucket, originalName: file.originalname },\n  });\n}\n```\n\nSigned URL generation:\n- GET /api/documents/:id/url\n  - Verify caller is authorized to access this document via role and vertical rules.\n  - Generate signed URL via `supabase.storage.from(bucket).createSignedUrl(path, 3600)`.\n  - Return URL and expiry timestamp.\n\nRLS/Access policies:\n- Implement storage policies per bucket using JWT role & vertical similar to documents table policies:\n  - Students: read/write only own paths (student_user_id == auth.uid()).\n  - Superintendents: access students in their vertical (via join with users).\n  - Trustees: wide access.\n  - Accounts: restricted to payment receipts in system-generated.\n\nDocument preview & watermarking:\n- For PDFs and images, use a server-side processing library in NestJS workers:\n  - PDFs: pdf-lib or pdfkit for rendering first page to PNG thumbnail and adding watermarks.\n  - Images: sharp for thumbnailing and watermark overlay.\n- Store thumbnails in a separate path (e.g., thumbnails/...) within same bucket.\n\nBulk download & PDF merging:\n- Implement /api/documents/bulk-download with filters (vertical, status, date range).\n- Fetch signed URLs server-side using service role, stream files, and zip them (archiver package) or merge PDFs:\n  - Use pdf-lib to merge multiple PDFs into a single admission packet.\n- Upload the merged packet into system-generated bucket and return signed URL.\n\nMigration script support:\n- Provide a NestJS Command or standalone Node script that:\n  - Reads existing file paths from db.json or filesystem.\n  - Uploads to appropriate bucket/path.\n  - Updates documents.storage_url and metadata accordingly.\n- Implement idempotency by checking if storage_url already points to Supabase path.\n\nLogging & compliance:\n- On each access of signed URL (GET /api/documents/:id/url), insert an audit_logs row with entity_type='DOCUMENT', action='ACCESS_URL', actor_id and role.\n",
        "testStrategy": "- Unit tests:\n  - Validate bucket selection logic by category.\n  - Validate file validation rules for allowed types and size limits.\n- Integration tests with mocked Supabase client:\n  - Successful upload creates storage object and DB record with status=UPLOADED.\n  - Invalid file type/size returns 400.\n  - Signed URL generation returns valid URL and enforces role-based access (students only for own docs, parents for linked children, etc.).\n- Security tests:\n  - Attempt to access another student's document; expect 403.\n  - Verify signed URLs expire after configured TTL and cannot be reused.\n- Migration dry-run tests:\n  - Run script on sample dataset; verify counts of uploaded files and updated DB rows.\n  - Simulate failure mid-way and verify rollback or resumability.\n- Visual tests:\n  - Verify thumbnail generation for PDFs and images visually or via file metadata (dimensions, watermark text exists).\n  - Verify bulk download and merged PDFs open correctly and contain expected pages.",
        "priority": "high",
        "dependencies": [
          "31"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "33",
        "title": "Implement Production PostgreSQL Schema, Triggers, and DB Migrations",
        "description": "Create the normalized Supabase PostgreSQL schema, indexes, and triggers replacing the json-server structure, managed via proper migration tooling.",
        "details": "Tooling & environment:\n- Use Supabase CLI migrations (`supabase migration new ...`) as the single source of truth for schema changes.[3][6]\n- Maintain separate environments (local, staging, prod) using Supabase projects and the CLI env configuration.[7]\n- Store SQL from PRD (users, applications, documents, payments, rooms, room_allocations, leave_requests, audit_logs) in versioned migration files.\n\nSchema implementation steps:\n1) Initial core tables migration:\n- Create migration 001 with all CREATE TABLE statements given in PRD.\n- Ensure `uuid-ossp` extension enabled for uuid_generate_v4().\n- Add NOT NULL / DEFAULT constraints as specified.\n\n2) Indexes migration:\n- Create a separate migration for performance indexes:\n```sql\nCREATE INDEX IF NOT EXISTS idx_applications_tracking ON applications(tracking_number);\nCREATE INDEX IF NOT EXISTS idx_applications_status ON applications(current_status);\nCREATE INDEX IF NOT EXISTS idx_applications_student ON applications(student_user_id);\nCREATE INDEX IF NOT EXISTS idx_documents_application ON documents(application_id);\nCREATE INDEX IF NOT EXISTS idx_payments_student ON payments(student_user_id);\nCREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status);\nCREATE INDEX IF NOT EXISTS idx_room_allocations_student ON room_allocations(student_user_id);\nCREATE INDEX IF NOT EXISTS idx_audit_logs_entity ON audit_logs(entity_type, entity_id);\nCREATE INDEX IF NOT EXISTS idx_audit_logs_created ON audit_logs(created_at DESC);\n```\n\n3) updated_at triggers:\n```sql\nCREATE OR REPLACE FUNCTION set_timestamp()\nRETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER set_users_timestamp\nBEFORE UPDATE ON users\nFOR EACH ROW EXECUTE FUNCTION set_timestamp();\n\nCREATE TRIGGER set_applications_timestamp\nBEFORE UPDATE ON applications\nFOR EACH ROW EXECUTE FUNCTION set_timestamp();\n-- Repeat for tables having updated_at.\n```\n\n4) Business logic triggers:\n- Status transition validation (applications.current_status):\n```sql\nCREATE OR REPLACE FUNCTION validate_application_status()\nRETURNS TRIGGER AS $$\nDECLARE\n  allowed_transitions JSONB := '{\"DRAFT\":[\"SUBMITTED\"],\"SUBMITTED\":[\"UNDER_REVIEW\",\"REJECTED\"],\"UNDER_REVIEW\":[\"APPROVED\",\"REJECTED\"],\"APPROVED\":[\"ACTIVE\"],\"ACTIVE\":[\"CLOSED\"]}'::jsonb;\n  from_status TEXT := OLD.current_status;\n  to_status TEXT := NEW.current_status;\nBEGIN\n  IF from_status = to_status THEN\n    RETURN NEW;\n  END IF;\n  IF NOT (to_status = ANY (SELECT jsonb_array_elements_text(allowed_transitions->from_status))) THEN\n    RAISE EXCEPTION 'Invalid status transition from % to %', from_status, to_status;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER applications_status_guard\nBEFORE UPDATE ON applications\nFOR EACH ROW EXECUTE FUNCTION validate_application_status();\n```\n\n- Room occupied_count management:\n```sql\nCREATE OR REPLACE FUNCTION update_room_occupancy()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    UPDATE rooms\n      SET occupied_count = occupied_count + 1,\n          status = CASE WHEN occupied_count + 1 >= capacity THEN 'OCCUPIED' ELSE status END\n      WHERE id = NEW.room_id;\n  ELSIF TG_OP = 'UPDATE' AND OLD.status != NEW.status THEN\n    -- handle transfers/checkouts\n    IF NEW.status = 'CHECKED_OUT' THEN\n      UPDATE rooms SET occupied_count = occupied_count - 1,\n        status = CASE WHEN occupied_count - 1 = 0 THEN 'AVAILABLE' ELSE status END\n      WHERE id = NEW.room_id;\n    END IF;\n  ELSIF TG_OP = 'DELETE' THEN\n    UPDATE rooms SET occupied_count = GREATEST(0, occupied_count - 1)\n      WHERE id = OLD.room_id;\n  END IF;\n  RETURN COALESCE(NEW, OLD);\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER room_allocations_occupancy\nAFTER INSERT OR UPDATE OR DELETE ON room_allocations\nFOR EACH ROW EXECUTE FUNCTION update_room_occupancy();\n```\n\n5) Audit trigger wiring:\n- Reference the audit logging function from Migration Task 7 (log_audit_entry) and attach AFTER triggers for INSERT/UPDATE/DELETE on key tables: users, applications, documents, payments, rooms, room_allocations, leave_requests.\n\n6) Migration workflow:\n- Use Supabase CLI to apply migrations locally, then staging, then prod following Git-based promotion.[3][5]\n- For large datasets, test index performance using EXPLAIN ANALYZE on typical queries.\n\nConcurrency considerations:\n- Use appropriate FK ON DELETE semantics (as defined) and validate that cascades behave as desired under concurrent operations.\n- For hot tables (applications, payments), test row-level locking behavior.\n",
        "testStrategy": "- Automated migration tests:\n  - Apply migrations in a fresh Supabase project (CI) and ensure no errors.\n- Schema validation tests:\n  - Insert records with invalid FKs and expect failure.\n  - Delete parent rows and verify cascading behavior (e.g., deleting applications removes documents if ON DELETE CASCADE).\n  - Verify CHECK constraints by attempting invalid enum values.\n- Performance tests:\n  - Seed 100k+ sample rows for applications, documents, payments, room_allocations.\n  - Run EXPLAIN ANALYZE on typical queries (by tracking_number, by student_user_id, by status) and confirm indexes are used and latency stays within targets (<50ms DB time in staging).\n- Trigger tests:\n  - Verify updated_at changes on UPDATE but not on INSERT (unless default NOW()).\n  - Simulate status transitions and confirm invalid transitions raise exceptions.\n  - Allocate and checkout rooms, verifying occupied_count and status updated correctly.\n- Regression tests:\n  - Ensure Phase 1 UI-required data fields map correctly to new schema via API tests in Task 35.",
        "priority": "high",
        "dependencies": [
          "31",
          "32"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "34",
        "title": "Define and Enforce Row Level Security (RLS) Policies Across All Tables",
        "description": "Implement RLS with default-deny semantics using Supabase’s Postgres RLS capabilities, enforcing role- and vertical-based access as per JWT claims.",
        "details": "RLS setup:\n- Enable RLS on all business tables: users, applications, documents, payments, rooms, room_allocations, leave_requests, audit_logs, consent_logs, etc.\n```sql\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\nALTER TABLE applications ENABLE ROW LEVEL SECURITY;\nALTER TABLE documents ENABLE ROW LEVEL SECURITY;\nALTER TABLE payments ENABLE ROW LEVEL SECURITY;\nALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;\n-- Repeat for others.\n```\n\nPolicy implementation based on PRD:\n- Ensure JWT from Supabase includes role, vertical, phone, and other identity signals.\n\nUsers table policies (example):\n```sql\nCREATE POLICY student_own_record ON users\n  FOR SELECT USING (auth.uid() = id AND auth.jwt()->>'role' = 'STUDENT');\n\nCREATE POLICY student_update_own ON users\n  FOR UPDATE USING (auth.uid() = id AND auth.jwt()->>'role' = 'STUDENT');\n\nCREATE POLICY superintendent_vertical_users ON users\n  FOR SELECT USING (\n    auth.jwt()->>'role' = 'SUPERINTENDENT' AND\n    vertical = auth.jwt()->>'vertical'\n  );\n\nCREATE POLICY trustee_all_users ON users\n  FOR SELECT USING (auth.jwt()->>'role' = 'TRUSTEE');\n```\n\nApplications table policies per PRD (applicant_mobile, student, superintendent, trustee):\n- Add applicant_own_application (FOR ALL USING applicant_mobile = auth.jwt()->>'phone').\n- Student_own_application, superintendent_vertical_apps, superintendent_update_apps, trustee_all_apps, as given.\n\nDocuments table policies:\n- Implement student_own_documents, student_upload_documents, superintendent_vertical_docs, trustee_all_docs from PRD.\n- Add parent read-only policy based on metadata link:\n```sql\nCREATE POLICY parent_child_documents ON documents\n  FOR SELECT USING (\n    auth.jwt()->>'role' = 'PARENT' AND\n    EXISTS (\n      SELECT 1 FROM users parent\n      JOIN LATERAL jsonb_array_elements_text(parent.metadata->'children_ids') AS child_id ON TRUE\n      WHERE parent.id = auth.uid()::uuid\n        AND child_id::uuid = documents.student_user_id\n    )\n  );\n```\n\nPayments table policies:\n- student_own_payments, accounts_all_payments, superintendent_vertical_payments (with EXISTS join to users) as in PRD.\n\nAudit logs policies:\n```sql\nCREATE POLICY all_can_insert_audit ON audit_logs\n  FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);\n\nCREATE POLICY admin_view_audit ON audit_logs\n  FOR SELECT USING (\n    auth.jwt()->>'role' IN ('TRUSTEE', 'ACCOUNTS', 'SUPERINTENDENT')\n  );\n```\n\nDefault deny:\n- Ensure no permissive built-in policies (e.g., authenticated = true) on public schema; drop any auto-generated public policies.\n\nPerformance and maintenance:\n- Use SECURITY DEFINER stable helper functions for repeated logic (e.g., checking vertical membership) to keep policies maintainable.\n- Periodically review policies using `pg_policies` view.\n",
        "testStrategy": "- Policy unit tests via SQL:\n  - Use Supabase JWT debugging (or psql with `set local role`-like constructs) to simulate auth.jwt for each role and vertical.\n  - For each table, attempt SELECT/INSERT/UPDATE/DELETE with role-specific JWTs and confirm allowed/denied as expected.\n- Automated integration tests:\n  - From NestJS (using service role only in backend, but passing access token to PostgREST or supabase-js) craft calls impersonating each role.\n  - Validate that a Boys superintendent cannot see Girls data; same for Dharamshala.\n  - Verify students cannot access other students' records or docs.\n  - Verify parents see only their children’s records.\n- Performance tests:\n  - Benchmark key queries with RLS enabled vs disabled on staging; confirm overhead <10ms/query for typical workloads.\n- Security tests:\n  - Pen-test style attempts at SQL injection or RLS bypass, including using crafted JWTs with invalid roles; ensure Supabase verifies signatures so only trusted JWTs are accepted.\n  - Ensure audit_logs rows cannot be updated/deleted by clients (no UPDATE/DELETE policies).",
        "priority": "high",
        "dependencies": [
          "33",
          "31"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "35",
        "title": "Migrate json-server Calls to NestJS API with Supabase Integration",
        "description": "Replace all frontend usage of json-server with a production NestJS API layer backed by Supabase for authentication, applications, students, documents, payments, rooms, and leaves.",
        "details": "Backend NestJS API:\n- Structure modules matching domains: AuthModule, ApplicationsModule, StudentsModule, DocumentsModule, PaymentsModule, RoomsModule, LeavesModule.\n- Use class-validator + class-transformer for DTO validation and OpenAPI via @nestjs/swagger.\n- Implement global exception filter to standardize error responses and a logging interceptor (or use pino-http) for request logs.\n- Add @nestjs/throttler-based rate limiting (100 req/min per IP), excluding some internal webhooks.\n\nExample DTO & controller snippet (Applications):\n```ts\nexport class CreateApplicationDto {\n  @IsEnum(['NEW','RENEWAL'])\n  type: string;\n\n  @IsEnum(['BOYS','GIRLS','DHARAMSHALA'])\n  vertical: string;\n\n  @IsPhoneNumber('IN')\n  applicantMobile: string;\n\n  @IsObject()\n  data: Record<string, any>;\n}\n\n@Post()\n@UseGuards(SupabaseJwtAuthGuard)\nasync createApp(@Body() dto: CreateApplicationDto, @Req() req) {\n  const trackingNumber = this.appService.generateTrackingNumber();\n  const { data, error } = await this.supabase\n    .from('applications')\n    .insert({\n      tracking_number: trackingNumber,\n      type: dto.type,\n      vertical: dto.vertical,\n      applicant_mobile: dto.applicantMobile,\n      student_user_id: req.user.sub ?? null,\n      data: dto.data,\n    })\n    .select()\n    .single();\n  if (error) throw new BadRequestException(error.message);\n  return data;\n}\n```\n\nOther endpoints:\n- Auth endpoints from Task 31.\n- Student dashboard/profile fetching aggregated data from multiple tables.\n- Documents endpoints from Task 32.\n- Payments endpoints integrating with Supabase payments table and Razorpay orchestration from Task 36.\n- Rooms endpoints using rooms and room_allocations with appropriate RLS and business rules.\n- Leave endpoints CRUD + approve paths restricted to superintendent role.\n\nFrontend migration:\n- Create a typed API client layer (e.g., using Axios or fetch wrapper) at /src/api/index.ts.\n- Replace all hard-coded json-server URLs (localhost:3001/...) with /api/* endpoints via environment configuration.\n- Implement standardized error handling: intercept 401/403, redirect to login or show permission errors; show toast/snackbar messages for 4xx/5xx.\n- Implement retry with exponential backoff for idempotent GETs (e.g., applications list) but avoid retrying non-idempotent POST/PUT by default.\n- Ensure loading and empty state management for each screen when calling new endpoints.\n\nLogging & monitoring:\n- Enable NestJS Swagger UI at /api/docs for development and staging.\n- Log structured entries (method, path, userId, role, latency, status) for all requests.\n",
        "testStrategy": "- Backend integration tests:\n  - Use Supertest + Jest to hit each endpoint with mocked/minted JWTs for different roles, verifying RBAC behavior aligns with RLS and business rules.\n  - Validate DTO constraints: invalid payloads return 400 with helpful messages.\n  - Check error paths for DB constraint violations, missing resources (404), and unauthorized access (401/403).\n- Contract tests:\n  - Generate OpenAPI spec and ensure types in frontend API client match the spec (can use openapi-typescript generation for TS types).\n- Frontend tests:\n  - Smoke tests for all Phase 1 flows against NestJS backend (Cypress/Playwright): applications, login, document upload, room allocation, leave requests, payments happy paths.\n  - Validate that no calls are made to json-server URLs (grep or network inspection in tests).\n- Load tests:\n  - Use k6 or Artillery to simulate 100+ concurrent users across critical endpoints (auth, applications, payments) and ensure p95 <500ms and error rate <0.1%.",
        "priority": "high",
        "dependencies": [
          "31",
          "32",
          "33",
          "34"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "36",
        "title": "Implement Production Payment Gateway Integration with Razorpay & Supabase",
        "description": "Replace mock payment logic with real Razorpay (and fallback PhonePe) integration, wired to the payments table, webhooks, refunds, and reconciliation processes.",
        "details": "Gateway selection & setup:\n- Primary: Razorpay (Node SDK: razorpay v2+). Configure API key/secret via env vars.\n- Fallback: prepare abstraction to allow alternate provider (e.g., PhonePe) but keep initial implementation focused on Razorpay.\n- Ensure backend never handles raw card data directly; use Razorpay checkout/payment flows (PCI-DSS alignment).\n\nNestJS PaymentsModule:\n- Services:\n  - PaymentsService handling supabase DB operations and Razorpay SDK calls.\n- Endpoints:\n  - POST /api/payments/initiate\n  - GET /api/payments/:id/status\n  - POST /api/payments/webhook\n  - POST /api/payments/:id/refund\n\nInitiate payment (pseudocode):\n```ts\n@Post('initiate')\n@UseGuards(SupabaseJwtAuthGuard)\nasync initiate(@Body() dto: InitiatePaymentDto, @Req() req) {\n  const application = await this.getAndAuthorizeApplication(dto.applicationId, req.user);\n  const order = await this.razorpay.orders.create({\n    amount: dto.amount * 100,\n    currency: 'INR',\n    receipt: `receipt_${dto.applicationId}`,\n    notes: { applicationId: dto.applicationId, vertical: application.vertical, studentId: application.student_user_id }\n  });\n\n  const { data, error } = await this.supabase\n    .from('payments')\n    .insert({\n      application_id: dto.applicationId,\n      student_user_id: application.student_user_id,\n      amount: dto.amount,\n      fee_breakdown: dto.feeBreakdown,\n      payment_method: 'UPI',\n      transaction_id: order.id,\n      status: 'PENDING',\n    })\n    .select()\n    .single();\n\n  return { orderId: order.id, paymentUrl: this.buildPaymentUrl(order), qrCodeUrl: order.qr, expiresAt: order.expire_by };\n}\n```\n\nVerification & webhook:\n- Verify payment signatures on client callback and again server-side if needed using crypto.createHmac('sha256', razorpaySecret).\n- Webhook endpoint:\n  - Accept raw body (disable body parsing or use raw middleware for signature verification).\n  - Verify x-razorpay-signature header.\n  - On payment.captured: update payments row to SUCCESS, set paid_at NOW(), store gateway_response.\n  - On payment.failed: set status=FAILED, log failure.\n  - On refund.created: set status=REFUNDED as appropriate.\n\nRefunds:\n```ts\n@Post(':id/refund')\n@UseGuards(RoleGuard('ACCOUNTS','TRUSTEE'))\nasync refund(@Param('id') id: string, @Body() dto: RefundDto, @Req() req) {\n  const payment = await this.getPayment(id);\n  const amountPaise = (dto.amount ?? payment.amount) * 100;\n  const refund = await this.razorpay.payments.refund(payment.transaction_id, { amount: amountPaise, notes: { reason: dto.reason, processedBy: req.user.sub } });\n  await this.supabase.from('payments').update({ status: 'REFUNDED', gateway_response: refund }).eq('id', id);\n  return { refundId: refund.id, status: refund.status, processedAt: new Date().toISOString() };\n}\n```\n\nReceipt generation & storage:\n- After successful payment, generate a PDF receipt using pdfkit or pdfmake:\n  - Include institute letterhead, transaction details, breakdown, date/time.\n- Upload PDF to Supabase Storage (system-generated bucket) and store reference in payments.fee_breakdown or a dedicated receipts table.\n- Send receipt by email/SMS via transactional provider (e.g., SendGrid, AWS SES + SMS via Twilio/MSG91), using asynchronous job queue.\n\nReconciliation job:\n- Create a scheduled job (e.g., via NestJS @Cron or external scheduler hitting an admin endpoint):\n  - Daily fetch Razorpay settlements for the previous day (using Razorpay APIs).\n  - Compare totals and transaction IDs against payments table.\n  - Mark reconciliation status in a reconciliation_logs table; flag discrepancies.\n\nIdempotency & safety:\n- Use idempotency keys for initiate calls from frontend (e.g., hash of applicationId+amount) to avoid duplicate payments.\n- Ensure webhooks are idempotent (check current status before applying updates).\n",
        "testStrategy": "- Sandbox testing:\n  - Use Razorpay Test mode to simulate successful, failed, and refunded payments end-to-end.\n- Automated tests:\n  - Unit-test PaymentsService for order creation, webhook handling, refunds (with mocked Razorpay SDK and supabase client).\n  - Verify HMAC signature calculation; tampered payload should be rejected.\n  - Ensure double-processing guard on webhooks (same event delivers twice -> no extra state change).\n- Integration tests:\n  - From frontend through backend to Razorpay sandbox: initiate payment, simulate callback/webhook, then check DB payments row updated, receipt stored, and documents accessible.\n- Reconciliation tests:\n  - Mock Razorpay settlements API to return mismatched amounts and verify discrepancies are logged for Accounts team.\n- Performance & reliability:\n  - Simulate webhook bursts and confirm the endpoint remains performant and consistent.\n  - Confirm that invalid or unauthenticated webhook calls are rejected with 400/401 and logged.",
        "priority": "high",
        "dependencies": [
          "33",
          "35"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "37",
        "title": "Implement Audit Logging, Consent, Encryption, and Data Retention for Compliance",
        "description": "Build immutable audit logs, DPDP-compliant consent tracking, PII encryption, data archival, and reporting capabilities.",
        "details": "Audit logging:\n- Implement the log_audit_entry() function from PRD and attach to core tables (applications, documents, payments, rooms, room_allocations, leave_requests, users as appropriate).\n- Ensure app.current_user_id and app.current_user_role are set from NestJS per-request using `SET LOCAL` statements via a DB wrapper service before write operations.\n\nConsent management:\n- Create consent_logs table per PRD.\n- Add service methods:\n  - recordConsent(userId, type, version, text, ip, deviceInfo, expiresAt?)\n  - revokeConsent(consentId, revokedAt)\n  - checkConsentRenewal(userId, type) using six-month logic in PRD.\n- Hook into login or critical flows requiring up-to-date consent; block operation until consent captured.\n\nPII encryption:\n- Identify sensitive fields (e.g., phone, address, guardian contacts) that require encryption at application level.\n- Use Node crypto with AES-256-GCM as in PRD snippet; store key in secure secret manager (e.g., environment variable loaded from Vault/SSM).\n- Create helper:\n```ts\nclass CryptoService {\n  encrypt(text: string): string { /* PRD snippet logic */ }\n  decrypt(payload: string): string { /* reverse with auth tag */ }\n}\n```\n- Apply encryption transparently in repositories/services before persisting and after reading PII.\n\nData retention & archival:\n- Create applications_archive table with reduced PII footprint (no phone, only high-level stats).\n- Implement weekly Cron job via @nestjs/schedule (@Cron('0 0 * * 0')) as in PRD.\n  - Find REJECTED applications older than 1 year.\n  - Strip PII via a method stripPII() and insert into archive.\n  - Delete originals, ensuring audit_log entries are generated.\n\nAudit reports:\n- Implement scheduled monthly job generating audit reports:\n  - Aggregate counts: total applications, payments, document verifications, consent renewals, failed logins, unusual access.\n  - Generate PDF report (pdfkit) and store in Supabase Storage (system-generated bucket) tagged by month.\n  - Notify Trustees via email with link to report.\n\nDPDP-specific measures:\n- Ensure access to PII is minimized and logged (via audit_logs and RLS).\n- Provide APIs for data subject rights (export and delete requests) if required later; at minimum, log such operations clearly when done manually.\n",
        "testStrategy": "- Audit tests:\n  - Perform CRUD actions on key tables and verify audit_logs entries appear with correct entity_type, entity_id, action, actor_id, role, and changes.old/new.\n  - Attempt to UPDATE/DELETE audit_logs directly as authenticated user; confirm RLS prevents modifications.\n- Consent tests:\n  - Record consent and check retrieval; simulate user without recent consent and ensure system prompts/blocks flows until renewed.\n- Encryption tests:\n  - Round-trip testing for CryptoService: encrypt+decrypt returns original string.\n  - Verify encrypted DB values are non-plaintext and unique IVs lead to different ciphertext for same input.\n- Archival tests:\n  - Seed applications with various updated_at timestamps and statuses, run archiveOldData in test mode.\n  - Confirm only REJECTED >1-year-old records are archived and deleted, with archived data PII stripped.\n- Report generation tests:\n  - Run monthly report job against sample data; inspect generated PDF for correctness.\n  - Ensure report metadata written (e.g., to audit_logs or a reports table) for traceability.",
        "priority": "medium",
        "dependencies": [
          "33",
          "34",
          "31"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "38",
        "title": "Data Migration from db.json to Supabase and Production Cutover",
        "description": "Migrate prototype data from db.json into Supabase, verify integrity, and execute a controlled production cutover with rollback capability.",
        "details": "Migration tooling:\n- Implement migration scripts as Node/NestJS CLI commands (e.g., using NestJS CommandRunner or standalone TS script compiled to Node) that:\n  - Load db.json.\n  - Validate data using the ValidationReport structure from PRD.\n  - Insert into Supabase via supabase-js with service role key.\n\nMigration process implementation:\n- Validation step:\n  - Implement validateData(dbJson) per PRD with additional checks for referential integrity (user ids referenced in applications, etc.).\n  - Fail fast on invalidRecords > 0 and output JSON report.\n\n- Migration step:\n  - Implement migrateData() as in PRD, extended to cover all tables (users, applications, documents, payments, rooms, room_allocations, leave_requests).\n  - Use batched inserts (e.g., chunk size 500) for performance.\n  - For document migration, integrate with Supabase Storage (Task 32), reading legacy file paths, uploading, and writing storage_url.\n  - Use database functions begin_migration, commit_migration, rollback_migration to manage transactional state (or emulate transaction markers if cross-service with Storage).\n\n- Verification step:\n  - Implement verifyMigration(dbJson) from PRD, expanding to all tables and comparing expected vs actual counts.\n  - Optionally spot-check hashes: compute hash of key fields for first N records and compare.\n\nCutover orchestration:\n- Implement scripts / runbooks for:\n  - Pre-cutover (T-24h): freeze writes to db.json, backup, run test migration on staging, run smoke tests.\n  - Cutover (T-0): enable maintenance mode (e.g., env flag consumed by frontend/backend), run migration on prod Supabase, run verification script, switch frontend to NestJS API URLs, deploy, remove maintenance mode.\n  - Post-cutover (T+24h): continuous monitoring, error tracking (Sentry/Elastic), DB performance dashboards, payment gateway monitoring.\n\nRollback procedure:\n- Implement a simple switch to redirect frontend back to db.json-backed environment (e.g., environment toggle and redeploy) as in PRD.\n- Document manual steps clearly in a runbook.\n- Ensure db.json backup retained for at least 7 days and versioned.\n\nMonitoring & observability:\n- Configure Supabase monitoring dashboards (query performance, errors, CPU, storage) and app logs.\n- Ensure alerts for high error rates, slow queries, or high DB CPU during and after migration.\n",
        "testStrategy": "- Dry-run tests:\n  - Run full migration on a staging Supabase project with synthetic data (100+ records per table) and ensure no script failures.\n  - Measure total migration time and resource usage.\n- Data integrity tests:\n  - After migration on staging, run verifyMigration and ensure all expected vs actual counts match for users, applications, documents, payments, rooms, allocations, leaves.\n  - Spot-check a subset of records (manual + automated) to confirm field-level correctness and document access.\n- Cutover rehearsal:\n  - Perform a full dress rehearsal in staging following the cutover runbook, including simulated rollback.\n  - Time each step to estimate downtime; aim for <1 hour maintenance window.\n- Post-migration regression tests:\n  - Execute full E2E test suite (Cypress/Playwright) against Supabase-backed production-like environment.\n  - Confirm all critical user journeys behave identically or better compared to pre-migration.\n- Rollback tests:\n  - Simulate a failure after migration in staging and practice rollback steps, ensuring frontend can be pointed back to db.json without data corruption.",
        "priority": "medium",
        "dependencies": [
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "39",
        "title": "Set up db.json prototyping environment with json-server and concurrently",
        "description": "Install json-server and concurrently packages, create a realistic db.json with mock data for all Phase 1 domains, configure concurrent dev scripts, and verify API endpoints for frontend prototyping.",
        "details": "1. Install development dependencies: `npm install --save-dev json-server concurrently` (local installation preferred over global for project reproducibility)[1][2][5].\n2. Create `db.json` in project root with nested structure matching Phase 1 domains: applications (with status, vertical, payments), students (profile, room, leaves), documents, payments, rooms (occupancy, allocations), leaves (status, approver notes), users (for auth prototyping), notifications. Populate with 20-50 realistic sample records per resource, including edge cases (overdue payments, pending leaves, multi-status applications)[1][3]. Use realistic Indian student names, hostel verticals (Boys/Girls/Dharamshala), fee structures (hostel+security deposit), and dates.\n3. Configure `package.json` scripts for concurrent execution: `\"dev\": \"concurrently \\\"npm run json-server\\\" \\\"npm run frontend\\\"`, `\"json-server\": \"json-server --watch db.json --port 4000 --delay 500 --host 0.0.0.0 --cors\", `\"frontend\": \"vite\"` (adjust for actual frontend runner). The `--delay 500` simulates realistic network latency; `--cors` enables frontend requests; port 4000 avoids conflicts[5][7].\n4. Optional: Add `public` folder for static assets if needed (`--static ./public`), and middleware script for basic auth simulation (e.g., lowdb filters for user roles) if prototyping requires it[1].\n5. Document API base URL (`http://localhost:4000`) and key endpoints in README.md with curl examples for GET/POST/PUT/DELETE on each resource.\n6. Ensure db.json is gitignored or use .gitignore patterns for sensitive mock data, but commit a minimal example.db.json.",
        "testStrategy": "1. Run `npm run dev` and verify both json-server (port 4000) and frontend start without port conflicts, checking console logs for 'Resources http://localhost:4000' message[1][2].\n2. Test core endpoints with curl or browser/Postman: `curl http://localhost:4000/applications` (expect array), `curl -X POST -H \"Content-Type: application/json\" -d '{\"name\":\"Test\",\"status\":\"new\"}' http://localhost:4000/applications` (creates record, auto ID), verify GET returns new item, `curl -X PUT -d '{\"status\":\"approved\"}' http://localhost:4000/applications/1` (updates), `curl -X DELETE http://localhost:4000/applications/1` (deletes)[1][7].\n3. Test all resources have data: GET /students, /rooms, /leaves, /payments, /documents, /notifications return non-empty arrays with realistic mock data.\n4. Verify frontend can fetch data: open app, check Network tab for successful 200 responses to localhost:4000 endpoints, no CORS errors.\n5. Test file watching: edit db.json (add record), refresh endpoint to confirm live reload without restart[1].\n6. Simulate latency: time a GET request, expect ~500ms delay. Test concurrent mode stability over 5 mins.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-21T15:24:27.995Z"
      },
      {
        "id": "40",
        "title": "Complete API Route Implementation for Hostel Management System",
        "description": "Implement all missing API routes required for the hostel management application to support authentication, application management, payments, room allocation, leave management, renewals, and dashboard functionality. This includes creating Next.js API routes that integrate with db.json for the prototyping phase.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "7"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan codebase and document existing Next.js API routes and db.json schema",
            "description": "Use repository tools to inventory all existing API route handlers and understand the current db.json structure used for prototyping data.",
            "dependencies": [],
            "details": "1) Use Glob over /workspace/repo to list API route files (e.g., app/api/**/*, pages/api/**/*). 2) Open each discovered route with Read to understand routing patterns (file-based structure, HTTP method handlers, middleware usage). 3) Locate db.json (or equivalent mock DB file) via Glob and inspect its structure (collections, key names, primary identifiers) with Read. 4) Note conventions for error handling, response shapes, status codes, and any helper utilities already used for reading/writing db.json. 5) Produce a brief internal summary (in comments or a doc) of existing endpoints and data model entities relevant to authentication, applications, payments, rooms, leaves, renewals, and dashboard metrics.",
            "status": "done",
            "testStrategy": "Confirm inventory by cross-checking Glob results against Next.js routing conventions and running the dev server to ensure no missing or misnamed API route files.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T19:23:56.580Z"
          },
          {
            "id": 2,
            "title": "Design and align API contract for all required hostel management modules",
            "description": "Define or reconcile the request/response contracts for authentication, applications, payments, room allocation, leaves, renewals, and dashboard based on existing frontend usage and db.json structures.",
            "dependencies": [
              1
            ],
            "details": "1) Use Grep to search in the codebase (components, hooks, services) for fetch/axios calls referencing /api or similar to identify expected endpoints and payload shapes. 2) Map each functional area (auth, admission application, payments, room allocation, leave, renewal, dashboard) to specific HTTP endpoints (paths, methods) and identify which are already implemented vs missing. 3) Ensure the proposed contracts match the db.json entity structure discovered in subtask 1, adjusting naming or nesting only where non-breaking. 4) Capture the API contract in a single source of truth (e.g., TypeScript types or a dedicated constants file) that can be imported by route handlers and potentially the frontend. 5) Validate that pagination, filtering, and status fields required by the UI are covered, especially for dashboard and list views.",
            "status": "done",
            "testStrategy": "Run TypeScript type-checking or linting on the API contract definitions and verify at least one existing frontend call type-checks correctly against the new shared types.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T19:27:15.105Z"
          },
          {
            "id": 3,
            "title": "Implement or complete authentication-related Next.js API routes using db.json",
            "description": "Create or finish API routes supporting applicant and resident authentication (login, OTP verification, session/account lookup) wired to db.json for prototyping.",
            "dependencies": [
              2
            ],
            "details": "1) From the contract in subtask 2, implement missing auth-related routes (e.g., /api/auth/request-otp, /api/auth/verify-otp, /api/auth/session or similar) following existing handler patterns found in subtask 1. 2) Add helper functions or reuse existing utilities to read/write user and OTP records in db.json, ensuring atomic updates where possible. 3) Respect any DPDP/consent flags if modeled in db.json by setting or checking consent fields during the first contact flow. 4) Implement consistent error responses (status codes and JSON shape) compatible with the existing OTP and registration UI (Task 5). 5) Ensure all auth routes are compatible with the current multi-step application wizard entry point (Task 10), returning the identifiers the wizard expects (e.g., applicantId, vertical, or token).",
            "status": "done",
            "testStrategy": "Use existing OTP and login UI screens to manually exercise the full flow against the new routes, verifying both success and failure scenarios without modifying the frontend code.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T19:31:07.533Z"
          },
          {
            "id": 4,
            "title": "Implement core CRUD API routes for applications, payments, room allocation, leaves, and renewals",
            "description": "Create or complete all remaining API endpoints required for managing admission applications, payment records, room allocation, leave requests, and renewal cycles using db.json persistence.",
            "dependencies": [
              2,
              3
            ],
            "details": "1) For each module (applications, payments, rooms, leaves, renewals), implement REST-style routes under /api/* following the naming and file-structure patterns identified earlier (e.g., collection route for list/create and dynamic route for get/update). 2) Ensure handlers correctly read and mutate the appropriate collections in db.json, including relational links (e.g., applicationId on payments, studentId on room allocations). 3) Implement basic server-side validation corresponding to the multi-step admission wizard fields and other UI requirements, returning validation errors in a consistent JSON structure. 4) Support status transitions (e.g., application submitted/approved/rejected, payment pending/confirmed, leave requested/approved/rejected, renewal requested/active/expired) and write any approval history entries if the schema supports it. 5) Keep business logic minimal and prototyping-focused while still reflecting realistic flows expected by the UI, avoiding breaking existing screens that may already assume partial responses or field names.",
            "status": "done",
            "testStrategy": "Call each new endpoint with representative payloads using a tool like curl or an HTTP client and verify data is persisted and retrievable from db.json; then run the frontend flows (application, payment, leave, renewal) to confirm end-to-end behavior without console errors.",
            "parentId": "undefined",
            "updatedAt": "2025-12-28T20:02:13.501Z"
          },
          {
            "id": 5,
            "title": "Implement dashboard and audit-support API routes and perform integration testing",
            "description": "Add any missing dashboard aggregation and audit/log-support endpoints, then run full integration testing across all modules using the new API routes.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "1) Implement dashboard-related routes that aggregate data from db.json (e.g., counts of applications by status, occupancy by vertical, payment summaries) following existing response patterns for cards and charts. 2) Where Task 21 requires audit logs (communication, approvals, consents), add lightweight endpoints and db.json collections to record and fetch these logs, reusing shared utilities and status enums used in other modules. 3) Verify that all existing dashboard and admin views compile and render correctly with the new endpoints, adjusting only API route implementations (not frontend) to match expected contracts. 4) Execute a full end-to-end walkthrough: landing, vertical selection, registration/OTP, application wizard, room allocation simulation, payment mock, leave and renewal flows, and relevant dashboard screens. 5) Fix any contract mismatches or missing fields discovered during integration, keeping changes localized to API handlers and db.json structure while preserving established conventions.",
            "status": "done",
            "testStrategy": "Perform manual end-to-end testing of the full hostel management prototype in a dev environment, logging all API calls (e.g., via browser devtools or middleware) to ensure every frontend request has a corresponding implemented route returning expected data without 4xx/5xx errors.",
            "parentId": "undefined",
            "updatedAt": "2025-12-29T08:40:55.210Z"
          }
        ],
        "updatedAt": "2025-12-29T08:40:55.210Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-29T09:32:04.820Z",
      "taskCount": 40,
      "completedCount": 16,
      "tags": [
        "master"
      ]
    }
  }
}