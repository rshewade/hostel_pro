{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Define design system foundation (colors, typography, spacing)",
        "description": "Create the core Figma design system foundations aligned with hostel branding and accessibility guidelines.",
        "details": "• Technology: Figma latest, using Styles and Variables for color, typography, spacing, and radii.\n• Import or recreate the official hostel logo and extract a **blue + brownish-yellow** primary palette; define neutral grayscale for backgrounds and borders.\n• Set light **white & blue** interface theme tokens (backgrounds, surfaces, text, borders, focus states) using Figma Color Styles and global/local variables.\n• Establish typography scale with high readability (e.g., Inter, Roboto, or system-safe Sans) and map to heading, subheading, body, caption, and button styles.\n• Define 4–8px-based spacing scale (4, 8, 12, 16, 24, 32, 40, 64) and border radius tokens (0, 4, 8) with institutional, non-playful look.\n• Include elevation tokens (shadows) for modals, dropdowns, and sticky elements but keep them subtle to maintain a clean institutional feel.\n• Ensure minimum contrast ratios target WCAG AA (4.5:1 for body text, 3:1 for large text) using Figma contrast check plugins.\n• Create design foundations that can be exported or mirrored into React/Vue component libraries (name tokens with dev-friendly naming like `color.bg.surface`, `font.size.sm`).",
        "testStrategy": "• Verify all text/background color combinations meet WCAG AA using a contrast checker plugin.\n• Check that all text styles and color styles are reused in sample frames (no local ad-hoc styles).\n• Ask dev lead to confirm naming is easily mappable to CSS variables or design tokens.\n• Test on both desktop and mobile frames to ensure typography and spacing scales look balanced.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Brand discovery and logo import",
            "description": "Research hostel branding, import or recreate the official logo, and extract the primary blue + brownish-yellow palette in Figma.",
            "dependencies": [],
            "details": "Use Figma to import logo SVG/PNG; extract 5-7 primary colors from logo using eyedropper; create initial color variables under 'brand/primary'; document palette source and rationale in a dedicated frame.",
            "status": "pending",
            "testStrategy": "Verify logo matches official assets (pixel-perfect comparison); check palette extraction accuracy against logo; ensure colors are stored as global variables for reuse; review with brand stakeholder for approval."
          },
          {
            "id": 2,
            "title": "Color system and tokens with WCAG contrast validation",
            "description": "Define light white & blue interface theme tokens (backgrounds, surfaces, text, borders, focus) and neutral grayscale; validate all combinations meet WCAG AA using Figma plugins.",
            "dependencies": [
              1
            ],
            "details": "Create primitive color variables (e.g., blue/100-900, gray/100-900) and semantic tokens (color/bg/surface, color/text/primary); set focus states with 3:1+ contrast; use Figma's Stark or Contrast plugins for checks.",
            "status": "pending",
            "testStrategy": "Run contrast checker on all text/background pairs (target 4.5:1 body, 3:1 large); test theme modes (light only); confirm no local colors used in sample frames; export tokens to verify JSON structure."
          },
          {
            "id": 3,
            "title": "Typography scale, text styles, and type tokens",
            "description": "Establish typography scale using Inter/Roboto/system sans-serif; create text styles for heading, subheading, body, caption, button with high readability.",
            "dependencies": [
              2
            ],
            "details": "Define font variables (font/family/base, font/size/h1-600px down to caption-12px); map to Figma text styles; ensure line-height 1.4-1.6x; pair with color tokens for contrast.",
            "status": "pending",
            "testStrategy": "Apply styles to sample paragraphs/headings; check readability at small sizes; validate contrast with color tokens; test variable swaps for consistency across frames."
          },
          {
            "id": 4,
            "title": "Spacing, radii, elevation, and foundational tokens",
            "description": "Define 4–8px spacing scale (4,8,12,16,24,32,40,64), border radii (0,4,8), and subtle elevation shadows for institutional look using Figma variables.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create number variables for spacing/radius; effect styles for shadows (e.g., elevation/1-3 with low opacity); apply to sample frames for modals/dropdowns; keep non-playful, clean aesthetic.",
            "status": "pending",
            "testStrategy": "Resize frames to confirm spacing consistency via Auto Layout; check shadow subtlety on white/blue backgrounds; validate token reuse in prototypes; measure pixel-perfect alignment."
          },
          {
            "id": 5,
            "title": "Dev-ready token naming, documentation, and sample frames",
            "description": "Apply dev-friendly naming (color.bg.surface, font.size.sm); document all tokens and create sample implementation frames for React/Vue export.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use hierarchical naming in variables (primitive/semantic); build documentation page with frames showing tokens in context; create exportable sample UI (button, card) using only tokens/styles.",
            "status": "pending",
            "testStrategy": "Review naming with dev lead for CSS mapping; check 100% token reuse (no overrides); prototype samples for responsiveness; validate Figma export to tokens JSON; stakeholder sign-off on docs."
          }
        ]
      },
      {
        "id": 2,
        "title": "Define reusable base UI components library",
        "description": "Design atomic and composite UI components (buttons, inputs, tables, badges, modals) as a Figma component library.",
        "details": "• Technology: Figma components, variants, Auto Layout 5, variables for states.\n• Create atomic components: buttons (primary, secondary, ghost, destructive), text fields, textareas, dropdowns, date/time pickers, radio/checkbox, toggles, chips, tags.\n• Create data components: tables with sortable headers, pagination, filter chips; cards; lists; tabs; accordions; steppers (for multi-step forms); status badges (Paid, Pending, Failed, Overdue, Approved, Rejected, Under Review, New, Verified, etc.).\n• Include UI patterns: confirmation modals, side panels, toast notifications, banners (e.g., DPDP consent banners), empty states, error states.\n• Add variants for sizes (desktop, mobile), states (default, hover, focus, disabled, error, success), and icons where necessary.\n• Design print-optimized containers (A4 width grids, simplified color, high contrast, printer-friendly) for letters, receipts, undertakings.\n• Use Auto Layout and constraints so components are responsive and easily dropped into React/Vue layouts.\n• Document usage guidance in a dedicated “Design System → Components” Figma page with naming consistent with common libraries (e.g., MUI, Ant Design) for easier dev mapping.",
        "testStrategy": "• Place each component variant in test frames for desktop and mobile to confirm responsiveness and spacing.\n• Validate every form element has clear focus state and error state.\n• Run a consistency check: ensure all screens use only library components (Figma’s “Instance” usage, no detached copies).\n• Print to PDF a sample of print-optimized components to confirm margins and legibility.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define component architecture, naming conventions, and variables strategy",
            "description": "Establish the overall component architecture, naming conventions, and variables strategy for the base UI library in Figma before creating components.",
            "dependencies": [
              2
            ],
            "details": "• Decide on atomic → composite hierarchy (e.g., Atoms/Molecules/Organisms or Base/Patterns) and map all required components into this structure.\n• Define component naming pattern using slashes (e.g., `Form/Input/Text`, `Button/Primary/LG`) and variant properties (e.g., `size=sm|md|lg`, `state=default|hover|focus|disabled|error|success`).\n• Set up Figma variables for semantic color, typography, spacing, radii, and state tokens coming from Task 1, and define how components will consume them (e.g., semantic tokens only, no raw hex).\n• Decide when to use variants vs component properties (e.g., boolean props for icon on/off, label visibility) to keep the library maintainable.\n• Plan a folder/page structure for the library file (e.g., Foundations, Components/Atoms, Components/Patterns, Test Frames).\nAcceptance criteria:\n• Written one-pager describing architecture, naming, and variable usage, reviewed with design + dev.\n• All created components follow the agreed naming and variant property schema.\n• No component uses raw colors or typography outside Task 1 styles/variables.\nTest frames:\n• Create a dedicated “Architecture & Tokens Sandbox” page with a few sample components wired to variables to validate the strategy before full rollout.",
            "status": "pending",
            "testStrategy": "Review a sample of at least 10 components against the written conventions to ensure consistent naming, variant properties, and variable usage."
          },
          {
            "id": 2,
            "title": "Create core form controls with full state coverage",
            "description": "Design reusable atomic form controls (inputs, textareas, dropdowns, pickers, radio, checkbox, toggles) as Figma components with all key states and sizes.",
            "dependencies": [
              1
            ],
            "details": "• List all required form controls: text input (single-line), textarea, dropdown/select, date picker, time picker, radio group, checkbox, toggle/switch, search field.\n• For each control, create base component with variants for size (sm, md, lg where needed) and state (default, hover, focus, filled, disabled, error, success, read-only).\n• Use Auto Layout and constraints so labels, helper text, and icons adjust to different label lengths and container widths.\n• Connect all colors, typography, spacing, and radii to design system tokens from Task 1.\n• Include optional adornments (leading/trailing icons, clear button) as component properties or variants.\nAcceptance criteria:\n• Each control exists as a master component with documented variant properties in Figma.\n• All interactive states have distinct visual treatment including clear focus outlines and error messaging placement.\n• Controls resize correctly in horizontal and vertical directions without breaking alignment.\nTest frames:\n• Create a \"Form Controls – Desktop\" and \"Form Controls – Mobile\" frame placing all variants in sample form layouts to test spacing, wrapping, and state transitions visually.",
            "status": "pending",
            "testStrategy": "Inspect controls in prototype mode to verify focus order and state changes; manually resize parent frames to confirm responsiveness of each control."
          },
          {
            "id": 3,
            "title": "Design buttons, chips, and tags with size and state variants",
            "description": "Create button, chip, and tag components with consistent sizes, visual hierarchy, and interactive states, aligned to the design system tokens.",
            "dependencies": [
              1
            ],
            "details": "• Define button types: primary, secondary, ghost, destructive, and any icon-only variants.\n• For buttons, create variants for size (xs, sm, md, lg if needed) and state (default, hover, focus, active/pressed, disabled, loading) with consistent padding and icon spacing.\n• Design chips and tags for filters, status, and input chips, with variants for selected vs unselected, with/without close icon, and different emphasis levels if required.\n• Ensure text truncation and long labels behave correctly using Auto Layout and min/max width constraints.\n• Map colors and typography strictly to Task 1 tokens, and align naming with common UI libraries (e.g., `Button/Primary`, `Chip/Filter`).\nAcceptance criteria:\n• All button, chip, and tag types exist as components with clearly labeled variant properties.\n• Visual hierarchy between primary, secondary, ghost, and destructive is obvious in test frames.\n• Icon placement options (left/right, icon-only) are available without creating redundant components.\nTest frames:\n• Create \"Buttons & Chips – States\" frames for desktop and mobile with all variants placed on both light and error/success backgrounds to verify contrast and legibility.",
            "status": "pending",
            "testStrategy": "Use Figma accessibility and contrast-check plugins on button and chip text; run a quick audit to confirm only library instances are used in sample flows."
          },
          {
            "id": 4,
            "title": "Build data display components: tables, lists, cards, badges, steppers, tabs, accordions",
            "description": "Construct composite data display components that are flexible, responsive, and reuse atomic components where possible.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "• Design table components with header, row, and cell subcomponents, including sortable header icons, pagination controls, and filter chips; ensure row density variants (compact, regular).\n• Create card patterns for key use cases (summary cards, list cards) with optional sections (title, meta, status, actions) using component properties.\n• Define list patterns (simple lists, media lists) and align spacing with grids.\n• Create steppers for multi-step forms with variants for current, completed, upcoming, and error steps (horizontal and vertical where needed).\n• Design tabs and accordions with clear selected/hover/focus/disabled states and support for long labels.\n• Build status badges (Paid, Pending, Failed, Overdue, Approved, Rejected, Under Review, New, Verified, etc.) as a single base component with variants by status and emphasis.\nAcceptance criteria:\n• Each data component is a single source-of-truth component with variants/properties for states and densities instead of duplicated frames.\n• Tables, tabs, and accordions behave correctly when their width changes and when label text wraps.\n• Status badges are driven by a `status` variant or property and use semantic tokens for color.\nTest frames:\n• Assemble \"Data Components – Desktop\" and \"Data Components – Mobile\" frames that mimic realistic screens (e.g., table with filters, card grid, stepper in a form) to validate composition and responsiveness.",
            "status": "pending",
            "testStrategy": "Resize test frames and sample screens to check table column behavior, card wrapping, and badge legibility; confirm all instances link back to the shared components library."
          },
          {
            "id": 5,
            "title": "Create overlays and feedback patterns: modals, side panels, toasts, banners, empty and error states",
            "description": "Design reusable overlay and feedback components covering confirmations, notifications, and system/empty/error states.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "• Define base modal component with header, body, and footer slots that can host form controls and buttons; include variants for confirmation, destructive, and full-screen modes.\n• Create side panel component patterns for contextual details or editing, with responsive widths.\n• Design toast notifications and inline banners (including DPDP consent banners) with variants for types (info, success, warning, error) and optional actions.\n• Create templated empty states and error states using illustration or icon placeholders, title, description, and primary/secondary actions.\n• Ensure focus management considerations are documented (what should receive focus on open/close) for dev handoff.\nAcceptance criteria:\n• At least one reusable base component exists for each overlay/feedback pattern with documented variant properties.\n• Overlays accommodate different content lengths and button configurations without layout breaking.\n• Empty and error states are consistent across modules in typography, iconography, and spacing.\nTest frames:\n• Build \"Overlays & Feedback – Desktop\" and \"Overlays & Feedback – Mobile\" frames simulating key flows (e.g., destructive confirmation, DPDP consent, form error) to visually validate hierarchy and spacing.",
            "status": "pending",
            "testStrategy": "Prototype sample flows triggering modals/toasts/banners to check visual stacking, alignment, and that all overlays reuse the same base components."
          },
          {
            "id": 6,
            "title": "Implement responsive behavior with Auto Layout and constraints for desktop and mobile",
            "description": "Apply Auto Layout, constraints, and layout grids so all components behave predictably across desktop and mobile breakpoints.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "• Define component-level layout rules aligned with Task 24 breakpoints and grids (e.g., desktop 12-col, mobile 4-col).\n• For each component family (forms, buttons, tables, cards, overlays), configure Auto Layout and constraints to handle width changes, content growth, and multi-line text.\n• Create size variants (desktop vs mobile where meaningfully different) only when responsive rules are insufficient.\n• Ensure components can be dropped into common container widths without manual overrides.\nAcceptance criteria:\n• All major components support at least two tested sizes (desktop and mobile frames) without visual defects.\n• No critical component relies on manual resizing of inner layers; resizing is governed by Auto Layout and constraints.\n• Components align cleanly to layout grids defined in Task 24 when placed in example screens.\nTest frames:\n• Create a \"Responsive Stress Test\" page with desktop, tablet, and mobile frames, placing key components and aggressively resizing containers to validate wrapping and alignment.",
            "status": "pending",
            "testStrategy": "Use Figma’s resize handles and layout grid overlays to confirm consistent behavior; spot-check a subset of application flows using only library components to verify real-world responsiveness."
          },
          {
            "id": 7,
            "title": "Document components in a dedicated design system page with dev mapping",
            "description": "Create a “Design System → Components” Figma page documenting usage guidance and mapping to common UI libraries for developer handoff.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "• Set up a structured documentation page (or pages) grouping components into logical sections (Forms, Buttons, Data Display, Overlays, Feedback, Layout/Print).\n• For each component, include a short description, intended usage, do/don’t examples, and notes on accessibility states (focus, error, required fields).\n• Add mapping notes to common UI libraries (e.g., MUI `TextField`, Ant Design `Table`) using consistent naming to ease implementation.\n• Include notes on expected behavior for edge cases (long text, missing data, loading states) and how variants/properties should be used.\n• Document print-optimized containers for A4 letters, receipts, and undertakings, including margins, color reduction, and typography scale.\nAcceptance criteria:\n• All core component families appear on the documentation page with clear labels and usage notes.\n• Each documented component lists at least one analogue in MUI or Ant Design where applicable.\n• Developers can navigate the page and understand which component to use for a given need without additional explanation.\nTest frames:\n• Embed example usage frames on the documentation page (e.g., mini screen mockups) demonstrating correct application of each component in context.",
            "status": "pending",
            "testStrategy": "Conduct a quick review session with at least one designer and one developer walking through the doc page and verifying they can each identify correct components for 5–7 sample UI requirements."
          },
          {
            "id": 8,
            "title": "Run quality checks for accessibility, instance usage, and library performance",
            "description": "Audit the component library for accessibility coverage, correct instance usage, and Figma performance, and fix identified issues.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "• Use Figma accessibility plugins and manual review to confirm all interactive components have clear focus, hover, active, disabled, and error/success states and adequate contrast.\n• Run an instance usage audit across key product files to ensure screens use shared components, not detached or local copies.\n• Check component descriptions and naming for clarity and completeness, updating where needed.\n• Review library performance: identify overly complex components (deep nesting, many hidden layers) and refactor for efficiency while preserving behavior.\n• Establish a lightweight maintenance checklist and cadence for future audits.\nAcceptance criteria:\n• No critical accessibility gaps remain in core components (focus states and contrast meet agreed standards).\n• All target screens consume published library instances; detached instances are either justified or eliminated.\n• Library performance is acceptable (no major lag when opening, editing, or publishing components).\nTest frames:\n• Create a \"QC & Regression\" page with representative flows (forms, tables, overlays) exclusively using library components to serve as a baseline for future regression checks.",
            "status": "pending",
            "testStrategy": "Perform a final pass using Figma’s library and performance tools plus contrast-check plugins; log and resolve issues in a short checklist before marking Task 2 as complete."
          }
        ]
      },
      {
        "id": 3,
        "title": "Define role-based navigation structure and information architecture",
        "description": "Design the global IA and navigation patterns for all roles: Applicant, Resident, Superintendent, Trustee, Accounts, Parent/Guardian.",
        "details": "• Create a sitemap listing all sections per role: Applicant (Application, Status), Resident (Dashboard, Fees, Leave, Room, Documents, Renewal, Exit), Superintendent (Applications, Leaves, Rooms, Communication, Config), Trustees (Applications forwarded, Interviews, Approvals), Accounts (Receivables, Logs, Exports), Parents (Dashboard, Fees view, Leave view).\n• Define navigation patterns: top nav vs side nav, breadcrumbs for deep sections, role-based nav items that only show relevant sections.\n• Map login entry points: Landing → Apply / Check Status / Login; then login-based redirection rules for each role.\n• Use Figma user flow diagrams to show navigation paths between major states and access restrictions.\n• Ensure vertical selection (Boys Hostel / Girls Ashram / Dharamshala) affects content filters and labels across dashboards.\n• Consider scalability for future modules (Biometric, Visitor, Mess) with placeholder nav items baked into IA but visually disabled.\n• Provide a clear guidelines note so devs can implement role-based routing using front-end routing (e.g., React Router / Vue Router) with guard hooks.",
        "testStrategy": "• Review IA with stakeholders to confirm that every requirement from the PRD maps to at least one screen in the sitemap.\n• Conduct quick card-sorting or tree-testing with 2–3 sample users (internally) to validate discoverability of key tasks.\n• Walk through each persona’s lifecycle (applicant to alumni) ensuring no dead ends or navigation loops.\n• Check that vertical selection (Boys/Girls/Dharamshala) is consistently represented in nav labels and context breadcrumbs.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Requirements and content inventory per role based on PRD",
            "description": "Compile detailed requirements and content inventory for each role (Applicant, Resident, Superintendent, Trustee, Accounts, Parent/Guardian) from the PRD, listing all sections and key tasks.",
            "dependencies": [],
            "details": "Review PRD to map every requirement to specific screens/sections per role; create tabular inventory with columns for Role, Section, Key Features, PRD Reference; outputs include inventory spreadsheet or Figma page with role cards detailing content needs.",
            "status": "pending",
            "testStrategy": "Cross-check inventory against PRD for 100% coverage; review with PM/stakeholders to confirm no missing requirements or extraneous items."
          },
          {
            "id": 2,
            "title": "Global sitemap and role-based IA including future modules",
            "description": "Design comprehensive global sitemap and role-specific information architecture, incorporating current sections and placeholders for future modules like Biometric, Visitor, Mess.",
            "dependencies": [
              1
            ],
            "details": "Build hierarchical sitemap in Figma or Miro showing all roles' sections (e.g., Applicant: Application/Status; Resident: Dashboard/Fees/etc.); include visually disabled placeholders for scalability; define shared vs role-specific content; outputs: interactive sitemap diagram and IA documentation.",
            "status": "pending",
            "testStrategy": "Validate hierarchy depth ≤3 levels; ensure future modules slotted without disrupting current flows; stakeholder sign-off on completeness."
          },
          {
            "id": 3,
            "title": "Navigation patterns selection and variants for roles",
            "description": "Select and define navigation patterns (top nav, side nav, breadcrumbs, role-scoped items) with variants for desktop/mobile and deep sections.",
            "dependencies": [
              1,
              2
            ],
            "details": "Evaluate patterns like vertical nav for dashboards, breadcrumbs for sub-sections, progressive disclosure; create Figma examples showing role-based nav (e.g., side nav for Superintendent); document guidelines for top vs side nav usage; outputs: pattern library page and variant mockups.",
            "status": "pending",
            "testStrategy": "Prototype 2-3 role navs and test resize responsiveness; confirm patterns align with Material Design/Userpilot best practices for task-oriented nav."
          },
          {
            "id": 4,
            "title": "Role-based routing and login/redirect rules in flow diagrams",
            "description": "Define login entry points, redirection rules post-login, and routing logic for each role, captured in detailed user flow diagrams.",
            "dependencies": [
              2,
              3
            ],
            "details": "Map flows: Landing → Apply/Check Status/Login → Role redirect (e.g., Applicant to Status); include guard hooks for access restrictions; use Figma prototypes for paths; provide dev notes for React/Vue Router implementation; outputs: flow diagrams and routing spec document.",
            "status": "pending",
            "testStrategy": "Walkthrough diagrams for edge cases (wrong role login, role switch); dev review for routing feasibility."
          },
          {
            "id": 5,
            "title": "Vertical context propagation rules across dashboards",
            "description": "Establish rules for how vertical selection (Boys Hostel/Girls Ashram/Dharamshala) filters content, updates labels, and propagates through IA and nav.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Define context persistence (URL params, session state); show in Figma how dashboards filter (e.g., Rooms list by vertical); update nav labels dynamically; outputs: propagation flow diagram, example screens with vertical variants, dev guidelines for state management.",
            "status": "pending",
            "testStrategy": "Test flows switching verticals mid-session; verify filters apply consistently across role sections."
          },
          {
            "id": 6,
            "title": "Validation activities for IA and navigation design",
            "description": "Conduct stakeholder reviews, internal card sorting/tree tests, and lifecycle walkthroughs to validate the IA and nav structure.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Schedule reviews with stakeholders; run card-sorting/tree-testing with 2-3 internal users per role; walkthrough full lifecycles (applicant→resident); gather feedback and iterate; outputs: validation report with findings, revised artifacts, approval sign-offs.",
            "status": "pending",
            "testStrategy": "Measure task success rate >90% in tree tests; confirm stakeholder alignment on all PRD mappings; document changes from feedback."
          }
        ]
      },
      {
        "id": 4,
        "title": "Design responsive landing page with vertical selection",
        "description": "Create the completed landing page design emphasizing hostel overview, facilities, vertical selection, and CTAs.",
        "details": "• Use desktop and mobile frames with Auto Layout to ensure responsiveness.\n• Sections: hero with hostel overview and values, discipline and safety highlights, amenities showcase, vertical selection cards (Boys Hostel, Girls Ashram, Dharamshala), visual step-by-step admission process timeline, announcements & notices, footer.\n• Vertical selection cards show short descriptions and lead into Applicant flow or login context; ensure card-style with relevant iconography but minimal visuals.\n• Admission process: design a horizontal or vertical timeline with labeled steps (Apply → Verification → Interview → Approval → Payment → Room Allocation → Check-in).\n• CTAs: clearly styled buttons for **Apply Now**, **Check Application Status**, **Login**; align button hierarchy with color tokens from the design system.\n• Include notices section using reusable announcement cards with date, type, and priority tags.\n• Consider SEO and accessibility best practices (clear headings, limited text blocks) in layout guidance for developers.\n• Use responsive constraints in Figma to adapt layout for tablets and mobiles (stack sections, reflow timeline to vertical).",
        "testStrategy": "• Validate that all landing requirements from PRD are present (overview, values, facilities, highlights, process visuals, announcements, vertical selection, CTAs).\n• Resize frames in Figma to common breakpoints (1440, 1024, 768, 375) to ensure layout doesn’t break.\n• Test tab order and keyboard navigation flow in prototype to simulate accessible interaction.\n• Run internal usability review to ensure CTAs are unambiguous and visually prominent.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Hero, Overview, and Upper Sections",
            "description": "Create responsive hero section with hostel overview and values, discipline/safety highlights, and amenities showcase using Auto Layout for desktop and mobile.",
            "dependencies": [],
            "details": "Incorporate high-quality images, concise text blocks, clear headings for SEO/accessibility; use color tokens; ensure stacking on mobile breakpoints (1440px, 768px, 375px).",
            "status": "pending",
            "testStrategy": "Resize frames to test responsiveness; validate tab order and heading hierarchy."
          },
          {
            "id": 2,
            "title": "Design Vertical Selection Cards and Admission Timeline",
            "description": "Build vertical selection cards for Boys Hostel, Girls Ashram, Dharamshala with icons, short descriptions, and CTAs; design step-by-step admission timeline.",
            "dependencies": [
              1
            ],
            "details": "Cards lead to applicant flow/login; timeline shows Apply → Verification → Interview → Approval → Payment → Room Allocation → Check-in; reflow to vertical on mobile.",
            "status": "pending",
            "testStrategy": "Prototype interactions; check card hover states and timeline adaptability across devices."
          },
          {
            "id": 3,
            "title": "Design Announcements, Footer, and Finalize CTAs/Responsiveness",
            "description": "Create announcements section with reusable cards (date, type, priority); footer; integrate all CTAs (Apply Now, Check Status, Login) with hierarchy.",
            "dependencies": [
              1,
              2
            ],
            "details": "Use announcement cards consistently; apply responsive constraints; test full page at 1024px, 768px, 375px; add dev notes for SEO/accessibility.",
            "status": "pending",
            "testStrategy": "Full page resize test; keyboard navigation; confirm CTA prominence and no layout breaks."
          }
        ]
      },
      {
        "id": 5,
        "title": "Design applicant registration & OTP verification flow",
        "description": "Design the pre-approval applicant journey including vertical selection, OTP verification, and initial application access.",
        "details": "• Map flow: Landing → Select Vertical → Enter Mobile/Email → OTP Input → Verified → Application Wizard.\n• OTP screen: design masked input, resend timer, error handling for invalid/expired codes, alternate contact if needed.\n• Ensure no persistent dashboard UI for applicants; show only minimal progress header and form navigation.\n• Add institutional messaging about data use and DPDP consent at first contact (short banner plus link to detailed policy).\n• Provide guidance text: explain that account will only be created post final approval, and tracking number will be shared.\n• For mobile, optimize OTP screen with single-field segmented inputs and auto-advance behavior (document expected behavior for devs).\n• Embed pseudo-code guidance for devs:\n  - POST /otp/send { phone/email, vertical }\n  - POST /otp/verify { code, token }\n  - On success, issue short-lived session token just for application submission.\n• Specify error states and retry limits to prevent abuse while maintaining usability.",
        "testStrategy": "• Prototype the full OTP flow and run through success, error, and timeout paths.\n• Confirm no references to \"dashboard\" or resident-only features appear in applicant views.\n• Validate copy clarity via review with non-technical stakeholders.\n• Ensure visual consistency with base components and that OTP input is accessible (labelled, focus-visible).",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Overall Flow and Screens",
            "description": "Create wireframes and high-fidelity designs for the applicant journey from landing page to application wizard, including vertical selection, contact input, OTP input, and success states.",
            "dependencies": [],
            "details": "Map the flow: Landing → Select Vertical → Enter Mobile/Email → OTP Input → Verified → Application Wizard. Include minimal progress header, no persistent dashboard, institutional messaging banner with DPDP consent link, and guidance text about account creation post-approval.",
            "status": "pending",
            "testStrategy": "Prototype the full flow and validate progression, ensuring no dashboard elements and clear messaging via stakeholder review."
          },
          {
            "id": 2,
            "title": "Design OTP Verification Screen",
            "description": "Design the OTP input screen with masked input, resend timer, error handling, alternate contact option, and mobile-optimized single-field segmented inputs with auto-advance.",
            "dependencies": [
              1
            ],
            "details": "Specify behaviors: masked input for security, resend timer (e.g., 60s), errors for invalid/expired codes, option for alternate contact. For mobile, document auto-advance on digit entry and paste support for devs.",
            "status": "pending",
            "testStrategy": "Test success/error/timeout paths in prototype, confirm usability on mobile/desktop, and validate error messages prevent abuse while maintaining flow."
          },
          {
            "id": 3,
            "title": "Document API Guidance and Error States",
            "description": "Provide developer notes including pseudo-code for OTP endpoints, session token issuance, error states, retry limits, and integration details.",
            "dependencies": [
              1,
              2
            ],
            "details": "Embed pseudo-code: POST /otp/send {phone/email, vertical}, POST /otp/verify {code, token}. On success, issue short-lived session token for application submission. Define error states (invalid/expired), retry limits (e.g., 3 attempts), and abuse prevention.",
            "status": "pending",
            "testStrategy": "Review dev notes for completeness, simulate API calls in prototype, ensure retry limits balance security and usability."
          }
        ]
      },
      {
        "id": 6,
        "title": "Design application tracking page and flow",
        "description": "Create the public Application Tracking screen with timeline, status display, interview info, and document re-upload actions.",
        "details": "• Access flow: from Landing \"Check Application Status\" CTA or link from SMS/Email → Tracking page.\n• Inputs: tracking number + OTP to registered mobile/email; design a combined identity verification flow aligned with OTP patterns from Task 5.\n• Tracking screen sections:\n  - Applicant summary (name, vertical, applied date).\n  - Visual status timeline (e.g., Submitted → Under Review → Interview Scheduled → Provisionally Approved → Final Approved / Rejected).\n  - Interview details: mode, date/time, venue/meeting link, countdown, status (upcoming, in-progress, completed).\n  - Action prompts (e.g., Re-upload documents, Confirm interview slot, Download provisional letter).\n• Use status badges and contextual alerts (e.g., \"Pending document re-upload\") with clear primary actions.\n• Allow download buttons for provisional letters in print-optimized format (integrate with print view components).\n• Include explanatory copy assuring privacy and DPDP-compliant data usage.\n• Ensure that students cannot see internal remarks; only high-level outcomes and necessary instructions.",
        "testStrategy": "• Ensure all PRD-listed data elements (timeline, interview schedule, prompts, download links) appear in the design.\n• Simulate multiple status scenarios by duplicating frame: awaiting review, interview scheduled, awaiting documents, approved, rejected.\n• Link from emails/SMS mock to this screen in prototype to check flow coherence.\n• Validate mobile-first layout for readability and tap targets.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Entry Flows and Identity Verification",
            "description": "Create frames for access from Landing CTA/SMS/Email to tracking page with tracking ID + OTP input, aligned with Task 5 OTP patterns.",
            "dependencies": [],
            "details": "Design 4 frames: Landing CTA link, tracking ID input, OTP input with resend timer/masked entry/error states, success transition to tracking page. Reuse Task 5 OTP components for consistency.",
            "status": "pending",
            "testStrategy": "Prototype full flow: success, invalid ID/OTP, timeout, resend. Verify visual alignment with Task 5 and smooth handoff to main tracking screen."
          },
          {
            "id": 2,
            "title": "Design Core Tracking Page Layout",
            "description": "Design main tracking screen with applicant summary, visual status timeline, interview details, and action prompts.",
            "dependencies": [
              1
            ],
            "details": "Create base frame with sections: summary (name/vertical/applied date), horizontal timeline (Submitted to Approved/Rejected with colors/checkmarks per [1]), interview card (mode/date/countdown/link), action buttons. Use status badges and contextual alerts.",
            "status": "pending",
            "testStrategy": "Checklist: All PRD sections present, timeline logical progression per [1], clear visual cues, descriptive labels. Review F/Z reading pattern per [3]."
          },
          {
            "id": 3,
            "title": "Design Document Re-upload and Action Patterns",
            "description": "Design re-use of existing components for document re-upload, interview confirmation, provisional letter download with print view.",
            "dependencies": [
              2
            ],
            "details": "Frame re-upload modal (reuse Task 19 patterns), confirm slot button, download buttons with print-optimized PDF preview. Include primary actions with status-based visibility.",
            "status": "pending",
            "testStrategy": "Test interactions: upload success/error, print legibility on A4, ensure actions gated by status. Validate component reuse from Tasks 5/19."
          },
          {
            "id": 4,
            "title": "Design State Variations for Major Statuses",
            "description": "Duplicate core layout for 5 states: awaiting review, interview scheduled, awaiting documents, provisionally approved, final approved/rejected.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create 5 frames varying timeline progress, interview details (upcoming/in-progress/completed), alerts/actions (e.g., re-upload prominent in awaiting docs). Use microinteractions for state changes per [1].",
            "status": "pending",
            "testStrategy": "Simulate all scenarios: verify conditional visibility, no internal remarks visible, responsive on mobile/desktop with vertical timeline if needed per [1]."
          },
          {
            "id": 5,
            "title": "Design Privacy Copy, Responsive Behavior, and Review",
            "description": "Add DPDP-compliant privacy messaging, ensure responsive design, and compile review checklist across all frames/states.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Insert explanatory banners/tooltips on data usage/privacy. Optimize for mobile (vertical layouts per [1]), desktop. Checklist: no internal remarks, clear instructions, all actions testable.",
            "status": "pending",
            "testStrategy": "Stakeholder review: copy clarity, privacy assurance, DPDP alignment. Test responsive breakpoints, print views, full flow from entry to actions in all states."
          }
        ]
      },
      {
        "id": 7,
        "title": "Design student login, first-time setup, and role-based redirection",
        "description": "Create post-approval student login experience, first login password change, and redirection into Student Dashboard.",
        "details": "• Flow: Receive credentials via Email/SMS → Login screen → First-time password change → Security confirmation → Student Dashboard.\n• Design login page consistent with institution branding; include subtle note about institutional usage rules.\n• First-time login: design forced password change form with strength indicator, confirm password, and DPDP consent checkbox/log reference.\n• After first login, persist session and redirect resident to Student Dashboard; for incorrect role or expired account, show clear error state.\n• Provide UI affordance to indicate vertical (Boys/Girls/Dharamshala) on login success (e.g., a label in top bar).\n• Design forgot password flow that uses OTP/email reset without creating new accounts.\n• Document recommended dev behavior: backend issues JWT/session, front-end uses role-based routes; do not store passwords in front-end.\n• Ensure login screen is generic and can redirect to other roles (Superintendent, Trustee, Accounts) based on account type or separate login entry points.",
        "testStrategy": "• Prototype login → first-time password change → dashboard flow for a sample user.\n• Test invalid credential, locked account, and expired link flows within the prototype.\n• Confirm visual differentiation from Applicant entry (copy and layout) to avoid confusion.\n• Review with stakeholders to ensure compliance with institutional password and audit requirements.",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design branded, multi-role login screen and basic flows",
            "description": "Create the main login UI for students and other roles, aligned with institutional branding and clear separation from applicant entry.",
            "dependencies": [],
            "details": "Design a responsive login page using institution logo, colors, and typography, with fields for username/mobile/email and password, a primary login CTA, and a clear but subtle note about institutional usage rules. Include visible links for forgot password and any alternate role entry (e.g., Superintendent, Trustee, Accounts) while keeping the screen visually distinct from the applicant registration/OTP flow. Ensure accessibility (labels, error messages, keyboard navigation), support for vertical-agnostic login (no vertical selection here), and provide error states for invalid credentials, locked or expired accounts, and generic technical failures. Document UI states in wireframes or mockups for success and failure paths.",
            "status": "pending",
            "testStrategy": "Prototype the login screen and validate branding, accessibility basics, and clarity of role separation with at least a few sample users or stakeholders."
          },
          {
            "id": 2,
            "title": "Design first-time login password change and security/DPDP confirmation",
            "description": "Create the forced first-time password change and consent screens shown immediately after initial student login.",
            "dependencies": [
              1
            ],
            "details": "After detecting a first-time student login, route to a dedicated password change screen that blocks access to the dashboard until completion. Include new password and confirm password fields, an inline password strength indicator, and copy explaining minimum requirements and security expectations. Add a required DPDP consent checkbox with concise text and a link or reference to the full policy, and plan for logging consent acceptance (timestamp and user ID) in dev notes. Include clear validation messages for weak or mismatched passwords, and a confirmation step or brief security confirmation message before redirecting to the Student Dashboard. Provide detailed UI specs and flow diagrams covering normal completion, validation errors, and back/exit behavior.",
            "status": "pending",
            "testStrategy": "Run through a prototype of the first-time login flow with sample credentials, testing weak/strong passwords, mismatches, and unchecked consent, and review with stakeholders for legal/DPDP wording and friction level."
          },
          {
            "id": 3,
            "title": "Design role-based redirection, session handling cues, and vertical indicators",
            "description": "Define and document the post-login redirection behavior, session persistence expectations, and UI cues for user role and vertical.",
            "dependencies": [
              1,
              2
            ],
            "details": "Specify how the front-end should interpret the authenticated user payload (e.g., role, vertical, account status) and route users to the correct dashboard: Student Dashboard for valid students, other role dashboards for Superintendent/Trustee/Accounts, and error pages for incorrect role, suspended, or expired accounts. Provide UI guidance for displaying the current role and vertical (Boys/Girls/Dharamshala) after login, such as a label or pill in the top bar. Describe expected session behavior at a design level (e.g., stay signed in until explicit logout or reasonable inactivity timeout), including how to visually handle session expiry and forced re-login without re-running first-time setup. Document do/don’t notes for developers: backend issues JWT/session, front-end uses role-based routes and must not store passwords or sensitive secrets. Capture these behaviors in a concise flow diagram and state table for key scenarios.",
            "status": "pending",
            "testStrategy": "Create a clickable prototype or flow diagram to walk through student vs non-student logins, expired/incorrect role cases, and session expiry, then review with devs to ensure routing and UI states are unambiguous."
          }
        ]
      },
      {
        "id": 8,
        "title": "Design parent/guardian OTP-based view-only login",
        "description": "Create a dedicated parent/local guardian login and restricted dashboard with view-only access.",
        "details": "• Flow: Select Parent/Guardian Login → Enter registered mobile → OTP verification → Parent Dashboard.\n• Parent Dashboard sections:\n  - Student overview (photo optional, name, vertical, room, joining date).\n  - Fee status (Paid / Pending / Overdue, upcoming dues, download receipts).\n  - Leave summary and statuses (upcoming, approved, rejected, past leaves).\n  - Notifications center showing recent communications affecting their ward.\n• Ensure all primary actions are view-only: no edit, no approval; only acknowledgements where required.\n• Provide clear labels and tooltips explaining permissions and responsibilities of parents.\n• Reuse OTP component patterns and status badges from design system.\n• Add DPDP informational content highlighting what data parents can see and how it is protected.\n• Outline dev guidance: enforce role scopes on API (e.g., parents can only see associated student IDs; read-only endpoints).",
        "testStrategy": "• Walk through parent login flow from Landing CTA in prototype.\n• Check every actionable element to ensure there are no state-changing actions (e.g., no editable form fields).\n• Validate that fee and leave information is presented clearly even on mobile.\n• Review with stakeholders to ensure that parent awareness and audit needs are met without overexposing internal remarks.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Parent/Guardian Entry and OTP Verification Flow",
            "description": "Create the login flow: Select Parent/Guardian Login → Enter registered mobile → OTP verification → Redirect to Parent Dashboard, reusing existing OTP patterns from Task 5.",
            "dependencies": [],
            "details": "Reuse masked OTP input, resend timer, error handling from Task 5. Ensure mobile-first design with clear labels. Add dev guidance for parent role scoping on API endpoints.",
            "status": "pending",
            "testStrategy": "Prototype full flow: success, invalid/expired OTP, resend. Verify no mutating actions; test on mobile devices for touch targets and readability. Confirm redirect only to view-only dashboard."
          },
          {
            "id": 2,
            "title": "Design Parent Dashboard IA and Layout",
            "description": "Design information architecture and mobile-first layout for sections: Student overview, Fee status, Leave summary, Notifications center.",
            "dependencies": [
              1
            ],
            "details": "Student overview: photo (optional), name, vertical, room, joining date. Fee: statuses, upcoming dues, receipt downloads. Leave: upcoming/approved/rejected/past. Notifications: recent ward-related comms. Use status badges from design system.",
            "status": "pending",
            "testStrategy": "Prototype dashboard; verify all sections load read-only data without edit fields. Test mobile scrolling, card stacking, and data clarity at 320px width. Ensure download links non-mutating."
          },
          {
            "id": 3,
            "title": "Specify Permissions and View-Only Behaviors",
            "description": "Define and implement view-only access: no edits, no approvals; allow only acknowledgements where required. Enforce role-based data scoping.",
            "dependencies": [
              1,
              2
            ],
            "details": "Parents see only associated student data via API role scopes (read-only endpoints). Disable all input fields/buttons except acknowledgements (e.g., 'Seen' on notifications). Provide dev notes on backend enforcement.",
            "status": "pending",
            "testStrategy": "Inspect prototype elements: confirm no forms, edit icons, or approval buttons. Simulate API calls to verify scoped data only. Test acknowledgement flows don't mutate core data; mobile gesture checks."
          },
          {
            "id": 4,
            "title": "Add Compliance, DPDP Info, and Scope Clarity",
            "description": "Incorporate DPDP informational content, tooltips explaining permissions/responsibilities, and clear labels for view-only scope.",
            "dependencies": [
              2
            ],
            "details": "Add banner/link to DPDP policy on data visibility/protection. Tooltips: 'View-only: cannot edit student info'. Labels: 'Parent Dashboard - View Your Ward's Status'. Ensure consistent tone across UI.",
            "status": "pending",
            "testStrategy": "Review all copy/tooltips for clarity and compliance. Test hover/tap on mobile for tooltip visibility. Verify no permission confusion leads to mutating attempts; stakeholder review for legal accuracy."
          }
        ]
      },
      {
        "id": 9,
        "title": "Design Student Dashboard (approved residents)",
        "description": "Create the main resident dashboard with status tracker, quick actions, and notifications.",
        "details": "• Layout: hero status area, quick action cards, notifications panel, and key summaries.\n• Resident journey tracker: visual indicator with stages `Checked-in → Renewal Due → Renewed → Exited` using timeline or segmented progress bar.\n• Quick action cards: **Pay Fees**, **Download Letters**, **Apply for Leave**, **View Room Details**, **View Documents**, **Renewal** when due.\n• Notifications: list of fee reminders, renewal due alerts, leave decisions, communication logs relevant to student.\n• Include vertical context (Boys/Girls/Dharamshala) and current academic period.\n• Ensure design is responsive and uses reusable card and badge components.\n• Keep tone student-friendly yet disciplined: integrate short helper text explaining next steps.\n• Provide dev hints for conditional visibility: e.g., show Renewal card only within configured renewal window, Exit card only when allowed.\n• Integrate subtle DPDP consent renewal alert when renewal cycle approaches.",
        "testStrategy": "• Confirm dashboard includes all PRD-required features and quick actions.\n• Create variations: new resident, nearing renewal, post-renewal, exit-initiated, and verify layout resilience.\n• Conduct quick usability review focusing on clarity of \"what do I do next\" for a student.\n• Validate mobile layout, ensuring quick actions are easily accessible and scrollable.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Dashboard Content Model and IA Design",
            "description": "Define the information architecture and content model for hero status, journey tracker, quick actions, and notifications panel.",
            "dependencies": [],
            "details": "Structure layout with hero status area, quick action cards, notifications list, and key summaries; include vertical context (Boys/Girls/Dharamshala) and academic period; use reusable card and badge components with student-friendly helper text.",
            "status": "pending",
            "testStrategy": "Mock scenarios: new resident (all actions visible), nearing renewal (renewal card prominent); validate via usability review for 'what do I do next' clarity and logical flow."
          },
          {
            "id": 2,
            "title": "Visual Design of Journey Tracker and Quick Actions",
            "description": "Design visual journey tracker and conditional quick action cards with stages and visibility rules.",
            "dependencies": [],
            "details": "Create timeline or segmented progress bar for Checked-in → Renewal Due → Renewed → Exited; design cards for Pay Fees, Download Letters, Apply for Leave, View Room Details, View Documents, Renewal (conditional on window); add dev hints for visibility.",
            "status": "pending",
            "testStrategy": "Mock states: Checked-in (basic actions), Renewal Due (renewal highlighted), Renewed (post-renewal actions), Exited (minimal actions); review usability for intuitive progress indication and action prioritization."
          },
          {
            "id": 3,
            "title": "Responsive Layouts and Key State Variants",
            "description": "Develop responsive layouts with variants for resident lifecycle states ensuring mobile and desktop usability.",
            "dependencies": [
              1
            ],
            "details": "Design hero area, cards, notifications for new resident, nearing renewal, post-renewal, exit-initiated states; ensure responsiveness using grid systems, consistent spacing, and accessibility features like keyboard navigation.",
            "status": "pending",
            "testStrategy": "Mock variants: new resident (full access), nearing renewal (alerts prominent), post-renewal (summary focus), exit-initiated (clearance actions); validate layout resilience on mobile/desktop via usability review."
          },
          {
            "id": 4,
            "title": "Integration Mapping to Core Modules",
            "description": "Map dashboard elements to fees, room, leave, documents, renewal, and exit modules for seamless navigation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Define links and data flows from quick actions and notifications to Task 16 (fees), room details, leave (Task 20?), documents, renewal (Task 19), exit (Task 20); ensure conditional visibility aligns with module states.",
            "status": "pending",
            "testStrategy": "Mock integrations: click Pay Fees → fees module, Renewal Due → Task 19 flow; review end-to-end journeys for new resident to exit-initiated, confirming no broken links or context loss in usability tests."
          },
          {
            "id": 5,
            "title": "Governance and DPDP Elements Implementation",
            "description": "Incorporate vertical context, academic period, and DPDP consent renewal alerts into dashboard.",
            "dependencies": [
              1
            ],
            "details": "Add subtle DPDP consent renewal banner near renewal cycle; display vertical (Boys/Girls/Dharamshala) and current academic period in hero area; integrate with notifications for consent alerts; maintain disciplined yet friendly tone.",
            "status": "pending",
            "testStrategy": "Mock scenarios: renewal approaching (DPDP alert visible), different verticals (context switches correctly); usability review for non-intrusive alerts, consent clarity, and context accuracy across states."
          }
        ]
      },
      {
        "id": 10,
        "title": "Design multi-step admission application form wizard",
        "description": "Create the complete multi-step admission form wizard with validation, drafts, and vertical-based routing.",
        "details": "• Steps: 1) Personal Details, 2) Academic & Course Info, 3) Hostel Preferences, 4) References (including ex-student references), 5) Document Upload, 6) Review & Submit.\n• Top or side stepper showing progress and current step; allow navigation back without losing data.\n• Personal details: name, DOB, contact, permanent address, parent/guardian info, local guardian details, emergency contacts.\n• Academic: institution, course, year/semester, marks, certificates upload references.\n• Hostel preferences: vertical (pre-selected), room type preferences, duration, special considerations.\n• References: fields for ex-student references with contact details.\n• Document upload: drag-and-drop + file picker; accept **PDF/JPG** with file size guidelines; show previews and replace/delete options.\n• Include \"Save as Draft\" CTA on every step; visually indicate saved state.\n• Show inline validation messages and helper text; highlight required fields clearly.\n• Routing logic note for devs: submit final application to respective Superintendent queue based on selected vertical.\n• Ensure robust error and connectivity messaging (e.g., “draft saved locally/remote”).",
        "testStrategy": "• Run through the entire wizard in prototype, verifying step order, progress indicator, and review screen correctness.\n• Test validation scenarios: missing required fields, invalid formats, large file upload placeholders.\n• Confirm that \"Save as Draft\" appears on all steps and is visually distinct from \"Next\" or \"Submit\".\n• Validate mobile layout, ensuring stepper remains understandable on small screens.",
        "priority": "high",
        "dependencies": [
          5,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define wizard information architecture, steps, and field-level requirements",
            "description": "Clarify and document the full multi-step admission wizard structure, per-step goals, and detailed field lists, validations, and edge cases.",
            "dependencies": [],
            "details": "Map the end-to-end wizard flow: confirm the 6 steps, their order, and any conditional or vertical-based variations in content. For each step (Personal Details, Academic & Course Info, Hostel Preferences, References, Document Upload, Review & Submit), list all fields, required/optional status, helper texts, and validation rules (format, length, allowed values). Capture special needs like ex-student references, file type and size constraints, and routing note for Superintendent queues. Produce a structured spec (e.g., flow diagram plus per-step form schema) to be used by design and dev.",
            "status": "pending",
            "testStrategy": "Review the flow and field inventory with stakeholders and devs to ensure all business rules, verticals, and edge cases are covered and there are no missing fields or contradictory rules."
          },
          {
            "id": 2,
            "title": "Design interaction patterns, navigation, drafts, and validation behavior for the wizard",
            "description": "Define how users move through steps, see progress, save drafts, handle errors, and deal with connectivity issues in the admission wizard.",
            "dependencies": [
              1
            ],
            "details": "Design the top or side stepper showing current step, completed steps, and remaining steps; specify labels, states, and click behavior (including backward navigation without data loss). Define primary/secondary CTAs per step (Next, Back, Save as Draft, Cancel), and specify how and when auto-save or manual draft save occurs and how saved state is visually indicated. Document inline validation behavior (on blur vs on submit), error message placement and copy guidelines, and handling of cross-step errors surfaced on Review step. Outline UX for connectivity issues and draft storage (e.g., local vs remote messaging, retry states) and how progress is preserved when users leave and return.",
            "status": "pending",
            "testStrategy": "Prototype a low- or mid-fidelity flow and run through common paths (linear completion, step back-and-forth, draft save and resume, offline/online transitions) to verify that navigation is intuitive, data is preserved, and error states are clear."
          },
          {
            "id": 3,
            "title": "Create detailed UI designs for all wizard steps including review and upload experiences",
            "description": "Produce high-fidelity UI screens and components for each wizard step, covering layouts, inputs, uploads, previews, and the final review & submit screen.",
            "dependencies": [
              1,
              2
            ],
            "details": "Design responsive layouts for each step using a consistent visual language: typography, spacing, input styles, and stepper placement. For Personal and Academic steps, lay out form sections with clear grouping and helper text. For Hostel Preferences and References, design patterns for repeated or optional sections (e.g., multiple references). For Document Upload, design drag-and-drop and file picker UI, PDF/JPG acceptance messaging, file size hints, preview tiles/cards, and replace/delete actions. For Review & Submit, design a read-only summary grouped by step, with edit links that return users to specific steps. Include annotations for devs on vertical-based Superintendent routing triggers and any conditional UI. Package into a design file with component specs and states (default, focused, error, disabled, loading).",
            "status": "pending",
            "testStrategy": "Walk through the full set of high-fidelity screens in an interactive prototype, validating visual consistency, accessibility basics (labels, focus states, contrast), correct representation of all states (empty, filled, error, draft saved), and alignment with the defined interaction patterns."
          }
        ]
      },
      {
        "id": 11,
        "title": "Design documents, undertakings, and sign-offs experience",
        "description": "Create UI for uploading required declarations at application time and digital acknowledgements post-admission.",
        "details": "• At application time: separate section/cards for Student declaration, Parent consent, Local guardian undertaking, acceptance of hostel rules, admission terms & conditions.\n• Provide scan/upload option for signed documents (PDF/JPG) and clear instructions for signatures.\n• Design preview modal or side panel for documents before submission with zoom and scroll.\n• Use status indicators: **Pending / Uploaded / Verified** for each document; display verification done by admin roles.\n• For post-admission undertakings, design in-app acknowledgement dialogs or forms with checkboxes and digital signature/typed name fields.\n• Ensure all documents and undertakings have **print-optimized layouts** using the print component styles (margins, letterhead, logo, sign blocks).\n• Provide download buttons for each document version (submitted, approved, generated letters).\n• Include DPDP consent logging elements: timestamp of consent, short text referencing policy.\n• Note dev integration: store metadata like `uploadedBy`, `uploadTime`, `verifiedBy`, `verifyTime`, `status` for audit.\n",
        "testStrategy": "• Verify that all required document types from PRD are represented with their statuses.\n• Prototype upload → preview → status change flows.\n• Print example undertakings and declarations as PDF to confirm formatting and readability.\n• Review with stakeholders (legal/compliance) for DPDP consent visibility and sign-off patterns.",
        "priority": "high",
        "dependencies": [
          10,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define application-time document upload cards, fields, and user flows",
            "description": "Design the set of application-time declaration cards and map the end-to-end UX from seeing a required document through successful upload.",
            "dependencies": [],
            "details": "List all required declaration types (student declaration, parent consent, local guardian undertaking, hostel rules, admission T&Cs) and specify which are mandatory or conditional. Define card layout, labels, helper text, and error states. Map user flow: first visit, partially completed, and completed applications. Specify where scan/upload controls appear, supported file types and size limits, and how instructions for physical signatures are displayed. Capture integration assumptions such as backend endpoints for listing required docs and saving per-card status.",
            "status": "pending",
            "testStrategy": "Prototype the multi-card section and run through scenarios: all documents pending, some uploaded, all uploaded. Validate clarity of labels and instructions with at least one stakeholder review."
          },
          {
            "id": 2,
            "title": "Design upload, preview, and document status lifecycle patterns",
            "description": "Specify reusable patterns for file upload controls, preview UI, and the Pending/Uploaded/Verified lifecycle.",
            "dependencies": [
              1
            ],
            "details": "Define upload component behavior (drag-and-drop vs button, progress bars, cancel/retry, handling duplicates). Design preview modal or side panel including zoom, scroll, rotation, pagination for PDFs, and fallback when preview is unavailable. Enumerate all status values (Pending, Uploaded, Verified, plus any error/rejected states if needed) and their visual treatments (badges, icons, colors, tooltips). Describe transitions between states, who can trigger them (applicant vs admin), and how the UI refreshes after admin verification. Document integration assumptions for status updates via APIs or websockets and how failures are surfaced to users.",
            "status": "pending",
            "testStrategy": "Create an interactive prototype of upload → preview → status change flows and test with sample files (PDF/JPG, large size, corrupted files). Verify that each state and transition is visually distinct and that errors are recoverable."
          },
          {
            "id": 3,
            "title": "Specify post-admission digital undertakings and acknowledgement flows",
            "description": "Design the UX for in-app undertakings, consent dialogues, and digital acknowledgements required after admission.",
            "dependencies": [
              1,
              2
            ],
            "details": "List all post-admission undertakings and map when and where each is presented in the product (on login, within a tasks panel, or dedicated page). Define acknowledgement patterns: checkbox groups, explicit consent statements, typed name or digital signature field, and confirmation screens. Capture edge cases: partially completed undertakings, forced completion before accessing other features, revocation or updates to terms. Detail the data elements captured per acknowledgement, error handling for incomplete submissions, and assumptions on backend APIs for saving and locking responses.",
            "status": "pending",
            "testStrategy": "Prototype at least one end-to-end undertaking flow (prompt → review text → provide acknowledgements → confirmation) and verify behavior for first-time users, returning users with pending undertakings, and users who have already completed them."
          },
          {
            "id": 4,
            "title": "Design print-optimized layouts for documents and undertakings",
            "description": "Define the templates and styling rules for printable versions of declarations, undertakings, and related artifacts.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create layout specifications for print views including margins, header/footer, institute letterhead, logo placement, typography, page breaks, and signature blocks for all relevant roles (student, parent, local guardian, admin). Document how the same template adapts from on-screen view to print/PDF output using the existing print component styles. Define variants for submitted vs approved vs generated letters. Capture assumptions about template engine, localization, and how dynamic data (names, dates, statuses) are injected at print time.",
            "status": "pending",
            "testStrategy": "Generate sample print/PDF outputs for key document types and visually inspect for alignment, readability, and branding consistency. Validate page breaks and signature block positioning on common paper sizes (e.g., A4, Letter)."
          },
          {
            "id": 5,
            "title": "Define audit and consent metadata model and integration assumptions",
            "description": "Specify the metadata schema and behavior for uploads and consents, covering timestamps, actors, and statuses for auditability.",
            "dependencies": [
              2,
              3
            ],
            "details": "Detail the full metadata set for each uploaded document and undertaking: uploadedBy, uploadTime, verifiedBy, verifyTime, status history, device/context info if required, and DPDP consent logging elements (timestamp, consent text reference, version of policy). Define how metadata is created, updated, and read by different services and which fields are immutable. Describe how this metadata appears in UI (tooltips, detail panels, audit trail views) without overwhelming end users. Capture data retention, time zone conventions, and integration contracts with backend systems.",
            "status": "pending",
            "testStrategy": "Review the proposed metadata schema with engineering and legal/compliance stakeholders. Validate that example records cover all required scenarios (initial upload, re-upload, verification, rejection, consent renewal) and can be represented cleanly in mock API responses."
          },
          {
            "id": 6,
            "title": "Specify cross-role visibility rules and legal/compliance review loop",
            "description": "Define which roles can see or act on each document/undertaking element and how legal/compliance review is incorporated.",
            "dependencies": [
              1,
              2,
              3,
              5
            ],
            "details": "Enumerate all relevant roles (applicant, student, parent-facing proxy if any, hostel admin, verifier, accounts, legal/compliance) and map their permissions for view, download, verify, comment, and update for each document type and status. Define visibility of DPDP consent logs and audit metadata per role. Describe workflows for legal/compliance review of templates and consent language, including versioning and approval steps before changes go live. Capture assumptions about role management, feature flags, and how blocked actions (e.g., unauthorized downloads) are signaled in the UI.",
            "status": "pending",
            "testStrategy": "Create a role-permission matrix and run walkthroughs for at least three personas (e.g., applicant, verifier, compliance officer) to ensure no inconsistent or unintended access. Review flows and permission rules with legal/compliance stakeholders for sign-off."
          }
        ]
      },
      {
        "id": 12,
        "title": "Design Superintendent application review and configuration panels",
        "description": "Create superintendent-facing interface for managing applications, leave rules, and parent notification rules.",
        "details": "• Application list: table view with filters for **New, Under Review, Approved, Rejected** plus search and vertical filter.\n• Columns: applicant name, date, vertical, current status, payment status, interview scheduled?, flags.\n• Detailed view: all application details, uploaded documents with preview, payments summary, internal notes, and action buttons.\n• Actions: **Approve**, **Reject**, **Forward to Trustees**; each with confirmation modals capturing required remarks.\n• Configuration screens:\n  - Leave approval rules: define which leave types require approval, thresholds, blackout dates.\n  - Parent notification rules: timing (on request, on approval, on rejection), channels (SMS, WhatsApp, Email).\n• Use tabbed layout or separate subpages for Applications, Leaves, Communication, Settings.\n• Ensure UI clearly indicates vertical context (Boys/Girls/Dharamshala) to avoid cross-mix errors.\n• Include embedded \"Send Message\" buttons in application detail view for ad-hoc communication.\n• Dev hints: ensure data tables support server-side paging and filters for scalability; design filter chips accordingly.",
        "testStrategy": "• Simulate each filter state and action (approve/reject/forward) in the prototype.\n• Validate that rules configuration UI covers all rule types listed in PRD.\n• Conduct quick heuristic evaluation for data density and readability on 13\" screens.\n• Confirm that internal-only fields (remarks) are visually distinguished from student-visible outcomes.",
        "priority": "high",
        "dependencies": [
          3,
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Application List and Detail Views",
            "description": "Create wireframes and high-fidelity designs for the superintendent application table view with filters, columns, detailed view including documents preview, payments, notes, and action buttons.",
            "dependencies": [],
            "details": "Include filters for New/Under Review/Approved/Rejected statuses, vertical filter (Boys/Girls/Dharamshala), search; columns: name, date, vertical, status, payment, interview, flags; actions: Approve/Reject/Forward with modals; embed Send Message button. Ensure server-side paging hints.",
            "status": "pending",
            "testStrategy": "Prototype filter states, action flows, and vertical context indicators; validate data density on 13\" screens."
          },
          {
            "id": 2,
            "title": "Design Leave Approval and Parent Notification Configuration Panels",
            "description": "Design configuration screens for leave rules (types, thresholds, blackout dates) and parent notification rules (timing, channels like SMS/WhatsApp/Email).",
            "dependencies": [],
            "details": "Use form-based interfaces with clear inputs for rule definitions; ensure vertical-specific contexts to prevent cross-mix; integrate into tabbed layout or subpages for Applications, Leaves, Communication, Settings.",
            "status": "pending",
            "testStrategy": "Simulate rule creation/editing; confirm coverage of all PRD rule types and UI readability for configuration tasks."
          },
          {
            "id": 3,
            "title": "Design Overall Layout, Navigation, and Vertical Context Indicators",
            "description": "Design tabbed layout or subpages structure, navigation between Applications/Leaves/Communication/Settings, and UI elements to clearly indicate vertical context.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement filter chips, confirmation modals with remarks capture; ensure scalability with server-side paging; add visual safeguards against cross-vertical errors (e.g., color-coding, prominent badges).",
            "status": "pending",
            "testStrategy": "Conduct heuristic evaluation for navigation flow, error prevention, and responsive design; test on multiple screen sizes."
          }
        ]
      },
      {
        "id": 13,
        "title": "Design Trustee panel for provisional approvals and interviews",
        "description": "Create Trustee-facing interface for provisional approval/rejection, interview scheduling, remarks, and final decisions.",
        "details": "• Trustee dashboard: list of applications forwarded from Superintendents with key metadata (applicant, vertical, recommendation, flags).\n• Application detail view: summary of application, documents, superintendent notes, previous decisions.\n• Provisional approval / rejection UI with decision modals describing implications.\n• Interview scheduling section:\n  - Fields: Mode (Online Zoom/Google Meet or Physical), Date, Time, Location or Meeting link.\n  - Integration placeholders for link entry (document label that devs can integrate with calendar/meeting APIs later).\n  - Auto-reminder configuration (checkbox for auto-reminder 24 hours before).\n• Interview remarks form: structured notes (ratings, observations) but clearly flagged as **internal**.\n• Final selection / rejection CTA, with clear copy about outcomes and downstream effects (account creation, refusal).\n• Ensure students only see high-level result; design a derived \"Outcome Summary\" card that excludes internal remarks.\n• Embed \"Send Message\" options to trigger communications to student/parent regarding interview and decision.\n",
        "testStrategy": "• Prototype end-to-end: view forwarded application → schedule interview → enter remarks → final approval.\n• Validate that internal remarks are visually and structurally separated from outcome summary.\n• Check that scheduling forms are usable on mobile and handle time/date inputs clearly.\n• Review with stakeholders to ensure the workflow matches institutional governance expectations.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Trustee panel information architecture and key user flows",
            "description": "Map the overall structure and navigation of the Trustee panel, focusing on how trustees move between dashboard, application detail, provisional decision, interview scheduling, remarks, and final decision screens.",
            "dependencies": [],
            "details": "Identify all required screens and states: trustee dashboard, application detail view, provisional approval/rejection modal, interview scheduling form, interview remarks section, final decision actions, and outcome summary display. Create user flow diagrams for core paths: reviewing forwarded applications, issuing provisional decisions, scheduling/modifying interviews, recording internal remarks, and confirming final outcomes. Align flows with existing admin roles and upstream superintendent workflows so that dependencies (e.g., only forwarded applications are visible) are explicit.",
            "status": "pending",
            "testStrategy": "Review user flows with stakeholders to confirm they cover all trustee responsibilities and match business rules before moving into detailed UI design."
          },
          {
            "id": 2,
            "title": "Design dashboard and application detail UIs for Trustee decisions",
            "description": "Create high-fidelity layouts for the trustee dashboard and application detail view, prioritizing clarity of key metadata, superintendent recommendations, and decision controls for provisional approvals.",
            "dependencies": [
              1
            ],
            "details": "Design a dashboard list view that surfaces forwarded applications with sortable columns such as applicant name, vertical, superintendent recommendation, flags, and current status. Include filters for status (pending provisional, interview scheduled, awaiting final decision) and vertical. For the application detail screen, structure sections for applicant summary, key documents, superintendent notes, previous decisions, and a clearly separated area for Trustee actions (provisional approval/rejection CTAs with explanatory modals). Ensure responsive behavior and visual hierarchy so trustees can quickly assess risk, recommendations, and next steps.",
            "status": "pending",
            "testStrategy": "Prototype dashboard and detail screens and run through sample cases to validate that trustees can locate critical information and issue a provisional decision within a few clicks on both desktop and common laptop resolutions."
          },
          {
            "id": 3,
            "title": "Design interview scheduling, internal remarks, and outcome summary components",
            "description": "Create detailed UI components for interview scheduling, internal-only interview remarks, final selection/rejection CTAs, outcome summary card, and integrated messaging triggers to students/parents.",
            "dependencies": [
              1,
              2
            ],
            "details": "Design the interview scheduling form with fields for mode (online/physical), date, time, location or meeting link, auto-reminder checkbox, and visible placeholders where developers will later hook calendar/meeting integrations. Create an internal remarks section with ratings and observation fields, visually tagged as internal-only and separated from any student-visible content. Define final decision CTAs with clear copy on implications (account creation, refusal) and design a derived Outcome Summary card that excludes internal notes while summarizing result and next steps. Embed Send Message entry points for notifying students/parents about interview details and final decisions, following patterns from the notifications/communications system.",
            "status": "pending",
            "testStrategy": "Walk through an end-to-end prototype from provisional approval to interview scheduling, remarks entry, and final decision, confirming that internal remarks never appear on student-facing views and that scheduling and messaging elements are clear and mobile-friendly."
          }
        ]
      },
      {
        "id": 14,
        "title": "Design embedded communication patterns (WhatsApp, SMS, Email)",
        "description": "Create contextual communication UI elements embedded in key workflows with templates and schedule options.",
        "details": "• Identify touchpoints: interview scheduling, selection/rejection, fee reminders, leave approval/rejection, renewal, exit notifications.\n• At each touchpoint, design a **Send Message** button opening a side panel or modal with:\n  - Channel toggles (WhatsApp, SMS, Email).\n  - Template dropdowns with editable message body.\n  - Recipient list (student, parent, local guardian, superintendent copy).\n• Include schedule options for some flows (e.g., auto-reminders 24 hours pre-interview, fee reminder cadence T-15, T-7, T-3, due date).\n• Show preview of final message including dynamic placeholders ({{name}}, {{date}}, {{amount}}) and highlight to devs that these will be auto-populated.\n• Provide design for an escalation feature: when fees overdue, UI shows \"Escalate\" with auto-selection of parents + superintendent consolidated report.\n• Ensure all communication triggers are logged via a consistent pattern: show a small \"Log will be stored\" info line.\n• Note to devs: actual sending will use APIs (e.g., Twilio, WhatsApp Business API, transactional email), but design must be service-agnostic.\n",
        "testStrategy": "• Walk through at least three embedding scenarios (interview, fee reminder, leave decision) in the prototype.\n• Validate that communication UI never hides critical context (e.g., referencing wrong student) by including summary in the panel.\n• Check that templates are editable but have safe defaults.\n• Confirm presence of schedule and escalation UI per PRD requirements.",
        "priority": "high",
        "dependencies": [
          12,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify and Map Communication Touchpoints",
            "description": "Analyze and document all specified touchpoints for embedding communication UI, including interview scheduling, selection/rejection, fee reminders, leave approval/rejection, renewal, and exit notifications.",
            "dependencies": [],
            "details": "Create a visual map or flowchart showing where the 'Send Message' button integrates into each workflow. Prioritize touchpoints based on frequency and urgency (e.g., fee reminders first). Include context summary requirements to avoid wrong recipient errors.",
            "status": "pending",
            "testStrategy": "Review map with stakeholders to confirm all PRD touchpoints covered and no critical workflows missed."
          },
          {
            "id": 2,
            "title": "Design Core Send Message Panel Components",
            "description": "Design the side panel or modal triggered by 'Send Message' button, featuring channel toggles (WhatsApp, SMS, Email), template dropdowns with editable body, recipient lists, and message preview with dynamic placeholders.",
            "dependencies": [
              1
            ],
            "details": "Specify UI elements: toggles with icons, searchable dropdowns for templates, checkboxes for recipients (student, parent, guardian, superintendent CC), rich text editor for body, and live preview pane showing {{name}}, {{date}}, {{amount}} populated examples. Ensure service-agnostic with dev notes on APIs.",
            "status": "pending",
            "testStrategy": "Prototype panel in Figma; test edit/preview flow, placeholder rendering, and responsive modal behavior on desktop/mobile."
          },
          {
            "id": 3,
            "title": "Design Scheduling, Escalation, and Logging Features",
            "description": "Incorporate schedule options for reminders, escalation UI for overdue fees, and consistent logging indicators across all communication patterns.",
            "dependencies": [
              1,
              2
            ],
            "details": "For scheduling: date/time picker with presets (e.g., T-24h interview, fee cadence T-15/7/3/due). Escalation: prominent 'Escalate' button auto-selecting parents + superintendent with consolidated report template. Add 'Log will be stored' info tooltip everywhere. Ensure non-blocking of parent context.",
            "status": "pending",
            "testStrategy": "Prototype 3 scenarios (interview reminder, fee escalation, leave rejection); validate scheduling presets, escalation auto-select, and logging visibility without UX friction."
          }
        ]
      },
      {
        "id": 15,
        "title": "Design fee payment and student-side payment experience",
        "description": "Create student-facing payment UI including fee breakup, payment methods, statuses, and receipts.",
        "details": "• Student payments page: show fee breakup components: processing fee, hostel fees, security deposit, key deposit.\n• Clearly label amounts due, paid, outstanding, and due dates; use status badges (**Paid, Pending, Failed, Overdue**).\n• Payment methods section: UI for UPI and QR Code flows with placeholders for integration; show payment instructions and security notes.\n• Use primary CTA **Pay Now** which opens payment details modal/page with method selection.\n• Upon successful payment, show confirmation screen with receipt download button (print-optimized receipt layout) and summary.\n• Design failure and pending screens with retry and contact support options.\n• Provide receipt template incorporating logo, payment breakdown, transaction ID, date/time, payer details.\n• Pseudo-code guidance for integration:\n  - Front-end posts to `/payments/create` and receives payment link/QR.\n  - Poll `/payments/status` until success/failure and then update UI state.\n• Ensure DPDP and financial privacy disclaimers are visible where relevant.",
        "testStrategy": "• Prototype payment flows: normal success, failure, and timeout.\n• Validate clarity of fee breakup and ensure no overlapping labels or ambiguous totals.\n• Print sample receipts from the print view design to check margins and information density.\n• Conduct internal UX review focused on preventing payment confusion and double payments.",
        "priority": "high",
        "dependencies": [
          2,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design student payments overview page with fee breakup and statuses",
            "description": "Create the main student payments page showing clear fee breakup, totals, and payment status indicators.",
            "dependencies": [],
            "details": "Design layout that lists all fee components (processing fee, hostel fees, security deposit, key deposit) with per-line amounts and a clear total. Include labels for amounts due, paid, and outstanding, with due dates displayed prominently near the summary. Add visually distinct status badges for Paid, Pending, Failed, and Overdue, ensuring they are readable and accessible. Reserve space for DPDP and financial privacy disclaimers near the summary or footer without distracting from the primary actions.",
            "status": "pending",
            "testStrategy": "Review with stakeholders using sample fee scenarios (all paid, partially paid, overdue) to confirm clarity of amounts and labels; run UX checks for readability and accessibility of status badges on mobile and desktop."
          },
          {
            "id": 2,
            "title": "Design payment initiation and method selection flow (Pay Now, UPI, QR)",
            "description": "Create the interaction and UI for starting a payment, choosing methods, and guiding users through UPI/QR flows with integration placeholders.",
            "dependencies": [
              1
            ],
            "details": "Design a primary Pay Now CTA on the payments overview page that opens a focused modal or dedicated page. In this flow, present available methods (e.g., UPI, QR Code) with clear icons, brief descriptions, and security notes. Include fields or placeholders that will be populated by backend responses from /payments/create (e.g., payment link, QR image). Provide stepwise instructions for UPI and QR use, plus a visible processing state while payments are in progress. Ensure there is a consistent area in the UI to surface polling-based status updates from /payments/status.",
            "status": "pending",
            "testStrategy": "Prototype the Pay Now flow with mock data for UPI and QR and run through success, in-progress, and cancellation scenarios; validate that users always know which step they are on and what to do next, and that the design can accommodate asynchronous status updates."
          },
          {
            "id": 3,
            "title": "Design payment result states and receipt experience (success, failure, pending)",
            "description": "Define UI for post-payment outcomes including confirmations, errors, pending states, and a reusable receipt template for students.",
            "dependencies": [
              2
            ],
            "details": "Create distinct screens or states for successful, failed, and pending payments, each with appropriate messaging, visual cues, and next steps. For success, design a confirmation screen summarizing amount, method, and key details, with a prominent button to download or print a receipt using a print-optimized layout. The receipt template should support logo, fee breakdown, transaction ID, date/time, payer details, and status. For failures and pending states, provide clear explanations, retry options where appropriate, and a contact support path. Ensure DPDP and financial privacy disclaimers are visible where personal and transaction details are shown.",
            "status": "pending",
            "testStrategy": "Test flows using mocked payment status responses (success, failure, timeout/pending) to ensure correct screen is shown and actions behave as expected; print sample receipts to verify legibility, information completeness, and brand alignment across common paper sizes."
          }
        ]
      },
      {
        "id": 16,
        "title": "Design Accounts / Accounting Team dashboards",
        "description": "Create accounting-facing views for receivables, logs, receipts generation, and export-ready layouts for Tally integration.",
        "details": "• Accounts dashboard: KPIs for total receivables, collected, overdue, upcoming due this month; filter by vertical and period.\n• Receivables list: table with student, amount, due date, status, contact summary.\n• Payment logs: chronological record of transactions with filters (status, method, date range) and quick export actions.\n• Receipt management: ability to generate and view receipts under multiple heads; design for searching by student, receipt number.\n• Export-ready layout for Tally: a simplified, columnar view with only necessary accounting fields; explicit note to devs about CSV/XLS export.\n• Show audit filters: by hostel vertical, by fee component, by user role initiating adjustments.\n• Incorporate communication log links for invoices and reminders.\n• Ensure the dense data interface remains readable with alternating row backgrounds and frozen headers on long tables.",
        "testStrategy": "• Validate that all PRD-required elements (receivables dashboard, receipt generation, logs, exports) are present.\n• Simulate export by framing an example Tally-ready table and running it through a print/PDF check.\n• Review ease of scanning large tables on 1080p and 1366x768 resolutions.\n• Get feedback from finance stakeholders (if available) on terminology and grouping.",
        "priority": "high",
        "dependencies": [
          15,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Accounts Dashboard with KPIs and Filters",
            "description": "Create the main overview dashboard displaying key performance indicators for receivables, collections, overdue amounts, and upcoming dues, with filters for vertical and period selection.",
            "dependencies": [],
            "details": "Include cards for total receivables, collected, overdue, upcoming due this month; add dropdown filters for vertical (hostel) and date period; ensure responsive layout with alternating row backgrounds if tables are used.",
            "status": "pending",
            "testStrategy": "Validate KPI calculations with sample data; test filter functionality across different verticals and periods; check readability on 1080p and 1366x768 resolutions."
          },
          {
            "id": 2,
            "title": "Design Receivables List, Payment Logs, and Receipt Management",
            "description": "Design detailed list views for receivables with student details, chronological payment logs with filters and exports, and receipt generation/search interface.",
            "dependencies": [
              1
            ],
            "details": "Receivables table: student, amount, due date, status, contact summary; Payment logs: filters by status/method/date, quick export; Receipts: generate/view by student/receipt number under multiple heads, include communication log links.",
            "status": "pending",
            "testStrategy": "Prototype table scrolling with frozen headers; simulate export actions; test search functionality for receipts; ensure dense data readability with alternating backgrounds."
          },
          {
            "id": 3,
            "title": "Design Tally Export Layout and Audit Filters",
            "description": "Create simplified export-ready columnar view for Tally integration with necessary accounting fields, plus audit filters by hostel vertical, fee component, and user role.",
            "dependencies": [
              1,
              2
            ],
            "details": "Export layout: CSV/XLS with explicit dev notes on fields; add audit filters throughout views; incorporate notes for devs on export implementation and table optimizations like frozen headers.",
            "status": "pending",
            "testStrategy": "Simulate Tally export with example data via print/PDF; verify all PRD elements present; test audit filters across scenarios; review on multiple resolutions for scanability."
          }
        ]
      },
      {
        "id": 17,
        "title": "Design room allocation and check-in interfaces",
        "description": "Create admin and student views for room allocation, occupancy matrix, and check-in confirmation.",
        "details": "• Admin room matrix: grid view by floor/wing with rooms as cards or cells, showing capacity, occupied count, and gender/vertical labels.\n• Filters: by vertical (Boys/Girls/Dharamshala), occupancy status (empty, partial, full), room type.\n• Room detail side panel: list of current occupants, capacity, allocation/change actions, history of allocations.\n• Allocation flow: select student(s) → choose room → confirm allocation with confirmation modal and optional notes.\n• Student view: simple room details page with room number, sharing details (roommates names, beds), joining date, and house rules.\n• Check-in confirmation: design a one-time confirmation step where student acknowledges room condition/inventory and hostel rules.\n• Use status badges to represent occupancy (Available, Partially Occupied, Full, Blocked).\n• Provide guidance for dev data model: rooms table, occupancy records, and link to student profile.\n",
        "testStrategy": "• Prototype allocation of a new student to a room, including change-room action.\n• Validate that matrix remains usable with several dozen rooms; test horizontal/vertical scrolling behaviors.\n• Confirm that student-facing views show only their room, not others’ sensitive details.\n• Print sample room list for offline use to test legibility.",
        "priority": "medium",
        "dependencies": [
          3,
          9,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Admin Room Allocation Matrix and Filters",
            "description": "Create the grid view for rooms organized by floor/wing, including cards or cells displaying capacity, occupied count, gender/vertical labels, and status badges (Available, Partially Occupied, Full, Blocked). Implement filters for vertical, occupancy status, and room type.",
            "dependencies": [],
            "details": "Use responsive grid layout with hover effects for room cards; integrate side panel for room details on selection; ensure scalability for dozens of rooms with scrolling; provide dev guidance on rooms table and occupancy records linking to student profiles.",
            "status": "pending",
            "testStrategy": "Prototype matrix filtering and sorting; validate usability with 50+ rooms; test status badge accuracy against mock data."
          },
          {
            "id": 2,
            "title": "Design Room Detail Panel and Allocation Flow",
            "description": "Develop the side panel showing current occupants list, capacity, allocation/change actions, and allocation history. Design the allocation workflow: select student(s), choose room, confirm via modal with optional notes.",
            "dependencies": [
              1
            ],
            "details": "Include occupant profiles with names and beds; add buttons for allocate/change room; modal should summarize selection, show conflicts, and log notes; link to student profiles for quick selection.",
            "status": "pending",
            "testStrategy": "Prototype full allocation flow including multi-student selection and confirmation; test edge cases like over-capacity or blocked rooms."
          },
          {
            "id": 3,
            "title": "Design Student Room View and Check-in Confirmation",
            "description": "Create student-facing room details page with room number, roommates' names, beds, joining date, and house rules. Design one-time check-in confirmation screen for acknowledging room condition, inventory, and hostel rules.",
            "dependencies": [
              1
            ],
            "details": "Keep student view minimal and non-sensitive; use checklists or signatures for check-in; include printable confirmation; ensure integration with occupancy records update post-check-in.",
            "status": "pending",
            "testStrategy": "Prototype student view and check-in flow; validate privacy (no other rooms visible); test confirmation modal on mobile and desktop."
          }
        ]
      },
      {
        "id": 18,
        "title": "Design leave management module (student, superintendent, parent views)",
        "description": "Create strict-governance leave request and approval interfaces for all roles.",
        "details": "• Student leave UI: option cards for Short leave, Night-out, Multi-day leave; each opens a tailored form with dates, reason, destination, contact.\n• Show rules and policies prominently (e.g., minimum notice period, curfew).\n• Leave history list with statuses and remarks.\n• Superintendent leave dashboard: table of pending and past leaves with filters by type, status, date, and student.\n• Approve/Reject actions with required remarks, plus an embedded Send Message panel to inform students/parents.\n• Admin-configurable rules (from Task 12) surface as read-only summary on approval screen.\n• Parent view: read-only list of leaves for their ward, with status, dates, and notifications; optional confirmation that they were notified.\n• Clearly mark all dates and times; use calendar and time pickers from the design system.\n• Ensure audit log references (who approved, when) are visible to authorized staff.\n",
        "testStrategy": "• Prototype student: create request → view pending → see approved/rejected state.\n• Prototype superintendent: review → apply decision → trigger notification.\n• Check that parent screens show only their ward’s leaves and no actions.\n• Validate strictness of flows (no self-approval, no editing after approval) through stakeholder review in prototype.",
        "priority": "high",
        "dependencies": [
          12,
          14,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design student-facing leave request and history interfaces",
            "description": "Create detailed UI/UX for the student leave experience, including request creation for all leave types, rule visibility, and history views.",
            "dependencies": [],
            "details": "Design the student dashboard section for leave management with option cards for Short leave, Night-out, and Multi-day leave, each opening a tailored form capturing dates/times, reason, destination, and contact details. Ensure rules and policies (notice periods, curfew, limits) are prominently surfaced contextually near form actions. Define empty, loading, and error states for leave creation. Design a leave history list with clear status badges, remarks, and sorting/filtering by type and date. Integrate calendar and time picker components from the existing design system and ensure mobile responsiveness.",
            "status": "pending",
            "testStrategy": "Prototype a full student flow: create each leave type, review validation and rule messaging, then verify visibility and clarity of history entries and statuses."
          },
          {
            "id": 2,
            "title": "Design superintendent leave review, decision, and audit views",
            "description": "Define the superintendent-facing dashboard, review flows, decision actions, and audit visibility for leave governance.",
            "dependencies": [
              1
            ],
            "details": "Create a superintendent dashboard with tables for pending and past leaves, including filters by leave type, status, date range, and student. Design the leave detail/review screen with prominent display of request data, admin-configurable rules summary (read-only), and past decisions. Specify Approve/Reject flows with mandatory remarks, confirmation patterns, and clear state changes. Integrate an embedded Send Message panel to contact students and/or parents directly from the decision screen. Include visible audit log references (who approved/rejected, when, and key actions) for authorized staff, ensuring the layout supports strict-governance and non-editability after final decisions.",
            "status": "pending",
            "testStrategy": "Run through sample scenarios: filter and open a pending leave, approve with remarks and message, reject with remarks, and verify that audit entries are updated and immutable in UI while list and detail views stay consistent."
          },
          {
            "id": 3,
            "title": "Design parent-facing leave overview and notification confirmation views",
            "description": "Create read-only parent views for tracking their ward’s leaves and confirming notifications without granting approval powers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Design a parent leave overview screen showing a list of their ward’s leave requests only, with clear display of dates, times, type, status, and superintendent remarks. Ensure no action controls for creating, editing, or approving leave are present. Add patterns for notification indicators (e.g., tags or icons) and an optional lightweight confirmation UI for parents to acknowledge they have been notified, without affecting the approval state. Align visual language with broader notification/alert patterns from the project while maintaining strict access boundaries between parent and student data.",
            "status": "pending",
            "testStrategy": "Prototype a parent session: view multiple leave records for a single ward, verify absence of action controls, test the notification acknowledgment interaction, and confirm that data matches the student and superintendent views for the same leave records."
          }
        ]
      },
      {
        "id": 19,
        "title": "Design 6-month renewal module",
        "description": "Create renewal journey screens for reminders, document re-uploads, fee top-up, consent renewal, and simplified approvals.",
        "details": "• Student renewal entry: card on dashboard and dedicated page when renewal window is open; show remaining days and benefits of timely renewal.\n• Renewal steps: 1) Review personal/academic info, 2) Re-upload updated certificates/marksheets, 3) Fee top-up, 4) Renewal consent, 5) Submit.\n• Integrate payment UI for top-up (reuse patterns from Task 15).\n• Include DPDP consent renewal prompt with explicit text and checkboxes.\n• Show renewal status tracker (Not started → In Progress → Under Review → Approved → Rejected).\n• Superintendent/Trustee renewal list: simplified view vs original admission with quick decisions.\n• Notifications: design subtle banners/alerts for upcoming renewal (e.g., at 30/15/7 days) in dashboards.\n• Ensure that after successful renewal, status on Student Dashboard updates to \"Renewed\" with new end date.\n",
        "testStrategy": "• Prototype full student renewal process including payment and consent steps.\n• Validate that required re-upload of documents is clearly indicated and cannot be bypassed.\n• Test scenarios: early renewal, last-minute renewal, missed deadline.\n• Confirm that renewal approval screens for admins are simpler yet aligned with governance needs.",
        "priority": "high",
        "dependencies": [
          9,
          11,
          15,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design renewal entry points and notification surfaces across dashboards",
            "description": "Define where and how students discover the 6‑month renewal journey, and how time-based reminders appear in student and admin dashboards.",
            "dependencies": [
              19,
              9,
              12
            ],
            "details": "Map all UI entry points: dashboard renewal card, dedicated renewal page, and deep links from notifications. Specify frames for: (a) default dashboard with no active window, (b) dashboard when renewal window is open with remaining days and benefit messaging, (c) banners/alerts for upcoming renewal at 30/15/7 days, and (d) post-renewal dashboard showing updated status and new end date. Enumerate states such as eligible, not-yet-open, open, closed, and renewed. Document dependencies on notification/communications module and existing dashboard layouts from earlier tasks so layout and tone stay consistent.",
            "status": "pending",
            "testStrategy": "Validate that a student can always find a clear entry to renewal during the open window and that notifications appear in the right time windows without overlapping or cluttering other dashboard components."
          },
          {
            "id": 2,
            "title": "Design student renewal wizard steps and UI, including document re-upload",
            "description": "Create the multi-step student renewal flow with clear progression, data review, and required document re-uploads.",
            "dependencies": [
              1,
              11,
              19
            ],
            "details": "Define frames for each wizard step: (1) review personal and academic information, (2) mandatory and optional document re-upload screen for updated certificates/marksheets, (3) confirmation review step before payment and consent, and (4) final summary. For each step, list states: pristine, validation errors, saving, and success. Integrate document handling patterns from Task 11 for upload, preview, and status chips. Define navigation behaviors (next/back, autosave, resume later) and guardrails preventing skipping required uploads. Document dependencies on core profile data modules and document-management components so information is read-only where needed and edits are constrained.",
            "status": "pending",
            "testStrategy": "Run through end-to-end wizard prototypes verifying that each step validates correctly, documents can be re-uploaded and previewed, and that users cannot submit renewal without completing required sections."
          },
          {
            "id": 3,
            "title": "Integrate payment top-up UI using Task 15 patterns within renewal flow",
            "description": "Embed fee top-up and payment confirmation within the renewal wizard using existing payment design patterns.",
            "dependencies": [
              2,
              15,
              16,
              19
            ],
            "details": "Specify frames for the payment step: fee breakdown, selectable payment methods, charges summary, and confirmation screen. Reuse layouts, components, and error states defined in Task 15 for payment initiation, progress, success, and failure. Capture states for: pending calculation, payment in progress, success, failure with retry, and partial payment (if supported). Define how payment outcomes affect the wizard state (lock next steps until success, or allow exit-and-resume). Document integrations and data surfaces needed for Accounts dashboards from Task 16, including how receipts and logs will appear post-payment.",
            "status": "pending",
            "testStrategy": "Simulate payments with mock states (success, failure, timeout) ensuring UI feedback is clear, amounts match upstream fee rules, and payment records surface correctly for Accounts views."
          },
          {
            "id": 4,
            "title": "Design consent renewal UX including DPDP-compliant text and controls",
            "description": "Create the dedicated consent renewal experience with explicit DPDP wording and clear user choices.",
            "dependencies": [
              2,
              5,
              11,
              19
            ],
            "details": "Define frames for the consent step: initial consent screen with DPDP summary text, detailed policy access, and checkboxes for specific consents; error states where consent is not given or incomplete; and confirmation of recorded consents. Ensure copy and patterns align with earlier DPDP treatments from Tasks 5 and 11. Specify how the consent step links to the overall wizard (block submission until required consents are checked, show tooltips or inline help). Capture states for first-time consent vs renewal of previously given consent and show historical consent reference where needed.",
            "status": "pending",
            "testStrategy": "Review consent copy with compliance stakeholders, test flows where users partially consent or refuse, and verify that renewal cannot be completed without mandatory DPDP consents while optional consents behave as configured."
          },
          {
            "id": 5,
            "title": "Define renewal status tracking UI and student-facing lifecycle states",
            "description": "Design how students see and understand the status of their renewal across its lifecycle.",
            "dependencies": [
              1,
              2,
              3,
              4,
              19
            ],
            "details": "Specify frames for the renewal tracker component: inline widget on dashboard, full-width tracker on the renewal page, and compact status chip versions. Enumerate and visually differentiate states: Not started, In Progress, Under Review, Approved, Rejected, and any payment-pending or docs-pending intermediates. Define transitions triggered by student actions (submit, edit) and admin decisions. Ensure that after approval, the student dashboard clearly shows status as Renewed with the new end date. Document dependencies on backend status codes and existing status-badge components to keep naming and color semantics consistent.",
            "status": "pending",
            "testStrategy": "Walk through sample timelines from creation to approval/rejection confirming the UI always shows the correct current state, prevents contradictory statuses, and updates immediately following simulated backend changes."
          },
          {
            "id": 6,
            "title": "Design admin renewal review and decision flows (Superintendent/Trustee)",
            "description": "Create simplified admin views for reviewing and deciding on renewals compared to full admission workflows.",
            "dependencies": [
              2,
              3,
              5,
              11,
              19
            ],
            "details": "Define frames for Superintendent/Trustee renewal lists: list view with filters, compact cards, and key columns (student, due date, status, flags). Design a simplified detail/review screen highlighting only renewal-relevant data: updated documents, fee payment confirmation, consent status, and prior year data snapshot. Specify decision actions (quick approve, reject with reasons, send back for correction) and corresponding confirmation or error states. Compare and document differences from full admission review screens so the UX is lighter but still auditable. Capture dependencies on roles/permissions, document verification flows from Task 11, and accounting data from Tasks 15 and 16 for fee verification.",
            "status": "pending",
            "testStrategy": "Test sample admin journeys where multiple renewals are processed in bulk and individually, confirming that decisions correctly update student-facing status trackers and that minimal but sufficient information is available for safe decisions."
          },
          {
            "id": 7,
            "title": "Map edge-case renewal flows (early, last-minute, missed) and messaging",
            "description": "Design UI states and messages for atypical renewal timings including early, last-minute, and missed renewals.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              19
            ],
            "details": "Enumerate edge-case scenarios: early renewals before standard window, renewals submitted in the final days or hours, and renewals attempted after the window closes. For each, define frames and banner states on dashboards and in the wizard: eligibility warnings, urgency prompts, and post-deadline information (e.g., escalation path or appeal process if any). Specify behavior for partially completed renewals when the window closes, including what students see and what admins can do. Align all messaging tone with program policy and ensure no conflicting calls to action appear across surfaces. Document dependencies on scheduling/notification logic and policy rules from product and legal teams.",
            "status": "pending",
            "testStrategy": "Run scenario-based tests walking through each edge case using dated test data, verifying correct access rules, messaging, and handoffs between student and admin views, including how missed renewals are communicated and recorded."
          }
        ]
      },
      {
        "id": 20,
        "title": "Design exit and alumni module",
        "description": "Create UI for exit requests, clearance checklist, exit approval, exit certificate, and migration to alumni state.",
        "details": "• Student: Exit request form detailing desired exit date, reason, and forwarding address; show conditions and implications (fees, deposits).\n• Clearance checklist: items like room inventory check, key return, ID card return, accounts clearance; show statuses (Pending/Completed) for each.\n• Superintendent/Accounts: clearance dashboard summarizing pending tasks per exiting student and actions to mark them completed.\n• Exit approval screen: once all checklist items are cleared, allow final approval with remarks.\n• Exit certificate: design print-ready certificate including name, vertical, stay period, conduct (if applicable), and signatures.\n• Alumni migration: on approval, update student status to Alumni; design a simple alumni profile view with contact and history summary.\n• Add links to communication history and financial settlement in admin views.\n",
        "testStrategy": "• Prototype: student raises exit request → admin completes checklist → approves → student downloads certificate.\n• Print exit certificate mock to verify legibility and brand alignment.\n• Confirm no editing of exit records after final approval to preserve audit trail (at least in UI behavior).\n• Review with stakeholders for completeness of checklist items and certificate content.",
        "priority": "medium",
        "dependencies": [
          17,
          16,
          11,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design student exit request flow and implication messaging",
            "description": "Design the end-to-end student exit request experience, including form fields, guidance copy, and clear explanation of conditions, fees, deposits, and irreversible consequences.",
            "dependencies": [],
            "details": "Map the student journey from discovering the exit option on their dashboard through filling the request form (desired exit date, reason, forwarding address, preferred contact) and submitting it. Include inline help and a dedicated info section summarizing implications: possible forfeiture or adjustment of deposits, fee proration rules, loss of hostel access, and timeline expectations. Clearly differentiate editable vs non-editable fields after submission, and support a limited pre-approval edit/cancel window with explicit warnings before lock-in. Surface a visible status badge for the current exit state (Draft, Submitted, Under Clearance, Approved, Rejected/Withdrawn) and log all key actions (created, edited, canceled, submitted) with timestamp and actor in an audit trail panel that is read-only for admins and view-only for the student. Ensure irreversible transitions (e.g., from Submitted to Under Clearance) require confirmation dialogs that mention their audit-logged nature and that future changes must go through admin roles.",
            "status": "pending",
            "testStrategy": "Prototype the full student flow: create draft → edit → submit → attempt edit after lock → cancel within allowed window. Verify audit log entries are created for each action and remain visible even after state changes, and that irreversible transitions cannot be bypassed via alternative navigation paths."
          },
          {
            "id": 2,
            "title": "Design clearance checklist UI and cross-role status tracking",
            "description": "Create a structured, role-aware clearance checklist interface showing item-level statuses, ownership, and history for each exiting student.",
            "dependencies": [
              1
            ],
            "details": "Define the canonical checklist items (room inventory, key return, ID card return, accounts clearance, library dues, any custom items) as rows in a unified checklist view attached to the exit request. For each item, show owner role, current status (Pending, In Progress, Completed, Waived), last updated timestamp, and optional remarks. Allow role-based interaction: students see read-only statuses and any student-facing instructions; admins and specific departments can update only their owned items. Capture every change as an immutable audit entry (previous status, new status, remarks, actor, timestamp) and expose this via an expandable history per item. Visually signal when all mandatory items are completed and which items are blocking final approval. Design safeguards for irreversible status changes (e.g., Completed → revert) by either disallowing reversal in the primary UI or gating it behind an elevated override pattern with justification and separate audit tagging.",
            "status": "pending",
            "testStrategy": "Test with sample roles (student, superintendent, accounts) updating multiple checklist items and confirm visibility rules, status accuracy, and that all changes appear in per-item history. Attempt invalid operations (student editing statuses, cross-role edits) and verify they are blocked. Validate that once an item is marked Completed, UI reversal flows either do not exist or clearly request justification and log enhanced audit data."
          },
          {
            "id": 3,
            "title": "Design superintendent and accounts clearance dashboards and workflows",
            "description": "Create admin-facing dashboards that summarize pending exit-related tasks, support efficient processing, and expose audit-safe task handling patterns.",
            "dependencies": [
              2
            ],
            "details": "Design separate but consistent dashboards for superintendent and accounts roles, listing exiting students with key attributes (name, room, vertical, requested exit date, overall clearance progress, aging). Provide filters (by hostel, date range, progress state) and sort options (oldest requests first, high-risk cases). Include quick actions to open a student’s clearance detail view and mark owned checklist items as completed, with mandatory remarks where appropriate. Integrate compact views of communication history and financial settlement links so admins can reference context without leaving the workflow. All dashboard actions that change state must route through the same underlying checklist update patterns, ensuring comprehensive audit logging. Irreversible operations (e.g., mass-complete multiple items, closing an old request) should require confirmation, display impact (number of students/items affected), and be highlighted in audit logs as bulk operations for later review.",
            "status": "pending",
            "testStrategy": "Simulate typical admin workflows: triage by filters, open a case, update multiple checklist items, and close a batch of older cases. Verify that dashboard counts match individual student views, that every state-changing action generates a traceable log entry, and that bulk actions correctly log affected records. Run through least-privilege tests ensuring each role only sees and acts on its permitted scope."
          },
          {
            "id": 4,
            "title": "Design exit approval screen and audit-safe finalization patterns",
            "description": "Define the final approval interface and associated patterns to ensure safe, irreversible transition from active resident to exited status with strong audit guarantees.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create an approval screen that summarizes student details, requested exit parameters, full checklist with statuses, financial settlement summary, and any unresolved warnings. Disable the final approval action until all mandatory checklist items and financial requirements are satisfied or explicitly waived with justification. On approval, trigger a clearly marked irreversible transition that locks editing of the exit record and checklist while still allowing read-only viewing by authorized roles. Require explicit confirmation (modal) that outlines consequences: student will no longer be treated as active resident, certain features will be disabled, and data becomes part of permanent records. Capture structured approval metadata (approver role, name, timestamp, remarks, device/IP if available) and present it as the final entry in the audit log. Provide a narrowly scoped post-approval override pattern (e.g., admin-of-admins) for exceptional reversals that is visually distinct, requires detailed justification, and creates a prominent audit entry referencing the original approval.",
            "status": "pending",
            "testStrategy": "Walk through approval scenarios: fully compliant case, case with missing checklist item, and case requiring a waiver. Confirm that finalization cannot proceed with unresolved blockers and that once approved, all editing controls disappear while data remains viewable. Execute an exceptional reversal using the override role and check that both the approval and reversal are clearly recorded and chronologically ordered in the audit log."
          },
          {
            "id": 5,
            "title": "Design exit certificate template and download/print flow",
            "description": "Create a print-ready, branded exit certificate layout and the associated UI for generation, viewing, downloading, and printing with proper version control.",
            "dependencies": [
              4
            ],
            "details": "Define a certificate template with institution branding, student identity details, vertical, stay period, conduct statement (if applicable), approval date, and authorized signatures/ seals. Ensure layout is optimized for A4 printing with safe margins and high-contrast typography. In the UI, make certificate generation available only after final approval, with a one-click action that generates a versioned PDF snapshot of the exit record at that time. Prevent editing of certificate content by rendering from immutable data captured at approval; if post-approval corrections are necessary, require a controlled re-issue flow that stores both the old and new versions with reasons. Provide clear controls for viewing online, downloading, and printing, and include a small footer with version number or hash and generation timestamp to support audit verification. Log every certificate generation and download event with actor, timestamp, and version, accessible to admins in an audit panel.",
            "status": "pending",
            "testStrategy": "Print sample certificates (including re-issued ones) to verify layout consistency, legibility, and presence of all required fields. Test generation immediately after approval and after a later correction to confirm that versioning works and historical certificates remain accessible. Track multiple downloads by different roles and ensure each event is logged and retrievable in audit views."
          },
          {
            "id": 6,
            "title": "Design alumni state transition and minimal alumni profile views with history links",
            "description": "Define the migration from resident to alumni status and design concise alumni profile views with access to key historical records and clear treatment of irreversible state.",
            "dependencies": [
              4,
              5
            ],
            "details": "Specify that upon final exit approval, the system transitions the student to an Alumni status and removes them from active resident lists while retaining a linked alumni record. Design a minimal alumni profile page showing core identity details, contact information, stay history summary, exit certificate access, and links to communication history and financial settlement records. Make the alumni status visually distinct from active residents across the system (badges, filters) and ensure alumni records are read-only except for allowed fields like updated contact info, which should be logged when changed. Treat the resident→alumni transition as fundamentally irreversible in standard workflows; any return to resident-like status must follow a separate re-admission process rather than toggling flags. Reflect the transition in an audit trail entry capturing who triggered it (usually automated from approval), when, and from which prior status. Provide filter and search options for admins to locate alumni, and ensure that alumni data is covered by data retention and governance rules surfaced in design notes.",
            "status": "pending",
            "testStrategy": "Simulate an end-to-end journey from active resident to alumni, verifying that the user disappears from active views and appears in alumni lists with the correct status and profile. Test updates to allowed alumni fields and confirm they generate audit entries. Attempt to revert alumni back to active using normal admin roles and confirm that it is blocked, forcing use of the defined re-admission path if needed, and verify that alumni history links (communications, financials, certificate) open read-only records."
          }
        ]
      },
      {
        "id": 21,
        "title": "Design audit, logs, and compliance screens",
        "description": "Create comprehensive audit interfaces for communication logs, approvals, consent tracking, and DPDP compliance elements.",
        "details": "• Communication logs: table listing WhatsApp/SMS/Email communications with columns for date/time, sender role, recipient(s), channel, status (sent, failed), and context (fee, interview, leave).\n• Approval history: show records per application/leave/payment/renewal with authority, decision, date/time, and remarks.\n• Consent & undertaking logs: dedicated view listing each consent type (hostel rules, DPDP, parent consent, etc.) with timestamps and method (digital/physical upload).\n• DPDP compliance UI elements:\n  - Persistent but unobtrusive banners/links to data policy.\n  - Data retention information page.\n  - Consent renewal prompts surfaced in renewal module and first logins.\n• Filtering options by date range, vertical, role, channel, and entity type.\n• Emphasize read-only nature of logs; no destructive edits through UI.\n• Provide dev notes: logs tables expected to be large; suggest server-side pagination and export options in guidelines.\n",
        "testStrategy": "• Cross-check log screen requirements with all modules that generate audit entries.\n• Prototype drill-down from specific student/application to a filtered audit view.\n• Validate that DPDP banners and consent info are accessible from login screens and account settings.\n• Run UX review to ensure logs remain usable even with many filters and high data density.",
        "priority": "high",
        "dependencies": [
          14,
          12,
          13,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Communication and Approval Logs Tables",
            "description": "Create table-based interfaces for communication logs (WhatsApp/SMS/Email with columns: date/time, sender role, recipient(s), channel, status, context) and approval history (per application/leave/payment/renewal with authority, decision, date/time, remarks).",
            "dependencies": [],
            "details": "Include server-side pagination for large datasets, read-only emphasis via visual cues (no edit buttons), filtering by date range, vertical, role, channel, entity type. Add export options (CSV/PDF) with dev notes on implementation.",
            "status": "pending",
            "testStrategy": "Prototype tables with sample data; test filters, pagination, export on desktop/mobile; validate read-only behavior prevents accidental edits."
          },
          {
            "id": 2,
            "title": "Design Consent and Undertaking Logs View",
            "description": "Build dedicated read-only view listing consent types (hostel rules, DPDP, parent consent, etc.) with timestamps, method (digital/physical upload), and filtering options.",
            "dependencies": [
              1
            ],
            "details": "Use card or table layout for consents per entity; integrate filters matching other logs; highlight timestamps and methods prominently; ensure linkage to related entities like students/applications.",
            "status": "pending",
            "testStrategy": "Test drill-down from student profiles to filtered consents; verify completeness across modules (e.g., registration, renewal); UX review for scannability."
          },
          {
            "id": 3,
            "title": "Design DPDP Compliance UI Elements and Integration",
            "description": "Implement persistent banners/links to data policy, data retention info page, consent renewal prompts in renewal module/first logins, with read-only audit access.",
            "dependencies": [
              1,
              2
            ],
            "details": "Make banners unobtrusive (footer or subtle top bar); design info page with clear sections on retention policies; prompts as modals/checkboxes with explicit text; integrate into Tasks 5,19 navigation.",
            "status": "pending",
            "testStrategy": "Validate accessibility from login/settings/renewal; cross-check with PRD for DPDP elements; simulate consent renewal flow; stakeholder review for compliance visibility."
          }
        ]
      },
      {
        "id": 22,
        "title": "Design future-proofing placeholders for biometric, visitor, and mess management",
        "description": "Create visual placeholders for future modules without functional logic but aligned with IA and branding.",
        "details": "• Add navigation items or dashboard cards labeled **Biometric Attendance**, **Visitor Management**, **Mess Management** in relevant admin and student views, styled as \"Coming Soon\".\n• Design simple placeholder screens with iconography and short description of planned functions, ensuring they do not confuse users into expecting current functionality.\n• Use consistent pattern (e.g., greyed-out cards, lock icons) and tooltips to indicate non-availability.\n• Clearly indicate in style guide how devs should treat these placeholders (hidden behind feature flags or static informational pages).\n• Ensure placeholders do not interfere with primary workflows or clutter navigation excessively.\n",
        "testStrategy": "• Verify placeholders appear where requested in PRD but do not provide active actions.\n• Test on mobile that \"Coming Soon\" messaging is legible and not mistaken for an error.\n• Review IA to ensure future modules are logically grouped.\n• Obtain stakeholder sign-off that placeholders don’t create false expectations.",
        "priority": "low",
        "dependencies": [
          3,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define IA placement and interaction rules for future module placeholders",
            "description": "Analyze existing information architecture to decide where Biometric Attendance, Visitor Management, and Mess Management should appear in admin and student views and specify how they should be accessed as non-functional entries.",
            "dependencies": [],
            "details": "Review current navigation, dashboards, and role-based views to identify logical positions for the three future modules without disrupting core workflows. Specify whether each will appear as a nav item, dashboard card, or both for each role. Document click behavior (e.g., opens static info screen only, no CTAs), and define rules for when they are visible or hidden (e.g., feature flags, environment settings). Capture these decisions in the IA/route map so devs can wire routes and flags consistently later.",
            "status": "pending",
            "testStrategy": "Cross-check final IA map against PRD to ensure all three modules are represented in the right sections and that no flows require active functionality from these entries."
          },
          {
            "id": 2,
            "title": "Design consistent UI pattern and copy for ‘Coming Soon’ placeholders",
            "description": "Create the visual and content system for placeholder cards and screens for the three modules, ensuring clarity that features are not yet available and alignment with brand guidelines.",
            "dependencies": [
              1
            ],
            "details": "Design card states (e.g., greyed-out, low emphasis, lock or clock icon) for Biometric Attendance, Visitor Management, and Mess Management with a unified style. Create corresponding placeholder screens with iconography, short description of intended capabilities, and explicit ‘Coming Soon / Not yet available’ messaging. Define tooltip and helper text patterns that clarify non-availability and avoid any impression that an error occurred. Ensure typography, spacing, colors, and icons follow the existing design system and accessibility rules. Provide Figma components or similar reusable assets for placeholders.",
            "status": "pending",
            "testStrategy": "Run quick usability checks or stakeholder reviews on mockups to confirm users interpret these elements as future features, not broken links or active modules, and verify visual consistency with the existing design system."
          },
          {
            "id": 3,
            "title": "Document implementation guidelines and constraints in the style guide",
            "description": "Extend the design/style guide with explicit guidance on how developers should implement and manage the future-proofing placeholders for the three modules.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add a dedicated section to the style guide that documents when and where to use placeholder cards and screens, including examples for Biometric Attendance, Visitor Management, and Mess Management. Specify technical treatment expectations: use of feature flags vs. static pages, routing behavior, analytics tracking (if any), and rules for hiding/removing placeholders in certain deployments. Clarify non-interference requirements (no blocking primary tasks, minimal nav clutter) and do/don’t examples. Include redlines and component specs so devs can implement without additional clarification.",
            "status": "pending",
            "testStrategy": "Review the updated style guide with design and engineering leads to ensure the instructions are unambiguous, feasible for implementation, and cover all three modules and environments (web/mobile)."
          }
        ]
      },
      {
        "id": 23,
        "title": "Design accessibility, help, and error handling patterns",
        "description": "Create consistent UX for tooltips, inline help, progress indicators, confirmation modals, and error states aligned with WCAG.",
        "details": "• Define standard patterns for:\n  - Tooltips (icon, hover/focus behavior).\n  - Inline help text below form fields.\n  - Visual progress indicators (steppers, loaders, skeletons) for long operations.\n  - Confirmation modals for irreversible actions (reject, final approval, exit, delete documents).\n  - Error banners and inline field errors.\n• Ensure color use and focus states meet WCAG 2.1 AA; include keyboard navigation guidance in design notes.\n• Add a compact help center pattern: small \"?\" icon linking to contextual help or FAQ per page.\n• Document guidelines for error messaging tone: formal, clear, non-technical.\n• Provide pseudo-code for devs on focus management:\n  - Move focus to error summary on form submission failure.\n  - Return focus to triggering element on modal close.\n• Include patterns for empty states that instruct users how to proceed.\n",
        "testStrategy": "• Apply these patterns on at least 3 key flows (application wizard, payment, leave) in the prototype.\n• Use accessibility plugins/checklists in Figma to review text size, color contrast, and focus cues.\n• Conduct keyboard-only walkthrough in prototype (Tab/Enter/Esc) to simulate behavior.\n• Review error copy with stakeholders for tone and clarity.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define accessible UI patterns for help, progress, errors, and empty states",
            "description": "Create detailed, WCAG-aligned design specs for tooltips, inline help, progress indicators, confirmation modals, error banners/inline errors, and empty states.",
            "dependencies": [],
            "details": "Document component-level patterns covering: tooltip trigger icon and label, hover/focus behavior, dismissal, and ARIA usage; inline help placement, wording, and interaction; visual progress indicators including steppers, loaders, and skeletons with text alternatives; confirmation modal structure for irreversible actions with clear primary/secondary actions and warnings; error banners and inline field errors with clear copy, iconography, and associations to fields; empty states that explain next steps and link to primary actions. Ensure consistency with existing design system tokens and component library.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Specify accessibility, color, focus, and keyboard interaction guidelines",
            "description": "Define cross-component accessibility rules for color contrast, focus states, keyboard navigation, and context-sensitive help patterns.",
            "dependencies": [
              1
            ],
            "details": "Write WCAG 2.1 AA–aligned guidelines for minimum contrast ratios, focus ring styles, and state changes for all relevant components. Define keyboard behavior for tooltips, progress steppers, modals (open/close, trap focus, escape handling), banners, and inline errors. Include rules for logical tab order and visible focus. Design and document the compact help center pattern using a small \"?\" icon that is reachable by keyboard, has accessible name/tooltip, and links to contextual help or FAQ per page.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Document error messaging tone and focus management pseudo-code for developers",
            "description": "Produce implementation-oriented guidance for error messaging style and focus handling across forms and modals.",
            "dependencies": [
              1,
              2
            ],
            "details": "Write tone guidelines for error, warning, and help messages (formal, clear, non-technical, action-oriented), including examples for banners, inline errors, and confirmation modals. Provide pseudo-code and interaction notes for focus management, covering: moving focus to an error summary region on form submission failure; setting focus on first errored field when appropriate; trapping and restoring focus for modals; returning focus to the triggering element on modal close. Align documentation with existing coding standards so devs can integrate patterns consistently.",
            "status": "pending",
            "testStrategy": null
          }
        ]
      },
      {
        "id": 24,
        "title": "Define responsive layout grids and breakpoints for all screen types",
        "description": "Standardize grid systems and breakpoints for desktop, tablet, and mobile layouts to ensure consistency.",
        "details": "• Define breakpoint strategy (e.g., Desktop ≥ 1200px, Tablet 768–1199px, Mobile ≤ 767px) and document it in the design system.\n• For each breakpoint, set column grids (e.g., 12-col for desktop, 8 for tablet, 4 for mobile) with defined gutters and margins.\n• Apply grids consistently to key screen templates: dashboards, tables, forms, modals, print views.\n• Use Figma layout grids and constraints to make components responsive; test resizing behavior.\n• Provide implementation notes for devs mapping Figma grids to CSS frameworks (e.g., CSS Grid/Flexbox, or libraries like MUI/Bootstrap if used).\n• Document maximum content width for readability (e.g., ~1200px) and behavior on very wide monitors.\n",
        "testStrategy": "• Check that all major frames use the defined grids and no ad-hoc grids exist.\n• Manually resize multiple screens to test responsive behavior and component wrapping.\n• Review on simulated devices (Figma preview) to confirm consistent spacing.\n• Get dev feedback on feasibility of mapping grids to CSS layout utilities.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and document responsive breakpoint strategy in design system",
            "description": "Establish the canonical breakpoint ranges for mobile, tablet, and desktop (and any extra-large or orientation-specific states) and document them clearly in the design system.",
            "dependencies": [
              1,
              2,
              24
            ],
            "details": "• Analyze current and target devices to finalize breakpoint ranges (e.g., mobile ≤767px, tablet 768–1199px, desktop ≥1200px, plus any XL/landscape variants if needed).\n• Decide naming convention for breakpoints (e.g., xs/sm/md/lg/xl or mobile/tablet/desktop).\n• Create a dedicated section in the Figma design system file and design docs describing each breakpoint, its pixel range, intended usage, and example layouts.\n• Add example Figma frames per breakpoint (blank shells) labeled with viewport size and constraints for later reuse.\n• Ensure breakpoint definitions align with or can be mapped to front-end tokens or CSS media query variables used by engineering.",
            "status": "pending",
            "testStrategy": "• Review breakpoint list with design and dev leads to confirm feasibility and alignment with front-end media queries.\n• Check that the design system documentation includes explicit ranges, names, and example frames for each breakpoint.\n• Validate no conflicting or duplicate breakpoint definitions exist in previous files or specs."
          },
          {
            "id": 2,
            "title": "Define grid systems (columns, gutters, margins) and map to spacing/typography tokens per breakpoint",
            "description": "Specify the column grids, gutters, and margins for each breakpoint and connect them to existing spacing and typography tokens in the design system.",
            "dependencies": [
              1,
              24
            ],
            "details": "• For each breakpoint, define grid specs: number of columns (e.g., 12 for desktop, 8 for tablet, 4 for mobile), gutter width, and outer margins.\n• Map grid spacing (gutters/margins) to existing spacing tokens from Task 1 (e.g., 16/24/32px) and ensure typographic line lengths support readability (e.g., max content width ~1200px).\n• Create Figma layout grid styles per breakpoint and save them as reusable named styles (e.g., Grid/Desktop/12col).\n• Document how typography scales across breakpoints (e.g., heading size adjustments, line-height, and content width recommendations).\n• Include visual examples: one or two simple content layouts per breakpoint that demonstrate proper column usage and spacing alignment to tokens.",
            "status": "pending",
            "testStrategy": "• Apply each grid style to sample frames at each breakpoint and verify columns, gutters, and margins match the documented values.\n• Check that spacing units visible in redlines align with design tokens (no ad-hoc values).\n• Confirm max content width and line length meet readability goals when previewed at common device sizes."
          },
          {
            "id": 3,
            "title": "Apply grids and constraints to key templates in Figma with example frames",
            "description": "Use the defined grids to build key screen templates (dashboards, tables, forms, modals, print views) and set up Figma layout constraints and resizing behavior for each breakpoint.",
            "dependencies": [
              1,
              2,
              24
            ],
            "details": "• Create base template frames for each key screen type (dashboards, data tables, forms, modals, print views) at mobile, tablet, and desktop breakpoints.\n• Apply the appropriate Figma layout grid style to each frame and ensure components snap to columns and respect gutters/margins.\n• Configure Figma constraints and Auto Layout so core components (nav, sidebars, content area, modals) resize and reflow correctly on frame width changes.\n• Include at least one annotated example frame per template/breakpoint combination showing column spans, content width, and stacking rules.\n• Define simple rules for component behavior across breakpoints (e.g., sidebar collapses, table columns stack or scroll, form fields move from multi-column to single-column).",
            "status": "pending",
            "testStrategy": "• Manually resize each template frame in Figma and verify that components remain aligned to the grid and behave according to defined rules.\n• Check that all key templates use only the standardized grid styles (no local grid overrides).\n• Review example frames with at least one other designer to confirm clarity and consistency of grid usage."
          },
          {
            "id": 4,
            "title": "Align with developers on grid implementation and validate via responsive tests",
            "description": "Document how Figma grids map to CSS Grid/Flexbox or chosen UI libraries, and run joint validation using resizing tests and device previews.",
            "dependencies": [
              1,
              2,
              3,
              24
            ],
            "details": "• Document mapping from each breakpoint and grid spec to front-end implementation (e.g., CSS Grid template columns, Flexbox wrappers, or MUI/Bootstrap grid props).\n• Provide example code snippets or pseudo-code for common layouts (dashboard with sidebar, form page, data table) reflecting the agreed column counts and breakpoints.\n• Walk through the grid and breakpoint documentation with dev leads to confirm naming, token mapping, and feasibility within the existing tech stack.\n• Run responsive checks on interactive prototypes or staged builds, comparing behavior to Figma example frames for each breakpoint.\n• Capture any deviations or constraints from engineering and update design guidelines and example frames accordingly.",
            "status": "pending",
            "testStrategy": "• Cross-check breakpoints and column counts in CSS or UI library configuration against the design system specs.\n• Test real or prototype pages in browser dev tools across a range of viewport widths to ensure layouts switch at the correct breakpoints and match Figma examples.\n• Collect developer feedback on implementation clarity and adjust documentation until no ambiguities remain."
          }
        ]
      },
      {
        "id": 25,
        "title": "Create clickable end-to-end prototype for primary user journeys",
        "description": "Link key screens in Figma into an interactive prototype covering major flows for each role.",
        "details": "• Journeys to include:\n  - Applicant: Landing → OTP → Application Wizard → Tracking.\n  - Student: Login → Dashboard → Pay Fees → Apply for Leave → Check Room → Renewal → Exit.\n  - Superintendent: Login → Application Review → Approve/Forward → Leave Approval → Config.\n  - Trustee: Review forwarded app → Schedule Interview → Final Decision.\n  - Accounts: View receivables → Export.\n  - Parent: OTP Login → View fees and leaves.\n• Use Figma prototype connections with smart animate where suitable for smooth transitions.\n• Add hotspot hints and annotations on a separate overlay frame or page for stakeholders to understand flows.\n• Ensure variants and component states (hover, focused, error) are demonstrated where relevant.\n• Configure starting points for each persona for easy testing in user sessions.\n",
        "testStrategy": "• Walk through all defined journeys end-to-end and fix any dead links or wrong transitions.\n• Share prototype with 2–3 stakeholders per role and gather feedback on navigation and flow.\n• Verify that transitions work on desktop and mobile previews.\n• Ensure performance of prototype is acceptable (no excessive nesting causing lag).",
        "priority": "high",
        "dependencies": [
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define prototype architecture, flows, and entry points per persona",
            "description": "Map all personas to their full journey, group relevant frames, and configure Figma flow starting points for each role.",
            "dependencies": [],
            "details": "Create a prototype architecture map listing Applicant, Student, Superintendent, Trustee, Accounts, and Parent flows and their exact frame sequences. Group frames into labeled sections per persona, define which screen is the starting frame for each journey, and set named Figma flows (e.g., “Applicant – Application Wizard,” “Student – Renewal & Exit”). Note cross-journey links (e.g., from Landing to Parent OTP, Student Login, Applicant start). Specify where device type and viewport settings differ between desktop and mobile. Document which frames will be reused across flows and where role-based variants of a screen are needed.",
            "status": "pending",
            "testStrategy": "In Figma, use the Flow list to verify each persona has a distinct named starting point and that pressing Present from each flow starts on the intended frame without showing other journeys by default."
          },
          {
            "id": 2,
            "title": "Wire applicant journey interactions and component states",
            "description": "Implement prototype connections for the Applicant flow: Landing → OTP → Application Wizard → Tracking, including stateful component variants.",
            "dependencies": [
              1
            ],
            "details": "On the Applicant journey frames, connect primary CTAs and form actions from Landing to OTP entry, OTP verification success, and error/retry states, then into the multi-step Application Wizard and final Tracking view. Use Smart Animate between steps where UI elements persist (e.g., header, progress, form container) to show smooth transitions. Demonstrate interactive component variants for buttons (default, hover, disabled, loading), text fields (empty, focused, filled, error), steppers/progress indicators (step changes), and status badges on the Tracking screen. Ensure back, cancel, and resume actions navigate correctly without dead ends and that failure paths (invalid OTP, required-field errors) are represented with at least one dedicated frame each.",
            "status": "pending",
            "testStrategy": "Run the Applicant flow in Present mode, clicking through both success and error paths. Confirm: all CTAs navigate to the correct next step, Smart Animate is applied where elements persist, and each important component shows at least one interactive or variant-driven state (focus, error, hover, disabled)."
          },
          {
            "id": 3,
            "title": "Wire student journey interactions and renewal/exit states",
            "description": "Implement prototype interactions for the Student flow: Login → Dashboard → Pay Fees → Apply for Leave → Check Room → Renewal → Exit, demonstrating residency states.",
            "dependencies": [
              1
            ],
            "details": "Link Student Login to Dashboard using appropriate success and error states. From the Dashboard, wire quick actions to Pay Fees (including at least one payment-in-progress and success/failure variant), Apply for Leave (integrated with Task 18 leave forms and statuses), View Room Details, Renewal, and Exit flows. Use Smart Animate or instant transitions where appropriate to illustrate changes in resident status (Checked-in, Renewal Due, Renewed, Exit-initiated, Exited) via the tracker and badges. Demonstrate component variants such as tab switches, accordions, table row hover/selection (for histories), and notification states (unread vs read). Ensure that renewal completion returns to an updated Dashboard state, and exit completion reflects restricted or read-only access where applicable.",
            "status": "pending",
            "testStrategy": "Simulate a full Student session in the prototype: login, pay a fee, submit a leave request, inspect room details, complete a renewal, and initiate/complete exit. Verify that status indicators and dashboards update to the correct state screens and that there are no broken links or loops that trap the user."
          },
          {
            "id": 4,
            "title": "Wire superintendent, trustee, accounts, and parent role flows with key tasks and states",
            "description": "Create role-specific prototype wiring for superintendent, trustee, accounts, and parent journeys with their primary tasks and UI states.",
            "dependencies": [
              1
            ],
            "details": "For Superintendent, wire Login to Application Review lists, then to detail views enabling Approve/Forward paths, Leave Approval, and Config screens, showing table interactions (filters, sort hover, row selection) and action button states (default, hover, disabled). For Trustee, connect entry from a forwarded application list to application detail, Schedule Interview, and Final Decision frames, including at least one confirmation modal. For Accounts, wire navigation to receivables views (tables with pagination/filter variants) and Export actions with a feedback state (e.g., export-in-progress, success). For Parent, implement OTP Login (aligned with Task 8) through to a read-only Dashboard showing fee status, leave summary, and notifications, explicitly demonstrating disabled or hidden edit actions and view-only interactions like tabs or filters. Reuse interactive components and variants wherever possible to maintain consistency across admin and parent flows.",
            "status": "pending",
            "testStrategy": "Present each role’s flow independently and walk through its primary tasks: superintendent reviewing and approving/forwarding an application and a leave request, trustee scheduling an interview and recording a decision, accounts exporting receivables, and parent logging in via OTP and reviewing fees and leaves. Confirm that all critical buttons and navigation elements respond with a state change or screen transition, and that parent views do not expose any state-changing controls."
          },
          {
            "id": 5,
            "title": "Optimize prototype performance, overlays, and end-to-end validation",
            "description": "Add annotation overlays and hotspot hints, tune prototype settings for performance, and run a comprehensive validation to remove dead ends or incorrect transitions.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create dedicated annotation/legend frames or overlay components describing each persona’s flow, key assumptions, and any non-obvious interactions, then hook them up via info icons or a separate ‘Guided Tour’ flow. Add hotspot hints on complex screens to indicate clickable areas where discoverability is a concern. Review and simplify transitions or Smart Animate usage where performance may lag, and adjust device settings or remove unnecessary media to keep interactions smooth. Conduct a systematic link audit across all flows, checking that back, close, and alternative paths always return to a valid frame and that all modal overlays have both entry and exit interactions. Ensure every major component type (buttons, fields, tables, tabs, steppers, badges) is demonstrated with at least one interactive or variant-driven state somewhere in the prototype for stakeholder review.",
            "status": "pending",
            "testStrategy": "Use Figma’s prototype Present mode to run scripted end-to-end scenarios for each persona, deliberately testing edge paths (cancel, back, error, and overlay close actions) while monitoring for jank or long load times. Fix any dead links or misrouted transitions identified, then share the prototype with a small stakeholder set per role and collect feedback specifically on clarity of flows, discoverability of hotspots, and performance, iterating until no critical navigation or state-visibility issues remain."
          }
        ]
      },
      {
        "id": 26,
        "title": "Prepare developer handoff specifications and annotations",
        "description": "Document component specs, behaviors, and integration notes for developers consuming the Figma designs.",
        "details": "• For each core component and template screen, add measurement specs (spacing, typography, colors) using Figma Inspect-friendly naming.\n• Document interaction behaviors (hover, focus, active, disabled, loading) and transitions directly on component examples.\n• Add pseudo-code snippets and API shape hints where relevant (e.g., status enums, routing logic, OTP flows), while keeping stack-agnostic but React/Vue-friendly.\n• Define accessibility requirements and keyboard behavior per component.\n• Group these notes in a dedicated \"Dev Specs\" page with links to relevant designs.\n• Encourage use of Figma’s Dev Mode for direct asset export of icons and images; mark exportable elements.\n• Include guidance on mapping roles and permissions into the front-end (e.g., route guards, conditional rendering).\n",
        "testStrategy": "• Review Dev Mode to ensure all key components expose understandable names and tokens.\n• Conduct a handoff session mock where a dev navigates the file and confirms clarity.\n• Validate that all complex flows (multi-step forms, payments, approvals) have at least one annotated reference screen.\n• Update specs iteratively based on developer feedback.",
        "priority": "high",
        "dependencies": [
          2,
          23,
          24
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Component-level specs using Figma Dev Mode",
            "description": "Add measurement specs for tokens, spacing, typography, colors for core components and screens using Figma Inspect-friendly naming and Dev Mode conventions.",
            "dependencies": [],
            "details": "Apply consistent naming conventions (e.g., spacing-sm-8px, color-primary-#hex); mark exportable assets; ensure all states (default, hover, etc.) have specs visible in Dev Mode.",
            "status": "pending",
            "testStrategy": "Review Dev Mode inspect panel for all core components to confirm specs are accurate and accessible."
          },
          {
            "id": 2,
            "title": "Screen and flow-level interaction specs",
            "description": "Document behaviors, edge cases, routing, and role-based logic for template screens and flows like login, renewal, exit.",
            "dependencies": [
              1
            ],
            "details": "Annotate interactions (hover, focus, transitions) on examples; cover edge cases (invalid creds, expired links) and role logic (route guards, conditional rendering).",
            "status": "pending",
            "testStrategy": "Prototype key flows in Figma and simulate dev navigation to verify interaction clarity."
          },
          {
            "id": 3,
            "title": "Accessibility and keyboard requirements",
            "description": "Define a11y requirements and keyboard behaviors for each component and flow, including ARIA labels and navigation order.",
            "dependencies": [
              1
            ],
            "details": "Specify labels, contrast ratios, focus order; call out non-standard heading hierarchies; align with WCAG for forms, modals in tasks like documents and renewal.",
            "status": "pending",
            "testStrategy": "Use Figma prototype with keyboard navigation and screen reader simulation to validate."
          },
          {
            "id": 4,
            "title": "API shapes and pseudo-code for critical flows",
            "description": "Provide stack-agnostic pseudo-code and API hints for OTP, payments, approvals, status enums in flows like login, renewal.",
            "dependencies": [
              2
            ],
            "details": "Include snippets for status handling (pending/verified), routing logic; format as code blocks on relevant screens, React/Vue-friendly but neutral.",
            "status": "pending",
            "testStrategy": "Share snippets with sample dev for feedback on clarity and implementability."
          },
          {
            "id": 5,
            "title": "Organize dedicated Dev Specs section",
            "description": "Create a Dev Specs page grouping all notes with navigation links to designs, components, and flows.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Use clear headings, thumbnails, single source of truth; link to components/screens; encourage Dev Mode for exports; consistent naming across file.",
            "status": "pending",
            "testStrategy": "Mock handoff navigation: ensure devs can find specs without guidance."
          },
          {
            "id": 6,
            "title": "Conduct handoff validation and iterations",
            "description": "Run validation sessions with devs, gather feedback, and iterate on specs based on input.",
            "dependencies": [
              5
            ],
            "details": "Schedule mock handoff sessions; track feedback on clarity, completeness; update file with changes, notify via Dev Mode status.",
            "status": "pending",
            "testStrategy": "Post-session survey: confirm 90% spec clarity; re-test complex flows like payments post-iteration."
          }
        ]
      },
      {
        "id": 27,
        "title": "Set up Figma library organization and versioning strategy",
        "description": "Organize Figma files into libraries and define a versioning workflow for sustainable collaboration.",
        "details": "• Structure: one main Design System library file, and separate product files for Public (Landing/Applicant), Student, Admin (Superintendent/Trustee/Accounts), Parents/Alumni.\n• Enable library publishing for components and styles; define naming conventions and categories.\n• Establish a versioning practice: tag major milestones (v1.0 Admission MVP, v1.1 Renewal & Exit, etc.) with Figma file versions.\n• Set up branching or duplicate files for experimentation without disturbing the main library.\n• Document contribution guidelines for designers (how to add components, update tokens, deprecate components).\n• Provide notes for devs on how to subscribe to libraries and track breaking changes.\n",
        "testStrategy": "• Verify that all screens use library components rather than local components where intended.\n• Test library publishing and consumption in a sandbox Figma team project.\n• Review naming consistency and searchability of components.\n• Ensure at least one previous version is easily restorable from Figma history.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Figma file and library structure with clear naming conventions",
            "description": "Define the concrete Figma project, file, page, and component naming structure for the main Design System library and the product-specific files (Public, Student, Admin, Parents/Alumni).",
            "dependencies": [],
            "details": "Create or reorganize Figma projects to separate the core Design System from product work files. Within the Design System project, create a primary \"Design System – Foundations & Components\" file that will act as the main library, plus distinct product files for Public (Landing/Applicant), Student, Admin (Superintendent/Trustee/Accounts), and Parents/Alumni. Inside the library file, create pages for Foundations, Components, Patterns, and Documentation. Define and document a component and style naming convention (e.g., `Button / Primary / Filled`, `Form / Input / Text`, `Color / Background / Surface`) and map where system-level components live vs. where product-specific variants live. Add a short in-file documentation frame describing when to create or keep components in the system library vs. in product files, with examples for each role/vertical.",
            "status": "pending",
            "testStrategy": "Open each Figma project and verify that the Design System and all product files follow the agreed structure and naming patterns. Confirm that new components can be located predictably via the Assets panel search using the defined naming scheme."
          },
          {
            "id": 2,
            "title": "Configure library publishing, categorization of components/styles, and access permissions",
            "description": "Set up Figma library publishing for the Design System file, categorize components and styles, and ensure correct team/project permissions and library enablement settings.",
            "dependencies": [
              1
            ],
            "details": "In the Design System file, convert key UI elements into main components and define Color, Text, and Effect Styles for tokens, ensuring they are on clearly labeled pages (e.g., Foundations, Components). Open the Team Library or Libraries panel and publish the Design System file as a shared library, confirming that all required components and styles are included while excluding work-in-progress or nested helper elements not meant for consumption. Organize components into logical groups using pages, frames, and slash-based naming for categories (e.g., `Navigation / Tabs`, `Feedback / Toast`). For each product team/project, enable the Design System library and, if needed, set up additional smaller product libraries. Review and adjust file and project permissions so only designated maintainers can publish library updates, while all designers can consume the library.",
            "status": "pending",
            "testStrategy": "From a separate sandbox Figma file with only view access to the library, verify that components and styles appear under the expected categories and groups in the Assets and Styles panels. Confirm that non-maintainers cannot publish changes but can consume updates. Publish a small test change and ensure it appears as an update notification in consumer files."
          },
          {
            "id": 3,
            "title": "Define and implement Figma versioning and branching workflow",
            "description": "Create a practical versioning and experimentation process using Figma file versions, naming conventions, and branching or duplicates for safe iteration.",
            "dependencies": [
              1,
              2
            ],
            "details": "Decide on a version naming convention for milestones (e.g., `v1.0 Admission MVP`, `v1.1 Renewal & Exit`) and document when to create a named version (e.g., after a release, after major component changes). In the Design System file, create at least one example named version to validate the workflow. Define how designers should use Figma branching (if available) or duplicate files/pages for experiments: specify which file is the \"main\" library, who can create branches, how to label them (e.g., `branch/button-states-refactor`), and the process for merging or discarding. Document rollback expectations, including how to restore a previous version or revert published library changes. Capture this as a short \"Versioning & Branching\" section in the system documentation frame or a dedicated documentation file linked from the library.",
            "status": "pending",
            "testStrategy": "Create a test branch or duplicate file, make visible changes to a few components, then merge or replace them into the main library and publish. Verify that consumer files receive update prompts and that you can revert to a previous named version if needed. Check that the named versions history clearly reflects the milestone tags."
          },
          {
            "id": 4,
            "title": "Document designer contribution, change management, and deprecation guidelines",
            "description": "Create written guidelines and lightweight workflows for how designers add or modify components, update tokens, and deprecate or replace existing components in the library.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Within the Design System file (or a dedicated \"Design System – Docs\" file), create a Documentation page or frame titled \"Designer Contribution Guidelines.\" Specify step-by-step instructions for proposing new components (e.g., work in a dedicated playground page or branch, follow naming and property conventions, request review), updating foundations/tokens (color, type, spacing), and extending variants. Define what constitutes a breaking change and outline the required review process for such changes (e.g., design review, dev sign-off). Establish a deprecation model, including how to tag deprecated components (e.g., prepend `Deprecated /` in the name, add a red badge in the component thumbnail, update description with replacement information), how long deprecated components remain before removal, and how to communicate replacements to designers. Include visual examples and checklists directly in the documentation frame.",
            "status": "pending",
            "testStrategy": "Ask another designer to follow the written process to add a small new component and deprecate an old variant in a sandbox branch. Observe whether they can do so without verbal clarification. Verify that deprecated components are clearly identifiable in the Assets panel and have guidance pointing to replacements."
          },
          {
            "id": 5,
            "title": "Create developer consumption and update-tracking guidelines for Figma libraries",
            "description": "Provide clear instructions and norms for developers on how to subscribe to Figma libraries, interpret components/tokens, and safely track and adopt library updates without introducing breaking changes.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create a \"For Developers\" documentation frame or page in the Design System or a separate handoff/documentation file. Describe how devs should enable the Design System library in Figma or their inspection tool, where to find canonical components and styles, and how tokens map to implementation (e.g., token naming vs. CSS variables or design tokens in code). Outline the process for monitoring changes: how and when maintainers will announce new versions or breaking changes (e.g., release notes frame, Slack/Notion link), how to use Figma’s library update dialog to inspect diffs before accepting, and what to do if an update breaks a layout. Include examples of a typical \"release notes\" entry summarizing changed components, deprecated items, and recommended adoption steps. Ensure this documentation is shared with dev leads and linked from any engineering documentation hubs.",
            "status": "pending",
            "testStrategy": "Share the developer guidelines with at least one dev and ask them to enable the library in a fresh Figma file, inspect a component, and walk through accepting a test library update. Confirm they can map a component’s styles/tokens to implementation names and explain how they would detect and respond to a breaking change announcement."
          }
        ]
      },
      {
        "id": 28,
        "title": "Design notifications and in-app alerts system",
        "description": "Create consistent UI for in-app notifications, banners, and reminder alerts across modules.",
        "details": "• Notification center: bell icon with dropdown showing latest notifications (fees, renewal, leaves, interviews), with type icons and timestamps.\n• In-page banners for critical alerts (e.g., overdue fees, renewal due, interview today) using color-coded statuses.\n• Badge counts on main nav items (e.g., new applications, pending approvals).\n• Notification detail page listing full history with filters by type and date.\n• Use consistent language and tone across all alerts.\n• Provide dev notes on polling or push patterns conceptually (while leaving implementation details to tech stack), and on marking notifications as read.\n• Ensure notifications are accessible (screen-reader announcements guidance in notes, non-color-only distinctions).\n",
        "testStrategy": "• Verify all modules that need reminders/alerts have corresponding notification patterns.\n• Prototype reading and clearing notifications in student and admin views.\n• Check responsive behavior of the notification dropdown and banners.\n• Review with stakeholders that reminder timing (fee, renewal, interview) is communicated clearly.",
        "priority": "medium",
        "dependencies": [
          9,
          14,
          23
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define notification types, hierarchy, and UX patterns",
            "description": "Identify all notification and alert types across modules (fees, renewals, leaves, interviews, approvals, etc.) and define a clear hierarchy (e.g., passive info, warning, critical) with corresponding UX patterns (center dropdown item, in-page banner, badge, modal if needed).",
            "dependencies": [],
            "details": "Map events from related modules (accounts, renewal, exit, registration) to specific notification types and priorities. Define which events surface in the bell dropdown, which require in-page banners, and which only use badges. Specify behavior rules: ordering, grouping, when to auto-expire, when to require explicit dismissal, and how read/unread states work across views. Document triggers conceptually without going into stack-specific implementation.",
            "status": "pending",
            "testStrategy": "Review a matrix of event types versus notification channels (center, banner, badge, email/SMS if applicable) with stakeholders and validate that each use case is covered without over-notifying users."
          },
          {
            "id": 2,
            "title": "Design UI for notification center, banners, badges, and detail history",
            "description": "Create detailed UI layouts and interaction specs for the bell icon dropdown, in-page banners, nav badge counts, and the full notification history page with filters and empty/error states.",
            "dependencies": [
              1
            ],
            "details": "Design the notification center dropdown: bell icon states, unread indicator, max visible items, scroll behavior, hover/focus states, timestamps, type icons, and inline actions (e.g., mark as read). Define visual and interaction patterns for in-page banners, including placement rules, color/status mapping, icons, copy length, and dismissal. Specify badge styles and placement on main navigation items. Design the notification history page with sorting, type/date filters, pagination, bulk actions, and mobile-responsive behavior. Provide UI specs, components, and variants in the design system file.",
            "status": "pending",
            "testStrategy": "Prototype interactions for the dropdown, banners, and history page; run through common scenarios (many unread items, no notifications, mixed types) and validate responsiveness and usability with quick stakeholder or hallway tests."
          },
          {
            "id": 3,
            "title": "Define content guidelines, accessibility, and developer notes for notifications",
            "description": "Create guidelines for notification copy, tone, accessibility requirements, and conceptual dev notes on delivery (polling/push) and read-state handling.",
            "dependencies": [
              1,
              2
            ],
            "details": "Write copy patterns and templates for common notification types (fees, renewals, leaves, interviews) to ensure consistent tone, brevity, and clarity. Define rules for titles, body text, CTAs, and timestamps. Add accessibility guidance: ARIA roles, screen reader announcement behavior, focus management, keyboard navigation, and non-color visual distinctions for status. Provide conceptual notes for engineers on polling vs. push patterns, deduplication, throttling, and how notifications transition between unseen/unread/read across devices and sessions, without prescribing specific tech-stack implementations.",
            "status": "pending",
            "testStrategy": "Review guidelines with design, content, and engineering leads to ensure feasibility; perform spot-checks on sample screens for adherence to tone, accessibility checks (using screen reader and keyboard navigation), and consistency of read/unread behavior across mocked flows."
          }
        ]
      },
      {
        "id": 29,
        "title": "Design print-optimized templates for forms, letters, undertakings, and receipts",
        "description": "Create dedicated A4-friendly designs for all printable artifacts required for audit and physical submission.",
        "details": "• Templates to include:\n  - Application summary form.\n  - Provisional and final admission letters.\n  - Undertakings and consent forms (student, parent, local guardian).\n  - Fee receipts.\n  - Exit certificates.\n• Use A4-sized frames with defined margins (~20–25mm), mono/duo-color scheme to reduce ink usage, and legible fonts at print sizes.\n• Include institutional header (logo, name, address), reference numbers, dates, and signature blocks.\n• Keep layouts simple and use table structures for data where appropriate.\n• Add small footers with DPDP/data usage disclaimers where relevant.\n• Ensure the content aligns with on-screen information to avoid discrepancies.\n• Provide guidance in notes on mapping these templates to PDF generation in the application layer.\n",
        "testStrategy": "• Export each template as PDF and print on test printer or viewer to check readability and alignment.\n• Cross-check data fields vs respective on-screen counterparts.\n• Review with administrative staff/stakeholders for acceptance and compliance.\n• Iterate to fix any clipping or layout issues observed on physical prints.",
        "priority": "high",
        "dependencies": [
          11,
          15,
          20,
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design A4 Layout Framework and Common Elements",
            "description": "Establish standardized A4 page setup with margins (20-25mm), mono/duo-color scheme, legible fonts, institutional header (logo, name, address), footers with DPDP disclaimers, and signature blocks for all templates.",
            "dependencies": [],
            "details": "Use 210x297mm A4 dimensions at 300 DPI; apply table structures for data alignment; ensure print optimization with CMYK, simple grids (e.g., 8pt), and hierarchy (headlines 18-24pt, body 9-12pt); test for ink efficiency.",
            "status": "pending",
            "testStrategy": "Export to PDF, print test for margins/alignment/readability; verify color usage and font legibility at print size."
          },
          {
            "id": 2,
            "title": "Create Templates for Forms and Letters",
            "description": "Design print-optimized templates for application summary form, provisional/final admission letters, undertakings/consent forms (student, parent, local guardian), incorporating reference numbers, dates, and data mapping.",
            "dependencies": [
              1
            ],
            "details": "Structure forms with tables for fields matching on-screen data; letters with formal layout, placeholders for dynamic content; keep simple, aligned with institutional branding and audit requirements.",
            "status": "pending",
            "testStrategy": "Cross-check fields against application screens; PDF export/print review for discrepancies; stakeholder feedback on content alignment."
          },
          {
            "id": 3,
            "title": "Design Receipts, Exit Certificates, and Integration Notes",
            "description": "Develop fee receipts and exit certificates templates; provide developer guidance on PDF generation mapping from application layer.",
            "dependencies": [
              1
            ],
            "details": "Receipts with tabular fee breakdown, receipt numbers; certificates with formal borders/signatures; include notes on variable data insertion, PDF export standards (PDF/X), and avoiding print issues like clipping.",
            "status": "pending",
            "testStrategy": "Print prototypes on A4; validate data population simulation; admin staff review for compliance and usability in physical submission."
          }
        ]
      },
      {
        "id": 30,
        "title": "Conduct usability review and iterate on critical flows",
        "description": "Run internal usability checks on critical flows and refine designs based on findings.",
        "details": "• Focus flows: admission application, login and dashboard, payment, leave request, renewal, exit.\n• Prepare small test scenarios and tasks for representative users or internal testers.\n• Use Figma prototype, observe navigation paths, error recovery behavior, and comprehension of labels.\n• Collect prioritized list of issues (e.g., confusing labels, hidden CTAs, dense tables) and update designs accordingly.\n• Pay special attention to multi-role clarity (ensuring users always know which role and vertical context they are in).\n• Document key changes and rationale in a short changelog within the Figma project.\n",
        "testStrategy": "• Conduct at least one review session per main persona and capture feedback.\n• Re-test updated designs to confirm issues are resolved.\n• Validate that no critical path (apply, pay, renew, exit) has usability blockers.\n• Have stakeholders sign off on revised prototypes as v1.0 release-ready.",
        "priority": "medium",
        "dependencies": [
          25
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Prepare Usability Test Plan and Scenarios",
            "description": "Develop detailed test scenarios, tasks, and scripts for the specified critical flows using Figma prototype, focusing on navigation, error recovery, labels, and multi-role clarity.",
            "dependencies": [],
            "details": "Define in-scope flows (admission application, login/dashboard, payment, leave request, renewal, exit); create 3-5 tasks per flow with realistic scenarios; pilot test scripts internally; document goals, success metrics, and personas per NN/g and Nielsen methods.",
            "status": "pending",
            "testStrategy": "Review plan with team for completeness; simulate one full session to validate task clarity and timing."
          },
          {
            "id": 2,
            "title": "Conduct Internal Usability Testing Sessions",
            "description": "Run moderated usability tests with internal testers or representative users on Figma prototype, observing key behaviors and collecting feedback on critical flows.",
            "dependencies": [
              1
            ],
            "details": "Schedule 4-6 sessions covering all flows; use think-aloud protocol; record navigation paths, error recovery, label comprehension, and role/vertical context awareness; note issues like confusing labels, hidden CTAs, dense tables.",
            "status": "pending",
            "testStrategy": "Capture video recordings; debrief after each session; ensure at least one test per main persona and flow."
          },
          {
            "id": 3,
            "title": "Analyze Findings, Iterate Designs, and Document",
            "description": "Prioritize issues from test data, update Figma designs, re-test fixes, and create changelog with rationale.",
            "dependencies": [
              2
            ],
            "details": "Theme and prioritize issues by severity/frequency (e.g., critical paths first); refine designs for multi-role clarity; validate no blockers in apply/pay/renew/exit; add changelog frame in Figma with before/after and rationale.",
            "status": "pending",
            "testStrategy": "Re-test updated flows with 2-3 quick sessions; get stakeholder sign-off on v1.0 readiness."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-12-19T17:55:28.318Z",
      "updated": "2025-12-19T17:55:28.318Z",
      "description": "Tasks for master context"
    }
  }
}